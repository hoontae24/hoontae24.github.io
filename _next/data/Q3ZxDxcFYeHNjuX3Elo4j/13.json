{"env":{"BASE_PATH":"","ARTICLES_ROOT":".articles","ARTICLE_FILENAME":"README.md"},"__N_SSG":true,"pageProps":{"post":{"href":"13","round":13,"paths":["javascript","javascript-performance-to-generate-dictionary"],"slug":"javascript-performance-to-generate-dictionary","title":"자바스크립트, 딕셔너리를 만드는 가장 빠른 방법은?","description":"","date":"2020-04-12","category":"javascript","tags":["javascript","data structure"],"seriesId":null,"markdown":"\n![js dictionary](/javascript/javascript-performance-to-generate-dictionary/img/js_dictionary.png)\n\n자바스크립트 개발을 하면서 여러가지 자료구조를 사용하게 됩니다. 가장 많이 쓰이는 것은 역시 `Array(배열)`이겠죠? 그리고 데이터에 맞게 `Object(객체)`를 만들어 사용하기도 합니다. `Prototype`을 이용하거나, `ES6`의 `Class` 문법을 통해 객체 생성자를 만들어 사용하기도 합니다.\n\n오늘 포스트에서 살펴볼 자료구조는 바로 `Dictionary`입니다. `Dictionary`는 자바스크립트에는 없는 자료형 이름인데, `Object(객체)`와 동일합니다. `key`, `value` 쌍으로 이루어진 객체를 통해 데이터를 취급하는 자료구조입니다. `파이썬`에서는 `Dictionary`라고 부르기도 하죠. 제가 `Dictionary`라고 부르는 이유는 바로 사용 목적에 있습니다. `key`를 이용하여 데이터를 취급하는 객체라는 것을 명시적으로 나타내기 위해 `Dictionary`라고 명명하도록 하겠습니다.\n\n---\n\n### 언제 사용할까?\n\n`Dictionary`는 언제 사용할까요? 여러가지 상황에서 사용할 수 있지만 오늘은 배열에 있는 항목을 `index`가 아닌 다른 값으로 접근하고자 할 때, `Dictionary`를 만들어 사용해 보도록 하겠습니다.\n\n먼저 다음과 같은 배열이 있다고 합시다.\n\n```js\nconst items = [\n  { id: 1, name: \"banana\" },\n  { id: 2, name: \"apple\" },\n  { id: 3, name: \"orange\" },\n  // ...\n];\n```\n\n`items`배열의 항목은 `index`를 이용하여 바로 접근할 수 있지만, `index`를 알지 못하고 `id`를 통해 접근해야 한다면 어떻게 할까요? 만약 배열이 크지 않거나, 자주 하는 작업이 아니라면 다음과 같이 할 수도 있을겁니다.\n\n```js\nconst itemId = 1;\nconst item = items.find((item) => item.id === itemId);\n```\n\n하지만 위 작업은 실행할 때 마다 `O(n)`의 시간복잡도를 가지게 됩니다. 이 작업이 반복된다면 꽤 부담스러울 수도 있습니다. 그래서 `id`를 `key`로 하는 딕셔너리를 만들어서 사용합니다. `items`를 딕셔너리로 만들면 다음과 같습니다.\n\n```js\n// item의 id를 key로 가지는 딕셔너리\nconst itemDict = {\n  1: { id: 1, name: \"banana\" },\n  2: { id: 2, name: \"apple\" },\n  3: { id: 3, name: \"orange\" },\n};\n```\n\n---\n\n### 딕셔너리 만들기\n\n딕셔너리를 만드는 방법은 아주 간단합니다. 객체를 만들고 `id`를 `key`로 하는 값을 할당해주면 됩니다.\n\n```js\nconst itemDict = {};\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  itemDict[item.id] = item;\n}\n```\n\n간단한 반복 작업이기 때문에 `for`문이 아닌 다른 방법을 이용할 수도 있습니다. `items`의 항목이 많거나 각 항목이 복잡한 구조라면 딕셔너리를 만드는 것도 부담이 될 수 있습니다. 그래서 어떤 방법으로 딕셔너리를 만드는 것이 빠르고 적은 부담인지 알아보도록 하겠습니다.\n\n---\n\n### 여러가지 방법 비교해보기\n\n##### JSBen.ch 이용하기\n\n![JSBen.ch](/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch.png)\n\n[JSBen.ch](https://jsben.ch/)는 여러가지 케이스를 생성하여 비교해볼 수 있는 자바스크립트 벤치마킹 서비스입니다. **BROWSE** 탭을 열어보면 다른 벤치마크 테스트들을 볼 수 있습니다. 가장 views가 많은 **check object key**의 결과를 다음과 같이 한 눈에 볼 수 있습니다.\n\n![JSBen.ch](/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch_check_object_key.png)\n\n#### Setup Block 작성하기\n\n벤치마크에 사용될 기본적인 초기값을 설정해줍니다. 벤치마크 테스트에는 포함되지 않습니다. 딕셔너리로 만들 `items` 배열을 초기화해줍니다.\n\n```js\nconst itemCount = 100000;\nconst items = new Array(itemCount).fill(true).map((_, i) => {\n  return { id: i + 1, value: Math.random() };\n});\n```\n\n#### 테스트 케이스\n\n딕셔너리를 만드는 테스트 케이스를 각 코드블럭에 작성하겠습니다.\n\n##### 1. for\n\n```js\nconst result = {};\nfor (let i = 0; i < itemCount; i++) {\n  result[items[i].id] = items[i];\n}\n```\n\n##### 2. for in\n\n```js\nconst result = {};\nlet i;\nfor (i in items) {\n  result[items[i].id] = items[i];\n}\n```\n\n##### 3. for of\n\n```js\nconst result = {};\nlet item;\nfor (item of items) {\n  result[item.id] = item;\n}\n```\n\n##### 4. forEach\n\n```js\nconst result = {};\nitems.forEach((item) => (result[item.id] = item));\n```\n\n##### 5. reduce\n\n```js\nconst result = items.reduce((res, item) => {\n  res[item.id] = item;\n  return res;\n}, {});\n```\n\n##### 6. lodash keyBy / key-name\n\n```js\nconst result = _.keyBy(items, \"id\");\n```\n\n##### 7. lodash keyBy / key-callback\n\n```js\nconst result = _.keyBy(items, (item) => item.id);\n```\n\n#### 벤치마크 테스트하기\n\n이제 테스트 케이스가 작성했으니, 테스트를 실행해 보겠습니다. 다음과 같은 결과가 나왔습니다.\n\n![JSBen.ch](/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch_result_1.png)\n\n가장 단순한 `for`문이 가장 빠른 결과를 보여줍니다. `for in`문은 상대적으로 많이 느린 동작을 보여줍니다. `Array`의 메소드인 `forEach`와 `reduce`는 비슷한 속도를 가지고 있고, `lodash.keyBy`도 방식은 달라도 비슷한 속도를 보여줍니다.\n\n---\n\n### 마무리\n\n`Dictionary` 만들기라는 주제로 자바스크립트 반복문의 성능에 대해 간단히 알아보았습니다. 실제 개발을 할 때는 `for`문 보다 `reduce`나 `map`같이 `Array`메소드를 많이 활용하는데, 상황에 따라 필요한 것을 사용해야 할 것 같습니다. 간단한 작업이라면 성능을 많이 요구하지 않을테니 아무거나 사용해도 괜찮겠지만요.\n\n여기까지 구문에 따라 다른 성능을 보여주는 여러가지 반복문에 대해 알아보았습니다. 다음에 기회가 된다면 각 구문에 왜 다른 성능을 보여주는지, 어떤 상황에서 어떤 방법이 유리한 지 분석해보는 시간도 가져보겠습니다.\n","html":"<p><img src=\"/javascript/javascript-performance-to-generate-dictionary/img/js_dictionary.png\" alt=\"js dictionary\"></p>\n<p>자바스크립트 개발을 하면서 여러가지 자료구조를 사용하게 됩니다. 가장 많이 쓰이는 것은 역시 <code>Array(배열)</code>이겠죠? 그리고 데이터에 맞게 <code>Object(객체)</code>를 만들어 사용하기도 합니다. <code>Prototype</code>을 이용하거나, <code>ES6</code>의 <code>Class</code> 문법을 통해 객체 생성자를 만들어 사용하기도 합니다.</p>\n<p>오늘 포스트에서 살펴볼 자료구조는 바로 <code>Dictionary</code>입니다. <code>Dictionary</code>는 자바스크립트에는 없는 자료형 이름인데, <code>Object(객체)</code>와 동일합니다. <code>key</code>, <code>value</code> 쌍으로 이루어진 객체를 통해 데이터를 취급하는 자료구조입니다. <code>파이썬</code>에서는 <code>Dictionary</code>라고 부르기도 하죠. 제가 <code>Dictionary</code>라고 부르는 이유는 바로 사용 목적에 있습니다. <code>key</code>를 이용하여 데이터를 취급하는 객체라는 것을 명시적으로 나타내기 위해 <code>Dictionary</code>라고 명명하도록 하겠습니다.</p>\n<hr>\n<h3 id=\"언제-사용할까\">언제 사용할까?</h3>\n<p><code>Dictionary</code>는 언제 사용할까요? 여러가지 상황에서 사용할 수 있지만 오늘은 배열에 있는 항목을 <code>index</code>가 아닌 다른 값으로 접근하고자 할 때, <code>Dictionary</code>를 만들어 사용해 보도록 하겠습니다.</p>\n<p>먼저 다음과 같은 배열이 있다고 합시다.</p>\n<pre><code class=\"language-js\">const items = [\n  { id: 1, name: &quot;banana&quot; },\n  { id: 2, name: &quot;apple&quot; },\n  { id: 3, name: &quot;orange&quot; },\n  // ...\n];\n</code></pre>\n<p><code>items</code>배열의 항목은 <code>index</code>를 이용하여 바로 접근할 수 있지만, <code>index</code>를 알지 못하고 <code>id</code>를 통해 접근해야 한다면 어떻게 할까요? 만약 배열이 크지 않거나, 자주 하는 작업이 아니라면 다음과 같이 할 수도 있을겁니다.</p>\n<pre><code class=\"language-js\">const itemId = 1;\nconst item = items.find((item) =&gt; item.id === itemId);\n</code></pre>\n<p>하지만 위 작업은 실행할 때 마다 <code>O(n)</code>의 시간복잡도를 가지게 됩니다. 이 작업이 반복된다면 꽤 부담스러울 수도 있습니다. 그래서 <code>id</code>를 <code>key</code>로 하는 딕셔너리를 만들어서 사용합니다. <code>items</code>를 딕셔너리로 만들면 다음과 같습니다.</p>\n<pre><code class=\"language-js\">// item의 id를 key로 가지는 딕셔너리\nconst itemDict = {\n  1: { id: 1, name: &quot;banana&quot; },\n  2: { id: 2, name: &quot;apple&quot; },\n  3: { id: 3, name: &quot;orange&quot; },\n};\n</code></pre>\n<hr>\n<h3 id=\"딕셔너리-만들기\">딕셔너리 만들기</h3>\n<p>딕셔너리를 만드는 방법은 아주 간단합니다. 객체를 만들고 <code>id</code>를 <code>key</code>로 하는 값을 할당해주면 됩니다.</p>\n<pre><code class=\"language-js\">const itemDict = {};\nfor (let i = 0; i &lt; items.length; i++) {\n  const item = items[i];\n  itemDict[item.id] = item;\n}\n</code></pre>\n<p>간단한 반복 작업이기 때문에 <code>for</code>문이 아닌 다른 방법을 이용할 수도 있습니다. <code>items</code>의 항목이 많거나 각 항목이 복잡한 구조라면 딕셔너리를 만드는 것도 부담이 될 수 있습니다. 그래서 어떤 방법으로 딕셔너리를 만드는 것이 빠르고 적은 부담인지 알아보도록 하겠습니다.</p>\n<hr>\n<h3 id=\"여러가지-방법-비교해보기\">여러가지 방법 비교해보기</h3>\n<h5 id=\"jsbench-이용하기\">JSBen.ch 이용하기</h5>\n<p><img src=\"/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch.png\" alt=\"JSBen.ch\"></p>\n<p><a href=\"https://jsben.ch/\">JSBen.ch</a>는 여러가지 케이스를 생성하여 비교해볼 수 있는 자바스크립트 벤치마킹 서비스입니다. <strong>BROWSE</strong> 탭을 열어보면 다른 벤치마크 테스트들을 볼 수 있습니다. 가장 views가 많은 <strong>check object key</strong>의 결과를 다음과 같이 한 눈에 볼 수 있습니다.</p>\n<p><img src=\"/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch_check_object_key.png\" alt=\"JSBen.ch\"></p>\n<h4 id=\"setup-block-작성하기\">Setup Block 작성하기</h4>\n<p>벤치마크에 사용될 기본적인 초기값을 설정해줍니다. 벤치마크 테스트에는 포함되지 않습니다. 딕셔너리로 만들 <code>items</code> 배열을 초기화해줍니다.</p>\n<pre><code class=\"language-js\">const itemCount = 100000;\nconst items = new Array(itemCount).fill(true).map((_, i) =&gt; {\n  return { id: i + 1, value: Math.random() };\n});\n</code></pre>\n<h4 id=\"테스트-케이스\">테스트 케이스</h4>\n<p>딕셔너리를 만드는 테스트 케이스를 각 코드블럭에 작성하겠습니다.</p>\n<h5 id=\"1-for\">1. for</h5>\n<pre><code class=\"language-js\">const result = {};\nfor (let i = 0; i &lt; itemCount; i++) {\n  result[items[i].id] = items[i];\n}\n</code></pre>\n<h5 id=\"2-for-in\">2. for in</h5>\n<pre><code class=\"language-js\">const result = {};\nlet i;\nfor (i in items) {\n  result[items[i].id] = items[i];\n}\n</code></pre>\n<h5 id=\"3-for-of\">3. for of</h5>\n<pre><code class=\"language-js\">const result = {};\nlet item;\nfor (item of items) {\n  result[item.id] = item;\n}\n</code></pre>\n<h5 id=\"4-foreach\">4. forEach</h5>\n<pre><code class=\"language-js\">const result = {};\nitems.forEach((item) =&gt; (result[item.id] = item));\n</code></pre>\n<h5 id=\"5-reduce\">5. reduce</h5>\n<pre><code class=\"language-js\">const result = items.reduce((res, item) =&gt; {\n  res[item.id] = item;\n  return res;\n}, {});\n</code></pre>\n<h5 id=\"6-lodash-keyby--key-name\">6. lodash keyBy / key-name</h5>\n<pre><code class=\"language-js\">const result = _.keyBy(items, &quot;id&quot;);\n</code></pre>\n<h5 id=\"7-lodash-keyby--key-callback\">7. lodash keyBy / key-callback</h5>\n<pre><code class=\"language-js\">const result = _.keyBy(items, (item) =&gt; item.id);\n</code></pre>\n<h4 id=\"벤치마크-테스트하기\">벤치마크 테스트하기</h4>\n<p>이제 테스트 케이스가 작성했으니, 테스트를 실행해 보겠습니다. 다음과 같은 결과가 나왔습니다.</p>\n<p><img src=\"/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch_result_1.png\" alt=\"JSBen.ch\"></p>\n<p>가장 단순한 <code>for</code>문이 가장 빠른 결과를 보여줍니다. <code>for in</code>문은 상대적으로 많이 느린 동작을 보여줍니다. <code>Array</code>의 메소드인 <code>forEach</code>와 <code>reduce</code>는 비슷한 속도를 가지고 있고, <code>lodash.keyBy</code>도 방식은 달라도 비슷한 속도를 보여줍니다.</p>\n<hr>\n<h3 id=\"마무리\">마무리</h3>\n<p><code>Dictionary</code> 만들기라는 주제로 자바스크립트 반복문의 성능에 대해 간단히 알아보았습니다. 실제 개발을 할 때는 <code>for</code>문 보다 <code>reduce</code>나 <code>map</code>같이 <code>Array</code>메소드를 많이 활용하는데, 상황에 따라 필요한 것을 사용해야 할 것 같습니다. 간단한 작업이라면 성능을 많이 요구하지 않을테니 아무거나 사용해도 괜찮겠지만요.</p>\n<p>여기까지 구문에 따라 다른 성능을 보여주는 여러가지 반복문에 대해 알아보았습니다. 다음에 기회가 된다면 각 구문에 왜 다른 성능을 보여주는지, 어떤 상황에서 어떤 방법이 유리한 지 분석해보는 시간도 가져보겠습니다.</p>\n","excerpt":" 자바스크립트 개발을 하면서 여러가지 자료구조를 사용하게 됩니다. 가장 많이 쓰이는 것은 역시 Array(배열)이겠죠? 그리고 데이터에 맞게 Object(객체)를 만들어 사용하기도 합니다. Prototype을 이용하거나, ES6의 Class 문법을 통해 객체 생성자를 만들어 사용하기도 합니다. 오늘 포스트에서 살펴볼 자료구조는 바로 Dictionary입니다.","thumbnail":"/javascript/javascript-performance-to-generate-dictionary/img/js_dictionary.png","thumbnailUrl":"https://hoontae24.github.io/javascript/javascript-performance-to-generate-dictionary/img/js_dictionary.png"},"url":"https://hoontae24.github.io/13"}}