{"env":{"BASE_PATH":"","ARTICLES_ROOT":".articles","ARTICLE_FILENAME":"README.md"},"__N_SSG":true,"pageProps":{"post":{"href":"4","round":4,"paths":["svelte","svelte-store-and-crud"],"slug":"svelte-store-and-crud","title":"Svelte로 만드는 TODO-App (2), 데이터 Store 구현하기 / 간단한 CRUD 구현하기","description":"","date":"2019-11-22","category":"svelte","tags":["javascript","frontend","svelte"],"seriesId":2,"markdown":"\n![svelte](/svelte/svelte-store-and-crud/img/svelte_2.png)\n\n지난 시간에 이어서 `boards`와 `items` 데이터를 `Store`를 만들어서 관리하고, `CRUD`를 구현하겠습니다.\n\n### 1. Store 구현하기\n\n`Svelte`는 이미 `Store` 기능을 내장하고 있습니다. `svelte/store`를 `import`하면 그 기능을 사용할 수 있습니다.\n\n먼저 `Store`를 구현할 파일을 만들도록 하겠습니다. `/src`폴더 아래에 `stores`폴더를 만들고, `index.js`파일을 생성합니다.\n\n만약 `Store`로 사용할 데이터가 많다면 `/stores`폴더 안에 여러 파일을 만들어 구현하면 관리가 편하겠지만, 현재 프로젝트에서는 `boards`와 `items` 두 개의 데이터만 관리하면 되니, `index.js`파일 안에 함께 구현하도록 하겠습니다.\n\n`Store`에 대한 기본 지식은 [svelte/store 공식 API 문서](https://svelte.dev/docs#svelte_store)를 참조해주세요.\n\n#### 1.1 boards 데이터 Store로 구현하기\n\n이제 `/src/stores/index.js`파일을 다음과 같이 작성합니다.\n\n```js\n// src/stores/index.js\nimport { writable } from 'svelte/store'\nimport uuid from 'uuid/v4'\n\nconst _boards = [\n  { id: 1, title: 'Planning' },\n  { id: 2, title: 'In Progress' },\n  { id: 3, title: 'All Done' },\n]\n\nconst createBoards = () => {\n  const boards = writable(_boards)\n  const { subscribe, reset, update: _update } = boards\n\n  const add = () => {\n    _update(boards => boards.concat({ id: uuid(), title: '' }))\n  }\n\n  const remove = board => {\n    if (!board) return\n    _update(boards => boards.filter(_board => _board.id !== board.id))\n  }\n\n  const update = board => {\n    if (!board) return\n    _update(boards =>\n      boards.map(_board => (_board.id === board.id ? board : _board)),\n    )\n  }\n\n  return { subscribe, reset, add, remove, update }\n}\n\nexport const boards = createBoards()\n```\n\n`Store 모듈`에서 불러온 `writable`함수의 파라미터로 초기화 할 `boards`데이터를 넣어줍니다.\n\n생성된 `Store`객체 `boards`에서 `update`메소드를 이용해 `add`, `remove`, `update` 함수를 구현합니다. (`update`라는 이름의 함수를 따로 구현하기 위해서 원래의 `update`메소드를 `_update`로 명명하였음.)\n\n`createBoards`함수가 리턴하는 객체의 `add`, `remove`, `update`함수는 데이터를 다루는 데에 사용하기 위해 구현하였고, `subscribe`, `reset`함수는 컴포넌트 내에서 `$boards`로 접근하기 위해서 함께 넘겨줍니다.\n\n`add`함수에서 `board`를 생성하려고 할 때 id가 필요한데, 중복되지 않는 값이 필요하므로 `uuid`를 사용하도록 하겠습니다. 상단에서 `uuid`를 import 하고, 콘솔로 가서 모듈을 설치하겠습니다.\n\n> \\$ npm install uuid\n\n`package.json`파일을 열어보면, 다음과 같이 모듈이 의존성에 추가된 것을 볼 수 있습니다.\n\n```json\n// package.json\n\"dependencies\": {\n    \"sirv-cli\": \"^0.4.4\",\n    \"uuid\": \"^3.3.3\"\n  },\n```\n\n다음은 `App.svelte`파일로 가서 만들어둔 `boards`를 불러오겠습니다.\n\n`./stores`에서 `boards`를 import하고, 기존에 사용하던 boards배열 데이터는 삭제하겠습니다.\n\n```html\n<!-- App.svelte -->\n<script>\n  import { boards } from './stores'\n\n  // 기존의 데이터는 삭제\n  // const boards = [\n  //   { id: 1, title: 'Planning' },\n  //   { id: 2, title: 'In Progress' },\n  //   { id: 3, title: 'All Done' },\n  // ]\n\n  // (... 생략 ...)\n</script>\n\n<!-- 기존의 boards를 $boards로 바꿔줍니다. -->\n<!-- {#each boards as board (board.id)} -->\n{#each $boards as board (board.id)}\n<div class=\"item\">\n  <Board board={board} items={items.filter(item => item.boardId === board.id)}\n  />\n</div>\n{/each}\n\n<!-- (... 생략 ...) -->\n```\n\n앞서 말했던 것 처럼, `boards`자체는 `Store`객체이기 때문에, 해당하는 데이터에 접근하려면 `$`를 앞에 붙여야 합니다.\n\n이제 페이지로 접속해서 여전히 잘 동작하는지 확인해보세요. `Store`가 잘 생성되었는지 확인하기 위해서 `boards`의 기본 데이터를 변경해보고, 반영되는지 확인하면 됩니다.\n\n#### 1.2 items 데이터 Store로 구현하기\n\n다음은 `items`데이터를 `Store`로 구현하겠습니다. `boards`에서 했던 것과 거의 동일합니다.\n\n`stores/index.js`파일로 가서 아래의 내용을 추가하겠습니다.\n\n```js\n// stores/index.js\nconst _items = [\n  { id: 1, boardId: 1, title: '자료 조사하기', done: false },\n  { id: 2, boardId: 1, title: '교양책 읽기', done: false },\n  { id: 3, boardId: 2, title: '분리수거하기', done: false },\n  { id: 4, boardId: 2, title: '가계부 정리하기', done: false },\n  { id: 5, boardId: 3, title: '버그 수정하기', done: false },\n]\n\nconst createItems = () => {\n  const items = writable(_items)\n  const { subscribe, reset, update: _update } = items\n\n  const add = boardId => {\n    if (!boardId) return\n    _update(items =>\n      items.concat({ id: uuid(), boardId, title: '', done: false }),\n    )\n  }\n\n  const remove = item => {\n    if (!item) return\n    _update(items => items.filter(_item => _item.id !== item.id))\n  }\n\n  const update = item => {\n    if (!item) return\n    _update(items => items.map(_item => (_item.id === item.id ? item : _item)))\n  }\n\n  return { subscribe, reset, add, remove, update }\n}\n\nexport const items = createItems()\n```\n\n`boards`와 다른 부분은 `add`함수에서 `item`을 생성할 때, 어느 `board`에 소속해야할 지 알기 위해 `boardId`를 파라미터로 받는 부분입니다. 나머지는 동일합니다.\n\n이제 `App.svelte`파일로 가서 `items`를 삭제합니다.\n\n```html\n<!-- App.svelte -->\n<script>\n  // 기존 데이터 삭제\n  // const items = [\n  //   { id: 1, boardId: 1, title: '자료 조사하기', done: false},\n  //   { id: 2, boardId: 1, title: '교양책 읽기', done: false},\n  //   { id: 3, boardId: 2, title: '분리수거하기', done: false},\n  //   { id: 4, boardId: 2, title: '가계부 정리하기', done: false},\n  //   { id: 5, boardId: 3, title: '버그 수정하기', done: false},\n  // ]\n</script>\n\n<!-- Board에 주입해주었던 items를 삭제합니다 -->\n<Board board={board} />\n```\n\n`Board.svelte`로 가서 `Store`의 `items`를 `import`하고, `$items`로 접근하여 해당 `board`에 연결된 `items`를 불러오게 `filter`를 걸어줍니다. (원래 `Board.svelte`에 있던 부분을 옮겼습니다.)\n\n`$`를 이용해 `_items`에 반응성 변수를 만들고 해당 `board`의 `items`를 접근합니다.\n\n기존에 `items`로 접근했던 부분을 `_items`로 변경해주세요.\n\n```html\n<!-- Board.svelte -->\n<script>\n  import { items } from '../stores'\n\n  // 기존에 props로 주입되었던 items는 삭제합니다.\n  // export items = []\n  $: _items = $items.filter(item => item.boardId === board.id)\n</script>\n<!-- \"items\" -> \"_items\" -->\n{#each _items as item (item.id)}\n<Item {item} />\n{/each}\n```\n\n페이지로 가서 잘 동작하는지 확인해보세요.\n\n**Todo-app**에서 사용할 `boards`와 `items`데이터를 `Store`로 구현해 보았습니다. 페이지는 변한 것 없이 그대로지만, 데이터를 관리하는 부분은 수월해졌습니다. 만약 `Store`를 이용하지 않으려면, 자식 컴포넌트로 [이벤트](https://svelte.dev/docs#createEventDispatcher)를 전달해서 데이터를 변경하거나, [bind된 속성](https://svelte.dev/docs#bind_component_property)을 이용하면 됩니다.\n\n---\n\n### 2. Item CRUD 구현하기\n\n> **CRUD**는 _대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다._ (참조. 위키백과)\n\n**Item**의 동작은 **추가(C)**, **읽기(R)**, **변경(U)**, **삭제(D)** 정도가 있습니다. **읽기**는 따로 구현할 것 없이 지금처럼 보이기만 하면 됩니다.\n\n**추가**와 **삭제**는 버튼을 통해 단순하게 동작하도록 먼저 만들고, **변경**은 **Item**의 제목을 변경하고, **done**속성을 이용하여 완료 체크를 할 수 있도록 만들어 보겠습니다.\n\n#### 2.1 Item 추가 기능 구현하기\n\n`Item`을 추가하는 방법은 여러가지로 구현할 수 있겠지만, 각 `Board`에 있는 `추가`버튼을 클릭하면 해당 `Board`에 새로운 `Item`이 추가되도록 구현해 보겠습니다.\n\n먼저, `Board`의 우측 하단에 버튼을 하나 만들겠습니다.\n\n```html\n<!-- Board.svelte -->\n<!-- card-body안쪽의 마지막 부분에 버튼을 추가합니다. -->\n<div class=\"card-action\">\n  <button class=\"add-item\">+</button>\n</div>\n\n<style>\n  /* 간단한 스타일을 지정합니다. */\n  .add-item {\n    float: right;\n    width: 35px;\n    height: 35px;\n    padding: 0;\n  }\n</style>\n```\n\n버튼을 클릭하면 새로운 `Item`이 추가되도록 하겠습니다. `Board.svelte` 파일에 `handleAddItem`함수를 만들고 방금 생성한 버튼에 연결시켜줍니다. `handleAddItem`함수는 `items.add`를 호출하도록 구현하겠습니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  import Item from './Item.svelte'\n  import { items } from '../stores'\n\n  export let board = null\n  $: _items = $items.filter(item => item.boardId === board.id)\n\n  // handleAddItem 함수 구현\n  const handleAddItem = () => items.add(board.id)\n</script>\n\n<!-- ...생략... -->\n\n<!-- button의 onclick 이벤트에 handleAddItem함수를 연결합니다. -->\n<button class=\"add-item\" on:click={handleAddItem}>+</button>\n```\n\n이제 버튼을 클릭해 보겠습니다.\n\n![add item](/svelte/svelte-store-and-crud/img/svelte_addItem_1.png)\n\n`Item`을 추가하는 부분에 `title`을 지정해주지 않아서 제대로 나오지 않습니다.\n\n`stores/index.js`로 가서 해당 부분을 고쳐주겠습니다.\n\n```js\n// stores/index.js\nconst add = boardId => {\n  if (!boardId) return\n  _update(items =>\n    items.concat({ id: uuid(), boardId, title: '새 항목', done: false }),\n  )\n}\n```\n\n변경 후 다시 버튼을 클릭해보면 **\"새 항목\"** 이라는 제목으로 잘 추가됩니다.\n\n#### 2.2 Item 삭제 기능 구현하기\n\n먼저 `Item.svelte`컴포넌트에 삭제 버튼을 만들겠습니다.\n\n```html\n<!-- Item.svelte -->\n<div\n  class=\"item card p-1 mb-2 shadow-sm\"\n  class:shadow={hovering}\n  on:mouseenter={() => hovering = true}\n  on:mouseleave={() => hovering = false}\n>\n  <span>\n    {item.title}\n  </span>\n  <div class=\"item-action\">\n    <button class=\"item-btn\">-</button>\n  </div>\n</div>\n\n<style>\n  .item {\n    transition: box-shadow .25s ease-in;\n    flex-direction: row;\n    justify-content: space-between\n  }\n\n  .item-btn {\n    width: 25px;\n    height: 25px;\n    padding: 0;\n  }\n</style>\n```\n\n아직 버튼은 아무 동작이 없습니다. 이제 `handleRemoveItem`함수를 만들고 이벤트로 전달해주겠습니다.\n\n```html\n<!-- Item.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte'\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n\n  const handleRemoveItem = () => dispatch('remove', item)\n</script>\n\n<!-- ...생략... -->\n<button class=\"item-btn\" on:click={handleRemoveItem}>-</button>\n```\n\n`\"remove\"`로 전달한 이벤트를 리스너를 `Board.svelte`에 연결해주겠습니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  import Item from './Item.svelte'\n  import { items } from '../stores'\n\n  export let board = null\n  $: _items = $items.filter(item => item.boardId === board.id)\n\n  const handleAddItem = () => items.add(board.id)\n  // e 객체의 detail에 dispatch 함수의 두번째 인자가 담겨 전달됩니다.\n  const handleRemoveItem = e => items.remove(e.detail)\n</script>\n\n<!-- ...생략... -->\n{#each _items as item (item.id)}\n<!-- 하위 컴포넌트에서 remove로 넘겨준 이벤트를 on:remove 으로 받아줍니다. -->\n<Item {item} on:remove={handleRemoveItem} />\n{/each}\n```\n\n잘 동작하네요.\n\n![remove item](/svelte/svelte-store-and-crud/img/svelte_remove_item_1.gif)\n\n#### 2.3 Item 편집 기능 구현하기\n\n`Item`의 편집은 제목을 수정하고, 완료 체크를 할 수 있도록 구현해보겠습니다.\n\n수정 버튼을 만들어서, 버튼을 클릭하면 제목이 `input`으로 변하는 동작을 구현하고, 제목을 수정하도록 만들어 보겠습니다.\n\n삭제 버튼 옆에 수정 버튼을 만들어 줍니다. 그리고 수정버튼을 클릭하면 변하는 상태 변수 `isEditable`과 핸들러 `handleToggleEditable`을 만들어 줍니다. 수정 버튼에는 핸들러를 연결해 줄 것입니다.\n\n그리고 `isEditable`의 상태에 따라 `Item`의 제목이 `input`이 되도록 구현해 줍니다.\n\n`Item.svelte` 파일을 다음과 같이 수정합니다.\n\n```html\n<!-- Item.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte'\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n  let isEditable = false\n\n  const handleRemoveItem = () => dispatch('remove', item)\n  const handleToggleEditable = () => (isEditable = !isEditable)\n</script>\n\n{#if item}\n<div\n  class=\"item card p-1 mb-2 shadow-sm\"\n  class:shadow={hovering}\n  on:mouseenter={() => hovering = true}\n  on:mouseleave={() => hovering = false}\n>\n  {#if isEditable}\n  <input bind:value={item.title} />\n  {:else}\n  <span>\n    {item.title}\n  </span>\n  {/if}\n  <div class=\"item-action\">\n    <button class=\"item-btn\" on:click={handleToggleEditable}>E</button>\n    <button class=\"item-btn\" on:click={handleRemoveItem}>-</button>\n  </div>\n</div>\n{/if}\n```\n\n제목을 수정할 수 있도록 UI는 구성했으니, 수정된 제목이 `Store`에 반영되도록 해줍니다.\n\n`isEditable`이 `true`에서 `false`로 변할 때, 즉 수정을 완료하고 `submit`할 때 값을 저장하도록 구현해 주겠습니다.\n\n`handleUpdateItem` 함수를 만들어주고, `handleToggleEditable` 함수에서 `isEditable`이 변할 때, 실행되도록 구현해 보겠습니다.\n\n```html\n<!-- Item.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte'\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n  let isEditable = false\n\n  const handleRemoveItem = () => dispatch('remove', item)\n  const handleUpdateItem = () => dispatch('update', item)\n  const handleToggleEditable = () => {\n    isEditable = !isEditable\n    if (!isEditable) handleUpdateItem()\n  }\n</script>\n```\n\n`handleUpdateItem` 함수에서는 상위 컴포넌트로 이벤트를 발생시키게 하였습니다. `Board.svelte` 파일로 가서 해당 이벤트를 연결시켜 줍니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  const handleUpdateItem = e => items.update(e.detail)\n</script>\n\n{#each _items as item (item.id)}\n<Item {item} on:update={handleUpdateItem} on:remove={handleRemoveItem} />\n{/each}\n```\n\n`Board.svelte` 컴포넌트에서 `on:update`로 해당 이벤트의 콜백을 연결해주고, `store`에 구현해둔 `update`를 호출합니다.\n\n![remove item](/svelte/svelte-store-and-crud/img/svelte_update_item.gif)\n\n실제로 좋은 UX를 제공하려면, `Enter`키를 입력하거나 `input`에서 `blur`처리가 될 때, 상태를 변경시켜줘야 하겠지만, 그 작업은 생략하도록 하겠습니다.\n\n이제 `Item`의 완료처리를 구현해보겠습니다. 완료처리는 간단하게 제목을 클릭하면 제목에 실선이 그어지고, 색이 변하도록 만들겠습니다.\n\n`Item.svelte`파일에서 다음과 같이 수정합니다.\n\n```html\n<!-- Item.svelte -->\n<script>\n  const handleToggleDone = () => {\n    item.done = !item.done\n    handleUpdateItem()\n  }\n</script>\n\n<span class:item-done={item.done} on:click={handleToggleDone}>\n  {item.title}\n</span>\n\n<style>\n  .item-done {\n    text-decoration: line-through;\n    color: gray;\n  }\n</style>\n```\n\n`item`의 제목이 표시되는 엘리먼트를 클릭했을 때, `item.done`의 값이 변경되도록 해주고, `store`에 반영시켜줍니다. `item.done`의 값에 따라 `item-done`클래스를 가지도록 해주고, css로 실선과 색이 변하도록 해줍니다.\n\n---\n\n이렇게 **Item**의 간단한 CRUD를 구현해 보았습니다. **svelte**로 기본적인 동작들을 만들면서 알아야 할 것들을 자연스럽게 사용해 볼 수 있었습니다.\n\n다음 시간에는 각 `Item`들의 순서를 변경하고, 다른 `Board`로 이동시키는 동작을 구현해보겠습니다.\n\n*전체 프로젝트 코드는 [Github](https://github.com/hoontae24/hello-svelte)에서 보실 수 있습니다.*\n","html":"<p><img src=\"/svelte/svelte-store-and-crud/img/svelte_2.png\" alt=\"svelte\"></p>\n<p>지난 시간에 이어서 <code>boards</code>와 <code>items</code> 데이터를 <code>Store</code>를 만들어서 관리하고, <code>CRUD</code>를 구현하겠습니다.</p>\n<h3 id=\"1-store-구현하기\">1. Store 구현하기</h3>\n<p><code>Svelte</code>는 이미 <code>Store</code> 기능을 내장하고 있습니다. <code>svelte/store</code>를 <code>import</code>하면 그 기능을 사용할 수 있습니다.</p>\n<p>먼저 <code>Store</code>를 구현할 파일을 만들도록 하겠습니다. <code>/src</code>폴더 아래에 <code>stores</code>폴더를 만들고, <code>index.js</code>파일을 생성합니다.</p>\n<p>만약 <code>Store</code>로 사용할 데이터가 많다면 <code>/stores</code>폴더 안에 여러 파일을 만들어 구현하면 관리가 편하겠지만, 현재 프로젝트에서는 <code>boards</code>와 <code>items</code> 두 개의 데이터만 관리하면 되니, <code>index.js</code>파일 안에 함께 구현하도록 하겠습니다.</p>\n<p><code>Store</code>에 대한 기본 지식은 <a href=\"https://svelte.dev/docs#svelte_store\">svelte/store 공식 API 문서</a>를 참조해주세요.</p>\n<h4 id=\"11-boards-데이터-store로-구현하기\">1.1 boards 데이터 Store로 구현하기</h4>\n<p>이제 <code>/src/stores/index.js</code>파일을 다음과 같이 작성합니다.</p>\n<pre><code class=\"language-js\">// src/stores/index.js\nimport { writable } from &#39;svelte/store&#39;\nimport uuid from &#39;uuid/v4&#39;\n\nconst _boards = [\n  { id: 1, title: &#39;Planning&#39; },\n  { id: 2, title: &#39;In Progress&#39; },\n  { id: 3, title: &#39;All Done&#39; },\n]\n\nconst createBoards = () =&gt; {\n  const boards = writable(_boards)\n  const { subscribe, reset, update: _update } = boards\n\n  const add = () =&gt; {\n    _update(boards =&gt; boards.concat({ id: uuid(), title: &#39;&#39; }))\n  }\n\n  const remove = board =&gt; {\n    if (!board) return\n    _update(boards =&gt; boards.filter(_board =&gt; _board.id !== board.id))\n  }\n\n  const update = board =&gt; {\n    if (!board) return\n    _update(boards =&gt;\n      boards.map(_board =&gt; (_board.id === board.id ? board : _board)),\n    )\n  }\n\n  return { subscribe, reset, add, remove, update }\n}\n\nexport const boards = createBoards()\n</code></pre>\n<p><code>Store 모듈</code>에서 불러온 <code>writable</code>함수의 파라미터로 초기화 할 <code>boards</code>데이터를 넣어줍니다.</p>\n<p>생성된 <code>Store</code>객체 <code>boards</code>에서 <code>update</code>메소드를 이용해 <code>add</code>, <code>remove</code>, <code>update</code> 함수를 구현합니다. (<code>update</code>라는 이름의 함수를 따로 구현하기 위해서 원래의 <code>update</code>메소드를 <code>_update</code>로 명명하였음.)</p>\n<p><code>createBoards</code>함수가 리턴하는 객체의 <code>add</code>, <code>remove</code>, <code>update</code>함수는 데이터를 다루는 데에 사용하기 위해 구현하였고, <code>subscribe</code>, <code>reset</code>함수는 컴포넌트 내에서 <code>$boards</code>로 접근하기 위해서 함께 넘겨줍니다.</p>\n<p><code>add</code>함수에서 <code>board</code>를 생성하려고 할 때 id가 필요한데, 중복되지 않는 값이 필요하므로 <code>uuid</code>를 사용하도록 하겠습니다. 상단에서 <code>uuid</code>를 import 하고, 콘솔로 가서 모듈을 설치하겠습니다.</p>\n<blockquote>\n<p>$ npm install uuid</p>\n</blockquote>\n<p><code>package.json</code>파일을 열어보면, 다음과 같이 모듈이 의존성에 추가된 것을 볼 수 있습니다.</p>\n<pre><code class=\"language-json\">// package.json\n&quot;dependencies&quot;: {\n    &quot;sirv-cli&quot;: &quot;^0.4.4&quot;,\n    &quot;uuid&quot;: &quot;^3.3.3&quot;\n  },\n</code></pre>\n<p>다음은 <code>App.svelte</code>파일로 가서 만들어둔 <code>boards</code>를 불러오겠습니다.</p>\n<p><code>./stores</code>에서 <code>boards</code>를 import하고, 기존에 사용하던 boards배열 데이터는 삭제하겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- App.svelte --&gt;\n&lt;script&gt;\n  import { boards } from &#39;./stores&#39;\n\n  // 기존의 데이터는 삭제\n  // const boards = [\n  //   { id: 1, title: &#39;Planning&#39; },\n  //   { id: 2, title: &#39;In Progress&#39; },\n  //   { id: 3, title: &#39;All Done&#39; },\n  // ]\n\n  // (... 생략 ...)\n&lt;/script&gt;\n\n&lt;!-- 기존의 boards를 $boards로 바꿔줍니다. --&gt;\n&lt;!-- {#each boards as board (board.id)} --&gt;\n{#each $boards as board (board.id)}\n&lt;div class=&quot;item&quot;&gt;\n  &lt;Board board={board} items={items.filter(item =&gt; item.boardId === board.id)}\n  /&gt;\n&lt;/div&gt;\n{/each}\n\n&lt;!-- (... 생략 ...) --&gt;\n</code></pre>\n<p>앞서 말했던 것 처럼, <code>boards</code>자체는 <code>Store</code>객체이기 때문에, 해당하는 데이터에 접근하려면 <code>$</code>를 앞에 붙여야 합니다.</p>\n<p>이제 페이지로 접속해서 여전히 잘 동작하는지 확인해보세요. <code>Store</code>가 잘 생성되었는지 확인하기 위해서 <code>boards</code>의 기본 데이터를 변경해보고, 반영되는지 확인하면 됩니다.</p>\n<h4 id=\"12-items-데이터-store로-구현하기\">1.2 items 데이터 Store로 구현하기</h4>\n<p>다음은 <code>items</code>데이터를 <code>Store</code>로 구현하겠습니다. <code>boards</code>에서 했던 것과 거의 동일합니다.</p>\n<p><code>stores/index.js</code>파일로 가서 아래의 내용을 추가하겠습니다.</p>\n<pre><code class=\"language-js\">// stores/index.js\nconst _items = [\n  { id: 1, boardId: 1, title: &#39;자료 조사하기&#39;, done: false },\n  { id: 2, boardId: 1, title: &#39;교양책 읽기&#39;, done: false },\n  { id: 3, boardId: 2, title: &#39;분리수거하기&#39;, done: false },\n  { id: 4, boardId: 2, title: &#39;가계부 정리하기&#39;, done: false },\n  { id: 5, boardId: 3, title: &#39;버그 수정하기&#39;, done: false },\n]\n\nconst createItems = () =&gt; {\n  const items = writable(_items)\n  const { subscribe, reset, update: _update } = items\n\n  const add = boardId =&gt; {\n    if (!boardId) return\n    _update(items =&gt;\n      items.concat({ id: uuid(), boardId, title: &#39;&#39;, done: false }),\n    )\n  }\n\n  const remove = item =&gt; {\n    if (!item) return\n    _update(items =&gt; items.filter(_item =&gt; _item.id !== item.id))\n  }\n\n  const update = item =&gt; {\n    if (!item) return\n    _update(items =&gt; items.map(_item =&gt; (_item.id === item.id ? item : _item)))\n  }\n\n  return { subscribe, reset, add, remove, update }\n}\n\nexport const items = createItems()\n</code></pre>\n<p><code>boards</code>와 다른 부분은 <code>add</code>함수에서 <code>item</code>을 생성할 때, 어느 <code>board</code>에 소속해야할 지 알기 위해 <code>boardId</code>를 파라미터로 받는 부분입니다. 나머지는 동일합니다.</p>\n<p>이제 <code>App.svelte</code>파일로 가서 <code>items</code>를 삭제합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- App.svelte --&gt;\n&lt;script&gt;\n  // 기존 데이터 삭제\n  // const items = [\n  //   { id: 1, boardId: 1, title: &#39;자료 조사하기&#39;, done: false},\n  //   { id: 2, boardId: 1, title: &#39;교양책 읽기&#39;, done: false},\n  //   { id: 3, boardId: 2, title: &#39;분리수거하기&#39;, done: false},\n  //   { id: 4, boardId: 2, title: &#39;가계부 정리하기&#39;, done: false},\n  //   { id: 5, boardId: 3, title: &#39;버그 수정하기&#39;, done: false},\n  // ]\n&lt;/script&gt;\n\n&lt;!-- Board에 주입해주었던 items를 삭제합니다 --&gt;\n&lt;Board board={board} /&gt;\n</code></pre>\n<p><code>Board.svelte</code>로 가서 <code>Store</code>의 <code>items</code>를 <code>import</code>하고, <code>$items</code>로 접근하여 해당 <code>board</code>에 연결된 <code>items</code>를 불러오게 <code>filter</code>를 걸어줍니다. (원래 <code>Board.svelte</code>에 있던 부분을 옮겼습니다.)</p>\n<p><code>$</code>를 이용해 <code>_items</code>에 반응성 변수를 만들고 해당 <code>board</code>의 <code>items</code>를 접근합니다.</p>\n<p>기존에 <code>items</code>로 접근했던 부분을 <code>_items</code>로 변경해주세요.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  import { items } from &#39;../stores&#39;\n\n  // 기존에 props로 주입되었던 items는 삭제합니다.\n  // export items = []\n  $: _items = $items.filter(item =&gt; item.boardId === board.id)\n&lt;/script&gt;\n&lt;!-- &quot;items&quot; -&gt; &quot;_items&quot; --&gt;\n{#each _items as item (item.id)}\n&lt;Item {item} /&gt;\n{/each}\n</code></pre>\n<p>페이지로 가서 잘 동작하는지 확인해보세요.</p>\n<p><strong>Todo-app</strong>에서 사용할 <code>boards</code>와 <code>items</code>데이터를 <code>Store</code>로 구현해 보았습니다. 페이지는 변한 것 없이 그대로지만, 데이터를 관리하는 부분은 수월해졌습니다. 만약 <code>Store</code>를 이용하지 않으려면, 자식 컴포넌트로 <a href=\"https://svelte.dev/docs#createEventDispatcher\">이벤트</a>를 전달해서 데이터를 변경하거나, <a href=\"https://svelte.dev/docs#bind_component_property\">bind된 속성</a>을 이용하면 됩니다.</p>\n<hr>\n<h3 id=\"2-item-crud-구현하기\">2. Item CRUD 구현하기</h3>\n<blockquote>\n<p><strong>CRUD</strong>는 <em>대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다.</em> (참조. 위키백과)</p>\n</blockquote>\n<p><strong>Item</strong>의 동작은 <strong>추가(C)</strong>, <strong>읽기(R)</strong>, <strong>변경(U)</strong>, <strong>삭제(D)</strong> 정도가 있습니다. <strong>읽기</strong>는 따로 구현할 것 없이 지금처럼 보이기만 하면 됩니다.</p>\n<p><strong>추가</strong>와 <strong>삭제</strong>는 버튼을 통해 단순하게 동작하도록 먼저 만들고, <strong>변경</strong>은 <strong>Item</strong>의 제목을 변경하고, <strong>done</strong>속성을 이용하여 완료 체크를 할 수 있도록 만들어 보겠습니다.</p>\n<h4 id=\"21-item-추가-기능-구현하기\">2.1 Item 추가 기능 구현하기</h4>\n<p><code>Item</code>을 추가하는 방법은 여러가지로 구현할 수 있겠지만, 각 <code>Board</code>에 있는 <code>추가</code>버튼을 클릭하면 해당 <code>Board</code>에 새로운 <code>Item</code>이 추가되도록 구현해 보겠습니다.</p>\n<p>먼저, <code>Board</code>의 우측 하단에 버튼을 하나 만들겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;!-- card-body안쪽의 마지막 부분에 버튼을 추가합니다. --&gt;\n&lt;div class=&quot;card-action&quot;&gt;\n  &lt;button class=&quot;add-item&quot;&gt;+&lt;/button&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n  /* 간단한 스타일을 지정합니다. */\n  .add-item {\n    float: right;\n    width: 35px;\n    height: 35px;\n    padding: 0;\n  }\n&lt;/style&gt;\n</code></pre>\n<p>버튼을 클릭하면 새로운 <code>Item</code>이 추가되도록 하겠습니다. <code>Board.svelte</code> 파일에 <code>handleAddItem</code>함수를 만들고 방금 생성한 버튼에 연결시켜줍니다. <code>handleAddItem</code>함수는 <code>items.add</code>를 호출하도록 구현하겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  import Item from &#39;./Item.svelte&#39;\n  import { items } from &#39;../stores&#39;\n\n  export let board = null\n  $: _items = $items.filter(item =&gt; item.boardId === board.id)\n\n  // handleAddItem 함수 구현\n  const handleAddItem = () =&gt; items.add(board.id)\n&lt;/script&gt;\n\n&lt;!-- ...생략... --&gt;\n\n&lt;!-- button의 onclick 이벤트에 handleAddItem함수를 연결합니다. --&gt;\n&lt;button class=&quot;add-item&quot; on:click={handleAddItem}&gt;+&lt;/button&gt;\n</code></pre>\n<p>이제 버튼을 클릭해 보겠습니다.</p>\n<p><img src=\"/svelte/svelte-store-and-crud/img/svelte_addItem_1.png\" alt=\"add item\"></p>\n<p><code>Item</code>을 추가하는 부분에 <code>title</code>을 지정해주지 않아서 제대로 나오지 않습니다.</p>\n<p><code>stores/index.js</code>로 가서 해당 부분을 고쳐주겠습니다.</p>\n<pre><code class=\"language-js\">// stores/index.js\nconst add = boardId =&gt; {\n  if (!boardId) return\n  _update(items =&gt;\n    items.concat({ id: uuid(), boardId, title: &#39;새 항목&#39;, done: false }),\n  )\n}\n</code></pre>\n<p>변경 후 다시 버튼을 클릭해보면 <strong>&quot;새 항목&quot;</strong> 이라는 제목으로 잘 추가됩니다.</p>\n<h4 id=\"22-item-삭제-기능-구현하기\">2.2 Item 삭제 기능 구현하기</h4>\n<p>먼저 <code>Item.svelte</code>컴포넌트에 삭제 버튼을 만들겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;div\n  class=&quot;item card p-1 mb-2 shadow-sm&quot;\n  class:shadow={hovering}\n  on:mouseenter={() =&gt; hovering = true}\n  on:mouseleave={() =&gt; hovering = false}\n&gt;\n  &lt;span&gt;\n    {item.title}\n  &lt;/span&gt;\n  &lt;div class=&quot;item-action&quot;&gt;\n    &lt;button class=&quot;item-btn&quot;&gt;-&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n  .item {\n    transition: box-shadow .25s ease-in;\n    flex-direction: row;\n    justify-content: space-between\n  }\n\n  .item-btn {\n    width: 25px;\n    height: 25px;\n    padding: 0;\n  }\n&lt;/style&gt;\n</code></pre>\n<p>아직 버튼은 아무 동작이 없습니다. 이제 <code>handleRemoveItem</code>함수를 만들고 이벤트로 전달해주겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;script&gt;\n  import { createEventDispatcher } from &#39;svelte&#39;\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n\n  const handleRemoveItem = () =&gt; dispatch(&#39;remove&#39;, item)\n&lt;/script&gt;\n\n&lt;!-- ...생략... --&gt;\n&lt;button class=&quot;item-btn&quot; on:click={handleRemoveItem}&gt;-&lt;/button&gt;\n</code></pre>\n<p><code>&quot;remove&quot;</code>로 전달한 이벤트를 리스너를 <code>Board.svelte</code>에 연결해주겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  import Item from &#39;./Item.svelte&#39;\n  import { items } from &#39;../stores&#39;\n\n  export let board = null\n  $: _items = $items.filter(item =&gt; item.boardId === board.id)\n\n  const handleAddItem = () =&gt; items.add(board.id)\n  // e 객체의 detail에 dispatch 함수의 두번째 인자가 담겨 전달됩니다.\n  const handleRemoveItem = e =&gt; items.remove(e.detail)\n&lt;/script&gt;\n\n&lt;!-- ...생략... --&gt;\n{#each _items as item (item.id)}\n&lt;!-- 하위 컴포넌트에서 remove로 넘겨준 이벤트를 on:remove 으로 받아줍니다. --&gt;\n&lt;Item {item} on:remove={handleRemoveItem} /&gt;\n{/each}\n</code></pre>\n<p>잘 동작하네요.</p>\n<p><img src=\"/svelte/svelte-store-and-crud/img/svelte_remove_item_1.gif\" alt=\"remove item\"></p>\n<h4 id=\"23-item-편집-기능-구현하기\">2.3 Item 편집 기능 구현하기</h4>\n<p><code>Item</code>의 편집은 제목을 수정하고, 완료 체크를 할 수 있도록 구현해보겠습니다.</p>\n<p>수정 버튼을 만들어서, 버튼을 클릭하면 제목이 <code>input</code>으로 변하는 동작을 구현하고, 제목을 수정하도록 만들어 보겠습니다.</p>\n<p>삭제 버튼 옆에 수정 버튼을 만들어 줍니다. 그리고 수정버튼을 클릭하면 변하는 상태 변수 <code>isEditable</code>과 핸들러 <code>handleToggleEditable</code>을 만들어 줍니다. 수정 버튼에는 핸들러를 연결해 줄 것입니다.</p>\n<p>그리고 <code>isEditable</code>의 상태에 따라 <code>Item</code>의 제목이 <code>input</code>이 되도록 구현해 줍니다.</p>\n<p><code>Item.svelte</code> 파일을 다음과 같이 수정합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;script&gt;\n  import { createEventDispatcher } from &#39;svelte&#39;\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n  let isEditable = false\n\n  const handleRemoveItem = () =&gt; dispatch(&#39;remove&#39;, item)\n  const handleToggleEditable = () =&gt; (isEditable = !isEditable)\n&lt;/script&gt;\n\n{#if item}\n&lt;div\n  class=&quot;item card p-1 mb-2 shadow-sm&quot;\n  class:shadow={hovering}\n  on:mouseenter={() =&gt; hovering = true}\n  on:mouseleave={() =&gt; hovering = false}\n&gt;\n  {#if isEditable}\n  &lt;input bind:value={item.title} /&gt;\n  {:else}\n  &lt;span&gt;\n    {item.title}\n  &lt;/span&gt;\n  {/if}\n  &lt;div class=&quot;item-action&quot;&gt;\n    &lt;button class=&quot;item-btn&quot; on:click={handleToggleEditable}&gt;E&lt;/button&gt;\n    &lt;button class=&quot;item-btn&quot; on:click={handleRemoveItem}&gt;-&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n{/if}\n</code></pre>\n<p>제목을 수정할 수 있도록 UI는 구성했으니, 수정된 제목이 <code>Store</code>에 반영되도록 해줍니다.</p>\n<p><code>isEditable</code>이 <code>true</code>에서 <code>false</code>로 변할 때, 즉 수정을 완료하고 <code>submit</code>할 때 값을 저장하도록 구현해 주겠습니다.</p>\n<p><code>handleUpdateItem</code> 함수를 만들어주고, <code>handleToggleEditable</code> 함수에서 <code>isEditable</code>이 변할 때, 실행되도록 구현해 보겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;script&gt;\n  import { createEventDispatcher } from &#39;svelte&#39;\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n  let isEditable = false\n\n  const handleRemoveItem = () =&gt; dispatch(&#39;remove&#39;, item)\n  const handleUpdateItem = () =&gt; dispatch(&#39;update&#39;, item)\n  const handleToggleEditable = () =&gt; {\n    isEditable = !isEditable\n    if (!isEditable) handleUpdateItem()\n  }\n&lt;/script&gt;\n</code></pre>\n<p><code>handleUpdateItem</code> 함수에서는 상위 컴포넌트로 이벤트를 발생시키게 하였습니다. <code>Board.svelte</code> 파일로 가서 해당 이벤트를 연결시켜 줍니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  const handleUpdateItem = e =&gt; items.update(e.detail)\n&lt;/script&gt;\n\n{#each _items as item (item.id)}\n&lt;Item {item} on:update={handleUpdateItem} on:remove={handleRemoveItem} /&gt;\n{/each}\n</code></pre>\n<p><code>Board.svelte</code> 컴포넌트에서 <code>on:update</code>로 해당 이벤트의 콜백을 연결해주고, <code>store</code>에 구현해둔 <code>update</code>를 호출합니다.</p>\n<p><img src=\"/svelte/svelte-store-and-crud/img/svelte_update_item.gif\" alt=\"remove item\"></p>\n<p>실제로 좋은 UX를 제공하려면, <code>Enter</code>키를 입력하거나 <code>input</code>에서 <code>blur</code>처리가 될 때, 상태를 변경시켜줘야 하겠지만, 그 작업은 생략하도록 하겠습니다.</p>\n<p>이제 <code>Item</code>의 완료처리를 구현해보겠습니다. 완료처리는 간단하게 제목을 클릭하면 제목에 실선이 그어지고, 색이 변하도록 만들겠습니다.</p>\n<p><code>Item.svelte</code>파일에서 다음과 같이 수정합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;script&gt;\n  const handleToggleDone = () =&gt; {\n    item.done = !item.done\n    handleUpdateItem()\n  }\n&lt;/script&gt;\n\n&lt;span class:item-done={item.done} on:click={handleToggleDone}&gt;\n  {item.title}\n&lt;/span&gt;\n\n&lt;style&gt;\n  .item-done {\n    text-decoration: line-through;\n    color: gray;\n  }\n&lt;/style&gt;\n</code></pre>\n<p><code>item</code>의 제목이 표시되는 엘리먼트를 클릭했을 때, <code>item.done</code>의 값이 변경되도록 해주고, <code>store</code>에 반영시켜줍니다. <code>item.done</code>의 값에 따라 <code>item-done</code>클래스를 가지도록 해주고, css로 실선과 색이 변하도록 해줍니다.</p>\n<hr>\n<p>이렇게 <strong>Item</strong>의 간단한 CRUD를 구현해 보았습니다. <strong>svelte</strong>로 기본적인 동작들을 만들면서 알아야 할 것들을 자연스럽게 사용해 볼 수 있었습니다.</p>\n<p>다음 시간에는 각 <code>Item</code>들의 순서를 변경하고, 다른 <code>Board</code>로 이동시키는 동작을 구현해보겠습니다.</p>\n<p><em>전체 프로젝트 코드는 <a href=\"https://github.com/hoontae24/hello-svelte\">Github</a>에서 보실 수 있습니다.</em></p>\n","excerpt":" 지난 시간에 이어서 boards와 items 데이터를 Store를 만들어서 관리하고, CRUD를 구현하겠습니다. 1. Store 구현하기 Svelte는 이미 Store 기능을 내장하고 있습니다. svelte/store를 import하면 그 기능을 사용할 수 있습니다. 먼저 Store를 구현할 파일을 만들도록 하겠습니다. /src폴더 아래에 stores폴더를","thumbnail":"/svelte/svelte-store-and-crud/img/svelte_2.png","thumbnailUrl":"https://hoontae24.github.io/svelte/svelte-store-and-crud/img/svelte_2.png"},"url":"https://hoontae24.github.io/4"}}