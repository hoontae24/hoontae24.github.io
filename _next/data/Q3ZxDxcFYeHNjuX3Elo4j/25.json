{"env":{"BASE_PATH":"","ARTICLES_ROOT":".articles","ARTICLE_FILENAME":"README.md"},"__N_SSG":true,"pageProps":{"post":{"href":"25","round":25,"paths":["cicd","build-docker-image-using-github-actions"],"slug":"build-docker-image-using-github-actions","title":"Github Actions를 이용하여 docker image 빌드하기","description":"Github Actions를 이용하여 어플리케이션을 Docker 이미지로 빌드하고 ghcr.io 저장소에 푸시하는 과정을 알아봅니다.","date":"2022-05-02","category":"cicd","tags":["ci/cd","github"],"seriesId":null,"markdown":"\n![github actions icon](/cicd/build-docker-image-using-github-actions/img/github-actions-icon.png)\n\n소프트웨어 제품이나 서비스의 운영에 있어 배포는 적지 않게 중요합니다. 특히 운영 규모가 커지거나 많은 사람이 협업하는 경우에는 더욱 강조될 것입니다. 그렇기에 배포 프로세스를 자동화하면 생산성을 높이고, 휴먼 에러를 줄일 수 있습니다.\n\n요즘은 서비스 운영 환경이 컨테이너 기반으로 이루어진 경우도 많이 있습니다. 만약 kubernetes를 사용한다면 필수적입니다. 오늘은 그러한 운영 환경을 위한 배포 프로세스의 일부분이 될 수 있는 이미지 빌드에 대한 작업을 알아보겠습니다. 또한 많은 개발자들이 사용하는 Github에서 제공하는 기능인 Github Actions를 이용하여 이미지 빌드를 자동화해보겠습니다.\n\n> 오늘 다룰 내용에서는 배포를 위한 이미지 빌드 이후에 운영 환경에 배포하는 작업은 포함하지 않습니다.\n\n모든 소스코드는 [이 저장소](https://github.com/hoontae24/node-http-server)에서 보실 수 있습니다.\n\n## 1. 어플리케이션 준비\n\n먼저 배포할 어플리케이션을 준비합니다. Node.js 기반의 간단한 HTTP 서버를 작성합니다. npm 패키지를 포함하기 위해 `lodash`도 추가했습니다.\n\n```js\nconst http = require(\"http\");\nconst lodash = require(\"lodash\");\n\nhttp\n  .createServer((request, response) => {\n    const url = lodash.get(request, \"url\");\n    console.log(\"incoming request\", url);\n    response.end(`Hello World on ${url}`);\n  })\n  .listen(8080, () => console.log(\"Server is listening on port 8080\"));\n```\n\n빌드된 이미지로 컨테이너를 생성할 때, 명령어를 통해 서버를 실행할 수 있도록 `package.json`에 다음 내용을 추가했습니다.\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"node index.js\"\n  }\n}\n```\n\n## 2. Dockerfile 작성\n\n작성된 서버를 docker 이미지로 빌드하려면 Dockerfile을 작성하여 이미지 빌드에 대한 스펙 및 동작을 작성해주어야 합니다. Node.js 이미지를 빌드하기 위한 Dockerfile에 대한 예시는 [여기](https://nodejs.org/ko/docs/guides/nodejs-docker-webapp/)서 참고할 수 있습니다.\n\n```Dockerfile\nFROM node:16\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 8080\n\nCMD [ \"npm\", \"start\" ]\n```\n\n작성된 `Dockerfile`이 제대로 빌드되는지 로컬에서 먼저 테스트 해봅니다. 제대로 빌드가 되었다면 이미지 목록에서 확인할 수 있습니다.\n\n```sh\ndocker build -t node-http-server:latest .\n\ndocker images\n```\n\n빌드된 이미지를 컨테이너로 실행해봅니다.\n\n```sh\ndocker run -itd -p 8080:8080 --name node-http-server node-http-server:latest\n```\n\n위 명령어로 빌드된 어플리케이션 이미지가 `8080`포트로 개방된 컨테이너로 실행됩니다.\n\n```sh\ncurl localhost:8080\n\ncurl localhost:8080/hello-world\n```\n\n`Dockerfile`로 작성된 어플리케이션 이미지는 잘 동작되는 것을 확인했으니, 이제 Github Actions를 사용하여 이미지가 자동으로 빌드되는 방법을 알아보겠습니다.\n\n## 3. Github Token(PAT) 생성 및 등록\n\ndocker 이미지를 빌드한 후 저장할 이미지 저장소가 필요합니다. `dockerhub`, `aws ecr`, `ghcr` 등이 있습니다. 이번 글에서는 Github Container Registry인 `ghcr`에 빌드된 이미지를 저장하겠습니다.\n\n`ghcr`에 접근하기 위해서는 Github 계정의 `Personal Access Token`이 필요합니다. Github Actions 또는 다른 자동화 스크립트에서 Github에 접근할 수 있도록 인증을 위한 토큰입니다.\n\nGithub에서 `Settings` > `Developer Settings` > `Personal Access Token` 메뉴로 진입하여, `Generate new token`을 선택합니다.\n\n![generate new token](/cicd/build-docker-image-using-github-actions/img/generate-new-token.png)\n\n적당한 토큰에 대한 내용을 입력하고 `write:packages`, `read:packages`, `delete:packages` 권한을 선택한 후 토큰을 생성합니다. 생성된 토큰은 복사하여 따로 저장해둡니다.\n\n이제 Github Actions가 실행될 저장소에 토큰을 등록하겠습니다. `Repository's settings` > `Secrets` > `Actions` 메뉴로 진입하여 `New repository secret`을 선택합니다.\n\n![add repository secret](/cicd/build-docker-image-using-github-actions/img/add-repository-secret.png)\n\n## 4. Github workflows 작성\n\n이제 Github Actions를 사용하여 이미지를 빌드하기 위해 저장소에 workflow를 작성합니다. `.github/workflows/build-image.yml` 파일을 생성하고 다음을 작성합니다. 빌드와 이미지 태깅에 대한 부분 모두 marketplace에서 불러와 사용합니다.\n\n```yml\nname: build-image\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  build-and-push-image:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Log in to the Container registry\n        uses: docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.BUILD_IMAGE_FOR_GHCR }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@98669ae865ea3cffbcbaa878cf57c20bbf1c6c38\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n          tags: |\n            type=sha\n          flavor: |\n            latest=true\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n```\n\n각 부분을 간단하게만 짚어 보겠습니다.\n\n```yml\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n```\n\nworkflow 내에서 사용할 환경변수를 선언합니다. 빌드된 이미지의 이름을 현재 저장소 이름으로 지정합니다.\n\n```yml\npermissions:\n  contents: read\n  packages: write\n```\n\n저장소의 컨텐츠에 대한 권한과 패키지에 대한 권한을 지정합니다.([자세히](https://docs.github.com/en/actions/using-jobs/assigning-permissions-to-jobs))\n\n```yml\n- name: Log in to the Container registry\n  uses: docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9\n  with:\n    registry: ${{ env.REGISTRY }}\n    username: ${{ github.actor }}\n    password: ${{ secrets.BUILD_IMAGE_FOR_GHCR }}\n```\n\nGithub Container Registry에 접근할 수 있도록 인증 절차를 진행합니다. 저장소에 등록해둔 PAT를 불러와 로그인합니다.\n\n```yml\n- name: Build and push Docker image\n  uses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\n  with:\n    context: .\n    push: true\n    tags: ${{ steps.meta.outputs.tags }}\n    labels: ${{ steps.meta.outputs.labels }}\n```\n\n이미지를 빌드하고 로그인된 저장소에 푸시합니다. 이 때, 이미지 태그를 지정해줄 수 있습니다. 여기서는 앞선 step에서 저장소 이름을 사용하도록 지정했습니다.\n\n이제 작성된 workflow 파일을 저장하고 커밋한 뒤 `git push` 명령으로 코드를 푸시합니다. workflow가 푸시되면 Github Actions가 동작합니다. Github 저장소에서 `Actions` 탭을 확인해보겠습니다.\n\n![github actions](/cicd/build-docker-image-using-github-actions/img/github-actions.png)\n\n정상적으로 workflow가 성공한다면 해당 저장소의 `packages`에서 빌드된 이미지를 확인할 수 있습니다.\n\n![github new package](/cicd/build-docker-image-using-github-actions/img/github-repository-home-for-new-package.png)\n\n![github packages](/cicd/build-docker-image-using-github-actions/img/github-packages.png)\n\n## 5. 빌드된 이미지 Pull 받아 컨테이너로 실행하기\n\n`ghcr`에 올라간 이미지를 수동으로 내려 받아 컨테이너로 실행하여 제대로 빌드된 것인지 확인해보겠습니다. ghcr에 접근하기 위해 앞 단계에서 생성했던 PAT가 필요합니다.\n\n로컬에서 docker 이미지 저장소를 `ghcr.io`로 로그인합니다. `$PAT`에는 PAT를 입력하고, `$USERNAME`에는 github username을 입력합니다.\n\n```sh\necho \"$PAT\" | docker login ghcr.io -u $USERNAME --password-stdin\n```\n\n![login to ghcr](/cicd/build-docker-image-using-github-actions/img/login-to-ghcr.png)\n\n이제 빌드된 이미지를 Pull하여 내려 받습니다.\n\n```sh\ndocker pull ghcr.io/hoontae24/node-http-server\n```\n\n![docker pull image](/cicd/build-docker-image-using-github-actions/img/docker-pull.png)\n\n이제 앞 단계와 같이 컨테이너를 실행해봅니다.\n\n```sh\ndocker run -itd -p 8080:8080 --name node-http-server ghcr.io/hoontae24/node-http-server:latest\n```\n\n![docker run container](/cicd/build-docker-image-using-github-actions/img/docker-run-conatiner.png)\n\n`ghcr`로부터 내려받은 이미지가 컨테이너로 잘 동작하는 것을 확인할 수 있습니다.\n\n## 마치며\n\n오늘은 Github Actions를 이용하여 Docker 이미지를 빌드하고 Github Container Registry에 올리는 작업을 진행해봤습니다. 배포 프로세스를 자동화하는 과정 중 일부를 Github Actions를 이용하면 어렵지 않게 진행할 수 있을 것으로 보입니다.\n\n이번에는 편의를 위해 `ghcr.io`에 작업을 하였는데, 자주 사용하는 `dockerhub`나 `aws ecr`에도 적용해보면 좋을 것 같습니다. 또한 이미지 빌드뿐만 아니라 운영 서비스를 업데이트 하는 배포 과정에도 Github Actions를 사용해보면 좋을 것 같습니다.\n\n> 도움을 받은 자료\n>\n> - https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry\n","html":"<p><img src=\"/cicd/build-docker-image-using-github-actions/img/github-actions-icon.png\" alt=\"github actions icon\"></p>\n<p>소프트웨어 제품이나 서비스의 운영에 있어 배포는 적지 않게 중요합니다. 특히 운영 규모가 커지거나 많은 사람이 협업하는 경우에는 더욱 강조될 것입니다. 그렇기에 배포 프로세스를 자동화하면 생산성을 높이고, 휴먼 에러를 줄일 수 있습니다.</p>\n<p>요즘은 서비스 운영 환경이 컨테이너 기반으로 이루어진 경우도 많이 있습니다. 만약 kubernetes를 사용한다면 필수적입니다. 오늘은 그러한 운영 환경을 위한 배포 프로세스의 일부분이 될 수 있는 이미지 빌드에 대한 작업을 알아보겠습니다. 또한 많은 개발자들이 사용하는 Github에서 제공하는 기능인 Github Actions를 이용하여 이미지 빌드를 자동화해보겠습니다.</p>\n<blockquote>\n<p>오늘 다룰 내용에서는 배포를 위한 이미지 빌드 이후에 운영 환경에 배포하는 작업은 포함하지 않습니다.</p>\n</blockquote>\n<p>모든 소스코드는 <a href=\"https://github.com/hoontae24/node-http-server\">이 저장소</a>에서 보실 수 있습니다.</p>\n<h2 id=\"1-어플리케이션-준비\">1. 어플리케이션 준비</h2>\n<p>먼저 배포할 어플리케이션을 준비합니다. Node.js 기반의 간단한 HTTP 서버를 작성합니다. npm 패키지를 포함하기 위해 <code>lodash</code>도 추가했습니다.</p>\n<pre><code class=\"language-js\">const http = require(&quot;http&quot;);\nconst lodash = require(&quot;lodash&quot;);\n\nhttp\n  .createServer((request, response) =&gt; {\n    const url = lodash.get(request, &quot;url&quot;);\n    console.log(&quot;incoming request&quot;, url);\n    response.end(`Hello World on ${url}`);\n  })\n  .listen(8080, () =&gt; console.log(&quot;Server is listening on port 8080&quot;));\n</code></pre>\n<p>빌드된 이미지로 컨테이너를 생성할 때, 명령어를 통해 서버를 실행할 수 있도록 <code>package.json</code>에 다음 내용을 추가했습니다.</p>\n<pre><code class=\"language-json\">{\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;node index.js&quot;\n  }\n}\n</code></pre>\n<h2 id=\"2-dockerfile-작성\">2. Dockerfile 작성</h2>\n<p>작성된 서버를 docker 이미지로 빌드하려면 Dockerfile을 작성하여 이미지 빌드에 대한 스펙 및 동작을 작성해주어야 합니다. Node.js 이미지를 빌드하기 위한 Dockerfile에 대한 예시는 <a href=\"https://nodejs.org/ko/docs/guides/nodejs-docker-webapp/\">여기</a>서 참고할 수 있습니다.</p>\n<pre><code class=\"language-Dockerfile\">FROM node:16\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 8080\n\nCMD [ &quot;npm&quot;, &quot;start&quot; ]\n</code></pre>\n<p>작성된 <code>Dockerfile</code>이 제대로 빌드되는지 로컬에서 먼저 테스트 해봅니다. 제대로 빌드가 되었다면 이미지 목록에서 확인할 수 있습니다.</p>\n<pre><code class=\"language-sh\">docker build -t node-http-server:latest .\n\ndocker images\n</code></pre>\n<p>빌드된 이미지를 컨테이너로 실행해봅니다.</p>\n<pre><code class=\"language-sh\">docker run -itd -p 8080:8080 --name node-http-server node-http-server:latest\n</code></pre>\n<p>위 명령어로 빌드된 어플리케이션 이미지가 <code>8080</code>포트로 개방된 컨테이너로 실행됩니다.</p>\n<pre><code class=\"language-sh\">curl localhost:8080\n\ncurl localhost:8080/hello-world\n</code></pre>\n<p><code>Dockerfile</code>로 작성된 어플리케이션 이미지는 잘 동작되는 것을 확인했으니, 이제 Github Actions를 사용하여 이미지가 자동으로 빌드되는 방법을 알아보겠습니다.</p>\n<h2 id=\"3-github-tokenpat-생성-및-등록\">3. Github Token(PAT) 생성 및 등록</h2>\n<p>docker 이미지를 빌드한 후 저장할 이미지 저장소가 필요합니다. <code>dockerhub</code>, <code>aws ecr</code>, <code>ghcr</code> 등이 있습니다. 이번 글에서는 Github Container Registry인 <code>ghcr</code>에 빌드된 이미지를 저장하겠습니다.</p>\n<p><code>ghcr</code>에 접근하기 위해서는 Github 계정의 <code>Personal Access Token</code>이 필요합니다. Github Actions 또는 다른 자동화 스크립트에서 Github에 접근할 수 있도록 인증을 위한 토큰입니다.</p>\n<p>Github에서 <code>Settings</code> &gt; <code>Developer Settings</code> &gt; <code>Personal Access Token</code> 메뉴로 진입하여, <code>Generate new token</code>을 선택합니다.</p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/generate-new-token.png\" alt=\"generate new token\"></p>\n<p>적당한 토큰에 대한 내용을 입력하고 <code>write:packages</code>, <code>read:packages</code>, <code>delete:packages</code> 권한을 선택한 후 토큰을 생성합니다. 생성된 토큰은 복사하여 따로 저장해둡니다.</p>\n<p>이제 Github Actions가 실행될 저장소에 토큰을 등록하겠습니다. <code>Repository&#39;s settings</code> &gt; <code>Secrets</code> &gt; <code>Actions</code> 메뉴로 진입하여 <code>New repository secret</code>을 선택합니다.</p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/add-repository-secret.png\" alt=\"add repository secret\"></p>\n<h2 id=\"4-github-workflows-작성\">4. Github workflows 작성</h2>\n<p>이제 Github Actions를 사용하여 이미지를 빌드하기 위해 저장소에 workflow를 작성합니다. <code>.github/workflows/build-image.yml</code> 파일을 생성하고 다음을 작성합니다. 빌드와 이미지 태깅에 대한 부분 모두 marketplace에서 불러와 사용합니다.</p>\n<pre><code class=\"language-yml\">name: build-image\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  build-and-push-image:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Log in to the Container registry\n        uses: docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.BUILD_IMAGE_FOR_GHCR }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@98669ae865ea3cffbcbaa878cf57c20bbf1c6c38\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n          tags: |\n            type=sha\n          flavor: |\n            latest=true\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n</code></pre>\n<p>각 부분을 간단하게만 짚어 보겠습니다.</p>\n<pre><code class=\"language-yml\">env:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n</code></pre>\n<p>workflow 내에서 사용할 환경변수를 선언합니다. 빌드된 이미지의 이름을 현재 저장소 이름으로 지정합니다.</p>\n<pre><code class=\"language-yml\">permissions:\n  contents: read\n  packages: write\n</code></pre>\n<p>저장소의 컨텐츠에 대한 권한과 패키지에 대한 권한을 지정합니다.(<a href=\"https://docs.github.com/en/actions/using-jobs/assigning-permissions-to-jobs\">자세히</a>)</p>\n<pre><code class=\"language-yml\">- name: Log in to the Container registry\n  uses: docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9\n  with:\n    registry: ${{ env.REGISTRY }}\n    username: ${{ github.actor }}\n    password: ${{ secrets.BUILD_IMAGE_FOR_GHCR }}\n</code></pre>\n<p>Github Container Registry에 접근할 수 있도록 인증 절차를 진행합니다. 저장소에 등록해둔 PAT를 불러와 로그인합니다.</p>\n<pre><code class=\"language-yml\">- name: Build and push Docker image\n  uses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\n  with:\n    context: .\n    push: true\n    tags: ${{ steps.meta.outputs.tags }}\n    labels: ${{ steps.meta.outputs.labels }}\n</code></pre>\n<p>이미지를 빌드하고 로그인된 저장소에 푸시합니다. 이 때, 이미지 태그를 지정해줄 수 있습니다. 여기서는 앞선 step에서 저장소 이름을 사용하도록 지정했습니다.</p>\n<p>이제 작성된 workflow 파일을 저장하고 커밋한 뒤 <code>git push</code> 명령으로 코드를 푸시합니다. workflow가 푸시되면 Github Actions가 동작합니다. Github 저장소에서 <code>Actions</code> 탭을 확인해보겠습니다.</p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/github-actions.png\" alt=\"github actions\"></p>\n<p>정상적으로 workflow가 성공한다면 해당 저장소의 <code>packages</code>에서 빌드된 이미지를 확인할 수 있습니다.</p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/github-repository-home-for-new-package.png\" alt=\"github new package\"></p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/github-packages.png\" alt=\"github packages\"></p>\n<h2 id=\"5-빌드된-이미지-pull-받아-컨테이너로-실행하기\">5. 빌드된 이미지 Pull 받아 컨테이너로 실행하기</h2>\n<p><code>ghcr</code>에 올라간 이미지를 수동으로 내려 받아 컨테이너로 실행하여 제대로 빌드된 것인지 확인해보겠습니다. ghcr에 접근하기 위해 앞 단계에서 생성했던 PAT가 필요합니다.</p>\n<p>로컬에서 docker 이미지 저장소를 <code>ghcr.io</code>로 로그인합니다. <code>$PAT</code>에는 PAT를 입력하고, <code>$USERNAME</code>에는 github username을 입력합니다.</p>\n<pre><code class=\"language-sh\">echo &quot;$PAT&quot; | docker login ghcr.io -u $USERNAME --password-stdin\n</code></pre>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/login-to-ghcr.png\" alt=\"login to ghcr\"></p>\n<p>이제 빌드된 이미지를 Pull하여 내려 받습니다.</p>\n<pre><code class=\"language-sh\">docker pull ghcr.io/hoontae24/node-http-server\n</code></pre>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/docker-pull.png\" alt=\"docker pull image\"></p>\n<p>이제 앞 단계와 같이 컨테이너를 실행해봅니다.</p>\n<pre><code class=\"language-sh\">docker run -itd -p 8080:8080 --name node-http-server ghcr.io/hoontae24/node-http-server:latest\n</code></pre>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/docker-run-conatiner.png\" alt=\"docker run container\"></p>\n<p><code>ghcr</code>로부터 내려받은 이미지가 컨테이너로 잘 동작하는 것을 확인할 수 있습니다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>오늘은 Github Actions를 이용하여 Docker 이미지를 빌드하고 Github Container Registry에 올리는 작업을 진행해봤습니다. 배포 프로세스를 자동화하는 과정 중 일부를 Github Actions를 이용하면 어렵지 않게 진행할 수 있을 것으로 보입니다.</p>\n<p>이번에는 편의를 위해 <code>ghcr.io</code>에 작업을 하였는데, 자주 사용하는 <code>dockerhub</code>나 <code>aws ecr</code>에도 적용해보면 좋을 것 같습니다. 또한 이미지 빌드뿐만 아니라 운영 서비스를 업데이트 하는 배포 과정에도 Github Actions를 사용해보면 좋을 것 같습니다.</p>\n<blockquote>\n<p>도움을 받은 자료</p>\n<ul>\n<li><a href=\"https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry\">https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry</a></li>\n</ul>\n</blockquote>\n","excerpt":"Github Actions를 이용하여 어플리케이션을 Docker 이미지로 빌드하고 ghcr.io 저장소에 푸시하는 과정을 알아봅니다. 소프트웨어 제품이나 서비스의 운영에 있어 배포는 적지 않게 중요합니다. 특히 운영 규모가 커지거나 많은 사람이 협업하는 경우에는 더욱 강조될 것입니다. 그렇기에 배포 프로세스를 자동화하면 생산성을 높이고, 휴먼 에러를 줄일 수 있습니다. 요즘은 서비스 운영 환경이 컨테이너 기반으로 이루어진 경우도 많이 있습니다. 만약 kubernetes를 사용한다면 필수적","thumbnail":"/cicd/build-docker-image-using-github-actions/img/github-actions-icon.png","thumbnailUrl":"https://hoontae24.github.io/cicd/build-docker-image-using-github-actions/img/github-actions-icon.png"},"url":"https://hoontae24.github.io/25"}}