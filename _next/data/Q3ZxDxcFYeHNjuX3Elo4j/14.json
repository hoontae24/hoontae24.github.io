{"env":{"BASE_PATH":"","ARTICLES_ROOT":".articles","ARTICLE_FILENAME":"README.md"},"__N_SSG":true,"pageProps":{"post":{"href":"14","round":14,"paths":["react","react-ref-props"],"slug":"react-ref-props","title":"React 컴포넌트에 ref props 전달하기 (feat. forwardRef, useImperativeHandle)","description":"","date":"2021-08-18","category":"react","tags":["react","frontend"],"seriesId":null,"markdown":"\n![react ref props](/react/react-ref-props/img/react-ref-props.png)\n\nReact에서 `ref` 속성(props)이 가장 많이 사용하는 용도는 `DOM` 엘리먼트를 참조하는 경우일 것입니다. HTML 엘리먼트에 대해 `ref`를 `props`로 넘겨주어 `DOM` 엘리먼트를 담거나, 콜백 함수를 넘겨주어 `DOM` 엘리먼트를 매개변수로 접근할 수 있습니다. 하지만 `ref`의 기능은 그것뿐만이 아닙니다.\n\n> Refs provide a way to access DOM nodes or React elements created in the render method.\\\n> [공식문서(en)](https://reactjs.org/docs/refs-and-the-dom.html) [공식문서(ko)](https://ko.reactjs.org/docs/refs-and-the-dom.html)\n\n리액트 공식문서에서는 ref를 통해 DOM 노드뿐만 아니라 React 엘리먼트(DOM 노드 포함)에 접근할 수 있다고 말합니다. 이번 포스트에서는 React 엘리먼트를 다루는 `ref` 속성에 대해 알아보겠습니다.\n\n---\n\n## DOM 조작을 위한 ref 전달\n\n```jsx\nimport { useEffect, useRef } from \"react\"\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(inputRef) // { current: <input type=\"text\"> }\n  })\n\n  return (\n    <div>\n      <input ref={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n기본적으로 `jsx`로 DOM 엘리먼트를 작성할 때 `useRef`로 호출된 값을 `ref` 속성으로 넘겨주면 해당 `ref` 객체에 DOM 엘리먼트가 할당됩니다. 만약 `input`을 구현하는 컴포넌트 내부의 DOM 엘리먼트에 접근하려면 어떻게 해야 할까요? 다음 코드처럼 컴포넌트를 작성합니다.\n\n```jsx\nimport { useEffect, useRef } from \"react\"\n\nfunction MyInput(props) {\n  const { ref } = props\n\n  useEffect(() => {\n    console.log(\"ref:\", ref) // ref: undefined\n  })\n\n  return <input ref={ref} />\n}\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(\"inputRef:\", inputRef) // inputRef: { current: undefined }\n  })\n\n  return (\n    <div>\n      <MyInput ref={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n직접 작성한 `MyInput` 컴포넌트에 `ref` 속성으로 ref 객체를 전달했음에도 `MyInput` 컴포넌트 내부에서는 `ref`라는 이름으로 전달된 `props`가 `undefined`로 전달되는 것을 확인할 수 있습니다. 공식문서에서 말하는 것처럼 `ref` 속성은 `DOM 엘리먼트`나 `React 엘리먼트`를 참조하기 위한 속성이기 때문입니다.([Special Props Warning](https://reactjs.org/warnings/special-props.html))\n\n컴포넌트 내부의 엘리먼트를 참조하기 위해서는 어떻게 해야 할까요?\n\n### 1. `ref`가 아닌 `inputRef` 속성으로 전달\n\n`ref`는 컴포넌트 `props` 중에서 일종의 예약어이기 때문에 사용할 수 없습니다. 그래서 다른 이름의 `props`로 전달하면 됩니다.\n\n```jsx\nimport { useEffect, useRef } from \"react\"\n\nfunction MyInput(props) {\n  const { myInputRef } = props\n\n  useEffect(() => {\n    console.log(\"myInputRef:\", myInputRef) // myInputRef: {current: <input type=\"text\">}\n  })\n\n  return <input ref={myInputRef} />\n}\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(\"inputRef:\", inputRef) // inputRef: {current: <input type=\"text\">}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    <div>\n      <MyInput myInputRef={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n컴포넌트에 전달하는 `props`의 이름만 바꾸는 것으로 `ref` 객체를 전달하여 컴포넌트 내부의 엘리먼트에 접근할 수 있습니다. 하지만 이렇게 컴포넌트를 작성하게 되면 `input` 엘리먼트와 거의 비슷한 역할을 `MyInput` 컴포넌트가 수행함에도 약간의 다른 사용법을 제공하는 꼴이 됩니다. 이것은 일관적이지 않게 보일 수 있습니다. (`input` 엘리먼트에 접근하기 위해서 `ref`가 아닌 `inputRef` `props`를 전달해야 함.)\n\n### 2. forwardRef 사용하기\n\nReact에서는 `ref`를 그대로 전달하는 컴포넌트를 작성할 수 있게 도움을 줍니다. 컴포넌트를 `forwardRef`로 감싸주면 됩니다.\n\n```jsx\nimport { forwardRef, useEffect, useRef } from \"react\"\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  useEffect(() => {\n    console.log(\"forwardedRef:\", forwardedRef) // forwardedRef: {current: <input type=\"text\">}\n  })\n\n  return <input ref={forwardedRef} />\n})\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(\"inputRef:\", inputRef) // inputRef: {current: <input type=\"text\">}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    <div>\n      <MyInput ref={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n`forwardRef`함수에 함수형 컴포넌트 형태의 함수를 매개변수로 넣습니다. 이때, 두 번째 인자로 부모에게서 `ref` 속성으로 전달된 ref 객체가 전달됩니다.\n\n만약 `MyInput` 컴포넌트가 클래스 컴포넌트로 작성되었다면, 두 방식을 조합하여 `ref`를 전달할 수 있습니다.\n\n```jsx\nimport { Component, forwardRef, useEffect, useRef } from \"react\"\n\nclass MyInputWithInputRef extends Component {\n  componentDidMount() {\n    console.log(\"myInputRef:\", this.props.myInputRef) // myInputRef: {current: <input type=\"text\">}\n  }\n\n  render() {\n    const { myInputRef } = this.props\n    return <input ref={myInputRef} />\n  }\n}\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  useEffect(() => {\n    console.log(\"forwardedRef:\", forwardedRef) // forwardedRef: {current: <input type=\"text\">}\n  })\n\n  return <MyInputWithInputRef myInputRef={forwardedRef} />\n})\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(\"inputRef:\", inputRef) // inputRef: {current: <input type=\"text\">}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    <div>\n      <MyInput ref={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n코드가 길어졌지만 `MyInput`을 사용하는 부분(`App` 컴포넌트)에서는 `MyInput` 컴포넌트가 어떤식으로 구현되어 있는지 알 필요가 없습니다. `<MyInput>`을 `<input>`으로 교체하더라도 아무 문제가 없을 것입니다. 이것은 **Input**의 역할을 하는 컴포넌트에 대한 일관성과 신뢰성을 부여하게 됩니다.\n\n---\n\n이제 속성(props)으로서의 `ref`에 대해 알아봅시다.\n\n## React 컴포넌트를 조작하기 위한 ref 전달\n\n`ref` 속성은 React Element를 참조하기 위한 접근 방법입니다. 이번에는 컴포넌트 수준의 React Element에 접근하는 `ref`를 다루어 보겠습니다.\n\n### 클래스 컴포넌트에 `ref` 전달하기\n\n```jsx\nimport { Component, createRef, useEffect, useRef } from \"react\"\n\nclass MyInput extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { value: \"\" }\n    this.inputRef = createRef()\n    this.focus = () => {\n      this.inputRef.current.focus()\n    }\n    this.reset = () => {\n      this.setState({ value: \"\" })\n    }\n  }\n\n  render() {\n    return (\n      <input\n        ref={this.inputRef}\n        value={this.state.value}\n        onChange={(e) => this.setState({ value: e.target.value })}\n      />\n    )\n  }\n}\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () => {\n    ref.current.reset() // MyInput 컴포넌트 내부의 state를 조작함\n  }\n\n  const handleFocus = () => {\n    ref.current.focus() // MyInput 컴포넌트 내부의 input 엘리먼트에 포커스 됨\n  }\n\n  useEffect(() => {\n    console.log(\"ref:\", ref) // ref: {current: MyInput}\n    handleFocus()\n  })\n\n  return (\n    <div>\n      <button onClick={handleReset}>reset</button>\n      <button onClick={handleFocus}>focus</button>\n      <br />\n      <MyInput ref={ref} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n클래스로 작성된 컴포넌트에 `ref` 속성을 전달하면 해당 클래스로부터 생성된 React 엘리먼트에 접근할 수 있습니다. 클래스의 속성이나 메서드에도 접근할 수 있고, state나 context에도 접근할 수 있습니다.(심지어 render 메소드까지)\\\n위의 예시 코드와 같이 하위 컴포넌트의 메서드를 통해 부모 컴포넌트가 자식 컴포넌트를 컨트롤할 수 있습니다.(하지만 이런 데이터, 이벤트 흐름을 리액트에서 권장하지는 않습니다.)\n\n### 함수 컴포넌트에 `ref` 전달하기\n\n```jsx\nimport { forwardRef, useEffect, useRef, useState } from \"react\"\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  const ref = useRef()\n  const [value, setValue] = useState(\"\")\n\n  useEffect(() => {\n    // 수동으로 ref 객체에 내부 메서드를 할당\n    forwardedRef.current = {\n      focus: () => {\n        ref.current.focus()\n      },\n      reset: () => {\n        setValue(\"\")\n      },\n    }\n  }, [forwardedRef])\n\n  return (\n    <input ref={ref} value={value} onChange={(e) => setValue(e.target.value)} />\n  )\n})\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () => {\n    if (ref.current) {\n      ref.current.reset()\n    }\n  }\n\n  const handleFocus = () => {\n    if (ref.current) {\n      ref.current.focus()\n    }\n  }\n\n  useEffect(() => {\n    console.log(\"ref:\", ref) // ref: {current: {focus: fn, reset: fn}}\n    handleFocus()\n  })\n\n  return (\n    <div>\n      <button onClick={handleReset}>reset</button>\n      <button onClick={handleFocus}>focus</button>\n      <br />\n      <MyInput ref={ref} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n함수 컴포넌트는 `ref` 속성으로 엘리먼트에 접근할 수 없기 때문에, `forwardRef`를 이용하여 `MyInput` 컴포넌트 내부로 ref 객체를 전달한 후에 수동으로 내부 동작을 할당해 줄 수 있습니다.\n\nReact Hooks 에서는 이와 같은 기능을 제공하는 `useImperativeHandle` 함수가 있습니다.\n\n```jsx\nimport {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\"\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  const ref = useRef()\n  const [value, setValue] = useState(\"\")\n\n  // hooks를 이용하여 ref 객체에 내부 메서드를 할당\n  useImperativeHandle(forwardedRef, () => ({\n    focus: () => ref.current.focus(),\n    reset: () => setValue(\"\"),\n  }))\n\n  return (\n    <input ref={ref} value={value} onChange={(e) => setValue(e.target.value)} />\n  )\n})\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () => {\n    if (ref.current) {\n      ref.current.reset()\n    }\n  }\n\n  const handleFocus = () => {\n    if (ref.current) {\n      ref.current.focus()\n    }\n  }\n\n  useEffect(() => {\n    console.log(\"ref:\", ref) // ref: {current: {focus: fn, reset: fn}}\n    handleFocus()\n  })\n\n  return (\n    <div>\n      <button onClick={handleReset}>reset</button>\n      <button onClick={handleFocus}>focus</button>\n      <br />\n      <MyInput ref={ref} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n앞선 예시 코드에서 수동으로 ref 객체에 할당해주던 작업을 `useImperativeHandle` 함수로 대체하였습니다. `useImperativeHandle` 함수의 코드를 따라가보면 이렇게 구현되어 있습니다.\n\n```jsx\nfunction imperativeHandleEffect<T>(\n  create: () => T,\n  ref: {| current: T | null |} | ((inst: T | null) => mixed) | null | void\n) {\n  if (typeof ref === \"function\") {\n    const refCallback = ref\n    const inst = create()\n    refCallback(inst)\n    return () => {\n      refCallback(null)\n    }\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty(\"current\")) {\n        console.error(\n          \"Expected useImperativeHandle() first argument to either be a \" +\n            \"ref callback or React.createRef() object. Instead received: %s.\",\n          \"an object with keys {\" + Object.keys(refObject).join(\", \") + \"}\"\n        )\n      }\n    }\n    const inst = create()\n    refObject.current = inst\n    return () => {\n      refObject.current = null\n    }\n  }\n}\n```\n\n[Github React 저장소](https://github.com/facebook/react/blob/aa25824f3ebbdbbea01be48417f2f99251be1a12/packages/react-reconciler/src/ReactFiberHooks.old.js#L1512)\n\n실제 구현은 조금 더 복잡하지만, 핵심적인 부분은 앞서 수동으로 할당해주던 것과 꽤 비슷하네요.\n\n## 마무리\n\nDOM 엘리먼트를 참조하기 위해서 주로 `ref`를 이용합니다. 이번 글에서는 `ref` 객체가 아닌 React 엘리먼트의 **`ref` 속성**이 어떤 동작을 하는지 살펴봤습니다. 리액트를 사용하여 컴포넌트 단위로 UI를 구성하고 코드를 재사용하는 등등 프론트엔드 개발에서 편리한 점이 많은데요. 단순히 사용하는 것을 넘어 리액트가 어떻게 동작하는지 이해하면 더 잘 활용할 수 있을 것 같습니다. 이 글이 리액트의 동작을 이해하는데 도움이 되었기를 바랍니다.\n","html":"<p><img src=\"/react/react-ref-props/img/react-ref-props.png\" alt=\"react ref props\"></p>\n<p>React에서 <code>ref</code> 속성(props)이 가장 많이 사용하는 용도는 <code>DOM</code> 엘리먼트를 참조하는 경우일 것입니다. HTML 엘리먼트에 대해 <code>ref</code>를 <code>props</code>로 넘겨주어 <code>DOM</code> 엘리먼트를 담거나, 콜백 함수를 넘겨주어 <code>DOM</code> 엘리먼트를 매개변수로 접근할 수 있습니다. 하지만 <code>ref</code>의 기능은 그것뿐만이 아닙니다.</p>\n<blockquote>\n<p>Refs provide a way to access DOM nodes or React elements created in the render method.<br><a href=\"https://reactjs.org/docs/refs-and-the-dom.html\">공식문서(en)</a> <a href=\"https://ko.reactjs.org/docs/refs-and-the-dom.html\">공식문서(ko)</a></p>\n</blockquote>\n<p>리액트 공식문서에서는 ref를 통해 DOM 노드뿐만 아니라 React 엘리먼트(DOM 노드 포함)에 접근할 수 있다고 말합니다. 이번 포스트에서는 React 엘리먼트를 다루는 <code>ref</code> 속성에 대해 알아보겠습니다.</p>\n<hr>\n<h2 id=\"dom-조작을-위한-ref-전달\">DOM 조작을 위한 ref 전달</h2>\n<pre><code class=\"language-jsx\">import { useEffect, useRef } from &quot;react&quot;\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(inputRef) // { current: &lt;input type=&quot;text&quot;&gt; }\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;input ref={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>기본적으로 <code>jsx</code>로 DOM 엘리먼트를 작성할 때 <code>useRef</code>로 호출된 값을 <code>ref</code> 속성으로 넘겨주면 해당 <code>ref</code> 객체에 DOM 엘리먼트가 할당됩니다. 만약 <code>input</code>을 구현하는 컴포넌트 내부의 DOM 엘리먼트에 접근하려면 어떻게 해야 할까요? 다음 코드처럼 컴포넌트를 작성합니다.</p>\n<pre><code class=\"language-jsx\">import { useEffect, useRef } from &quot;react&quot;\n\nfunction MyInput(props) {\n  const { ref } = props\n\n  useEffect(() =&gt; {\n    console.log(&quot;ref:&quot;, ref) // ref: undefined\n  })\n\n  return &lt;input ref={ref} /&gt;\n}\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(&quot;inputRef:&quot;, inputRef) // inputRef: { current: undefined }\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;MyInput ref={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>직접 작성한 <code>MyInput</code> 컴포넌트에 <code>ref</code> 속성으로 ref 객체를 전달했음에도 <code>MyInput</code> 컴포넌트 내부에서는 <code>ref</code>라는 이름으로 전달된 <code>props</code>가 <code>undefined</code>로 전달되는 것을 확인할 수 있습니다. 공식문서에서 말하는 것처럼 <code>ref</code> 속성은 <code>DOM 엘리먼트</code>나 <code>React 엘리먼트</code>를 참조하기 위한 속성이기 때문입니다.(<a href=\"https://reactjs.org/warnings/special-props.html\">Special Props Warning</a>)</p>\n<p>컴포넌트 내부의 엘리먼트를 참조하기 위해서는 어떻게 해야 할까요?</p>\n<h3 id=\"1-ref가-아닌-inputref-속성으로-전달\">1. <code>ref</code>가 아닌 <code>inputRef</code> 속성으로 전달</h3>\n<p><code>ref</code>는 컴포넌트 <code>props</code> 중에서 일종의 예약어이기 때문에 사용할 수 없습니다. 그래서 다른 이름의 <code>props</code>로 전달하면 됩니다.</p>\n<pre><code class=\"language-jsx\">import { useEffect, useRef } from &quot;react&quot;\n\nfunction MyInput(props) {\n  const { myInputRef } = props\n\n  useEffect(() =&gt; {\n    console.log(&quot;myInputRef:&quot;, myInputRef) // myInputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n  })\n\n  return &lt;input ref={myInputRef} /&gt;\n}\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(&quot;inputRef:&quot;, inputRef) // inputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;MyInput myInputRef={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>컴포넌트에 전달하는 <code>props</code>의 이름만 바꾸는 것으로 <code>ref</code> 객체를 전달하여 컴포넌트 내부의 엘리먼트에 접근할 수 있습니다. 하지만 이렇게 컴포넌트를 작성하게 되면 <code>input</code> 엘리먼트와 거의 비슷한 역할을 <code>MyInput</code> 컴포넌트가 수행함에도 약간의 다른 사용법을 제공하는 꼴이 됩니다. 이것은 일관적이지 않게 보일 수 있습니다. (<code>input</code> 엘리먼트에 접근하기 위해서 <code>ref</code>가 아닌 <code>inputRef</code> <code>props</code>를 전달해야 함.)</p>\n<h3 id=\"2-forwardref-사용하기\">2. forwardRef 사용하기</h3>\n<p>React에서는 <code>ref</code>를 그대로 전달하는 컴포넌트를 작성할 수 있게 도움을 줍니다. 컴포넌트를 <code>forwardRef</code>로 감싸주면 됩니다.</p>\n<pre><code class=\"language-jsx\">import { forwardRef, useEffect, useRef } from &quot;react&quot;\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  useEffect(() =&gt; {\n    console.log(&quot;forwardedRef:&quot;, forwardedRef) // forwardedRef: {current: &lt;input type=&quot;text&quot;&gt;}\n  })\n\n  return &lt;input ref={forwardedRef} /&gt;\n})\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(&quot;inputRef:&quot;, inputRef) // inputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;MyInput ref={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p><code>forwardRef</code>함수에 함수형 컴포넌트 형태의 함수를 매개변수로 넣습니다. 이때, 두 번째 인자로 부모에게서 <code>ref</code> 속성으로 전달된 ref 객체가 전달됩니다.</p>\n<p>만약 <code>MyInput</code> 컴포넌트가 클래스 컴포넌트로 작성되었다면, 두 방식을 조합하여 <code>ref</code>를 전달할 수 있습니다.</p>\n<pre><code class=\"language-jsx\">import { Component, forwardRef, useEffect, useRef } from &quot;react&quot;\n\nclass MyInputWithInputRef extends Component {\n  componentDidMount() {\n    console.log(&quot;myInputRef:&quot;, this.props.myInputRef) // myInputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n  }\n\n  render() {\n    const { myInputRef } = this.props\n    return &lt;input ref={myInputRef} /&gt;\n  }\n}\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  useEffect(() =&gt; {\n    console.log(&quot;forwardedRef:&quot;, forwardedRef) // forwardedRef: {current: &lt;input type=&quot;text&quot;&gt;}\n  })\n\n  return &lt;MyInputWithInputRef myInputRef={forwardedRef} /&gt;\n})\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(&quot;inputRef:&quot;, inputRef) // inputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;MyInput ref={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>코드가 길어졌지만 <code>MyInput</code>을 사용하는 부분(<code>App</code> 컴포넌트)에서는 <code>MyInput</code> 컴포넌트가 어떤식으로 구현되어 있는지 알 필요가 없습니다. <code>&lt;MyInput&gt;</code>을 <code>&lt;input&gt;</code>으로 교체하더라도 아무 문제가 없을 것입니다. 이것은 <strong>Input</strong>의 역할을 하는 컴포넌트에 대한 일관성과 신뢰성을 부여하게 됩니다.</p>\n<hr>\n<p>이제 속성(props)으로서의 <code>ref</code>에 대해 알아봅시다.</p>\n<h2 id=\"react-컴포넌트를-조작하기-위한-ref-전달\">React 컴포넌트를 조작하기 위한 ref 전달</h2>\n<p><code>ref</code> 속성은 React Element를 참조하기 위한 접근 방법입니다. 이번에는 컴포넌트 수준의 React Element에 접근하는 <code>ref</code>를 다루어 보겠습니다.</p>\n<h3 id=\"클래스-컴포넌트에-ref-전달하기\">클래스 컴포넌트에 <code>ref</code> 전달하기</h3>\n<pre><code class=\"language-jsx\">import { Component, createRef, useEffect, useRef } from &quot;react&quot;\n\nclass MyInput extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { value: &quot;&quot; }\n    this.inputRef = createRef()\n    this.focus = () =&gt; {\n      this.inputRef.current.focus()\n    }\n    this.reset = () =&gt; {\n      this.setState({ value: &quot;&quot; })\n    }\n  }\n\n  render() {\n    return (\n      &lt;input\n        ref={this.inputRef}\n        value={this.state.value}\n        onChange={(e) =&gt; this.setState({ value: e.target.value })}\n      /&gt;\n    )\n  }\n}\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () =&gt; {\n    ref.current.reset() // MyInput 컴포넌트 내부의 state를 조작함\n  }\n\n  const handleFocus = () =&gt; {\n    ref.current.focus() // MyInput 컴포넌트 내부의 input 엘리먼트에 포커스 됨\n  }\n\n  useEffect(() =&gt; {\n    console.log(&quot;ref:&quot;, ref) // ref: {current: MyInput}\n    handleFocus()\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={handleReset}&gt;reset&lt;/button&gt;\n      &lt;button onClick={handleFocus}&gt;focus&lt;/button&gt;\n      &lt;br /&gt;\n      &lt;MyInput ref={ref} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>클래스로 작성된 컴포넌트에 <code>ref</code> 속성을 전달하면 해당 클래스로부터 생성된 React 엘리먼트에 접근할 수 있습니다. 클래스의 속성이나 메서드에도 접근할 수 있고, state나 context에도 접근할 수 있습니다.(심지어 render 메소드까지)<br>위의 예시 코드와 같이 하위 컴포넌트의 메서드를 통해 부모 컴포넌트가 자식 컴포넌트를 컨트롤할 수 있습니다.(하지만 이런 데이터, 이벤트 흐름을 리액트에서 권장하지는 않습니다.)</p>\n<h3 id=\"함수-컴포넌트에-ref-전달하기\">함수 컴포넌트에 <code>ref</code> 전달하기</h3>\n<pre><code class=\"language-jsx\">import { forwardRef, useEffect, useRef, useState } from &quot;react&quot;\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  const ref = useRef()\n  const [value, setValue] = useState(&quot;&quot;)\n\n  useEffect(() =&gt; {\n    // 수동으로 ref 객체에 내부 메서드를 할당\n    forwardedRef.current = {\n      focus: () =&gt; {\n        ref.current.focus()\n      },\n      reset: () =&gt; {\n        setValue(&quot;&quot;)\n      },\n    }\n  }, [forwardedRef])\n\n  return (\n    &lt;input ref={ref} value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt;\n  )\n})\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () =&gt; {\n    if (ref.current) {\n      ref.current.reset()\n    }\n  }\n\n  const handleFocus = () =&gt; {\n    if (ref.current) {\n      ref.current.focus()\n    }\n  }\n\n  useEffect(() =&gt; {\n    console.log(&quot;ref:&quot;, ref) // ref: {current: {focus: fn, reset: fn}}\n    handleFocus()\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={handleReset}&gt;reset&lt;/button&gt;\n      &lt;button onClick={handleFocus}&gt;focus&lt;/button&gt;\n      &lt;br /&gt;\n      &lt;MyInput ref={ref} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>함수 컴포넌트는 <code>ref</code> 속성으로 엘리먼트에 접근할 수 없기 때문에, <code>forwardRef</code>를 이용하여 <code>MyInput</code> 컴포넌트 내부로 ref 객체를 전달한 후에 수동으로 내부 동작을 할당해 줄 수 있습니다.</p>\n<p>React Hooks 에서는 이와 같은 기능을 제공하는 <code>useImperativeHandle</code> 함수가 있습니다.</p>\n<pre><code class=\"language-jsx\">import {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from &quot;react&quot;\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  const ref = useRef()\n  const [value, setValue] = useState(&quot;&quot;)\n\n  // hooks를 이용하여 ref 객체에 내부 메서드를 할당\n  useImperativeHandle(forwardedRef, () =&gt; ({\n    focus: () =&gt; ref.current.focus(),\n    reset: () =&gt; setValue(&quot;&quot;),\n  }))\n\n  return (\n    &lt;input ref={ref} value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt;\n  )\n})\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () =&gt; {\n    if (ref.current) {\n      ref.current.reset()\n    }\n  }\n\n  const handleFocus = () =&gt; {\n    if (ref.current) {\n      ref.current.focus()\n    }\n  }\n\n  useEffect(() =&gt; {\n    console.log(&quot;ref:&quot;, ref) // ref: {current: {focus: fn, reset: fn}}\n    handleFocus()\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={handleReset}&gt;reset&lt;/button&gt;\n      &lt;button onClick={handleFocus}&gt;focus&lt;/button&gt;\n      &lt;br /&gt;\n      &lt;MyInput ref={ref} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>앞선 예시 코드에서 수동으로 ref 객체에 할당해주던 작업을 <code>useImperativeHandle</code> 함수로 대체하였습니다. <code>useImperativeHandle</code> 함수의 코드를 따라가보면 이렇게 구현되어 있습니다.</p>\n<pre><code class=\"language-jsx\">function imperativeHandleEffect&lt;T&gt;(\n  create: () =&gt; T,\n  ref: {| current: T | null |} | ((inst: T | null) =&gt; mixed) | null | void\n) {\n  if (typeof ref === &quot;function&quot;) {\n    const refCallback = ref\n    const inst = create()\n    refCallback(inst)\n    return () =&gt; {\n      refCallback(null)\n    }\n  } else if (ref !== null &amp;&amp; ref !== undefined) {\n    const refObject = ref\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty(&quot;current&quot;)) {\n        console.error(\n          &quot;Expected useImperativeHandle() first argument to either be a &quot; +\n            &quot;ref callback or React.createRef() object. Instead received: %s.&quot;,\n          &quot;an object with keys {&quot; + Object.keys(refObject).join(&quot;, &quot;) + &quot;}&quot;\n        )\n      }\n    }\n    const inst = create()\n    refObject.current = inst\n    return () =&gt; {\n      refObject.current = null\n    }\n  }\n}\n</code></pre>\n<p><a href=\"https://github.com/facebook/react/blob/aa25824f3ebbdbbea01be48417f2f99251be1a12/packages/react-reconciler/src/ReactFiberHooks.old.js#L1512\">Github React 저장소</a></p>\n<p>실제 구현은 조금 더 복잡하지만, 핵심적인 부분은 앞서 수동으로 할당해주던 것과 꽤 비슷하네요.</p>\n<h2 id=\"마무리\">마무리</h2>\n<p>DOM 엘리먼트를 참조하기 위해서 주로 <code>ref</code>를 이용합니다. 이번 글에서는 <code>ref</code> 객체가 아닌 React 엘리먼트의 <strong><code>ref</code> 속성</strong>이 어떤 동작을 하는지 살펴봤습니다. 리액트를 사용하여 컴포넌트 단위로 UI를 구성하고 코드를 재사용하는 등등 프론트엔드 개발에서 편리한 점이 많은데요. 단순히 사용하는 것을 넘어 리액트가 어떻게 동작하는지 이해하면 더 잘 활용할 수 있을 것 같습니다. 이 글이 리액트의 동작을 이해하는데 도움이 되었기를 바랍니다.</p>\n","excerpt":" React에서 ref 속성(props)이 가장 많이 사용하는 용도는 DOM 엘리먼트를 참조하는 경우일 것입니다. HTML 엘리먼트에 대해 ref를 props로 넘겨주어 DOM 엘리먼트를 담거나, 콜백 함수를 넘겨주어 DOM 엘리먼트를 매개변수로 접근할 수 있습니다. 하지만 ref의 기능은 그것뿐만이 아닙니다.  Refs provide a way to acc","thumbnail":"/react/react-ref-props/img/react-ref-props.png","thumbnailUrl":"https://hoontae24.github.io/react/react-ref-props/img/react-ref-props.png"},"url":"https://hoontae24.github.io/14"}}