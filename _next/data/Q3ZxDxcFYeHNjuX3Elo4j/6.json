{"env":{"BASE_PATH":"","ARTICLES_ROOT":".articles","ARTICLE_FILENAME":"README.md"},"__N_SSG":true,"pageProps":{"post":{"href":"6","round":6,"paths":["javascript","javascript-promise-concept-and-usage"],"slug":"javascript-promise-concept-and-usage","title":"Javascript의 비동기 처리, Promise를 알아보자","description":"싱글스레드 환경에서 동작하는 자바스크립트의 비동기 처리를 하기 위한 Promise의 개념과 기본적인 사용법을 알아보겠습니다.","date":"2019-12-28","category":"javascript","tags":["javascript","promise"],"seriesId":null,"markdown":"\n![promise](/javascript/javascript-promise-concept-and-usage/img/promise.png)\n\n오늘은 자바스크립트에서 비동기 처리를 다루는 **Promise**에 대해 알아보겠습니다.\n\n## 1. Promise? 왜 필요할까요?\n\n자바스크립트 코드가 동작할 때, 어떠한 작업을 기다리게 된다면 어떻게 될까요? 만약 브라우저에서 실행되는 코드라면 웹 페이지의 동작이 멈추게 될 것입니다. 특히 웹 페이지에서는 1-2초의 먹통에도 사용자는 답답함을 느끼게 됩니다. 개발자는 이러한 상황을 만들지 않고 싶을 것입니다.\n\n자바스크립트는 그러한 상황에서 그 작업을 기다리지 않고 다음 작업을 수행하는 특성을 가지고 있습니다. 그래서 즉시 응답을 보장하지 못하는 경우에는 따로 비동기를 위한 처리를 해주어야 합니다. 대표적인 방법으로 기존에 많이 쓰였던 **Callback**함수를 이용한 패턴이 있습니다.\n\n예시 코드를 통해서 **Callback**함수를 사용하는 방식을 간단히 짚어보겠습니다.\n\n```js\n// getUsers: 사용자 목록을 불러오는 함수\ngetUsers(users => {\n  console.log(users)\n})\n```\n\n`getUsers`라는 함수를 통해 사용자의 데이터를 불러오는 작업을 가정해봅시다. 불러오는 값이 즉시 반환되지 못하고, API서버나 DB 등에서 불러오는 작업을 한다면 비동기 작업으로 이루어집니다. `getUsers` 내부에서는 불러온 `users` 데이터를 `Callback`함수의 인자로 전달해 주어, 해당 데이터를 다룰 수 있게 됩니다.\n\n만약 이러한 작업이 여러 개이면 어떨까요?\n\n```js\n// getUsers: 사용자 목록을 불러오는 함수\n// getPosts: 게시글 목록을 불러오는 함수\n// getComments: 댓글 목록을 불러오는 함수\ngetUsers(users => {\n  getPosts(posts => {\n    getComments(comments => {\n      console.log(users, posts, comments)\n    })\n  })\n})\n```\n\n위와 같이 비동기 작업이 연속적으로 여러 개라면 콜백 안의 콜백으로 이루어져 조금 더 복잡해 보입니다. 또 다른 경우를 봅시다.\n\n```js\n// getUsers: 사용자 목록을 불러오는 함수\n// getPosts: 게시글 목록을 불러오는 함수\n// getComments: 댓글 목록을 불러오는 함수\nconst data = {}\nfunction doSomething() {\n  const { users, posts, comments } = data\n  if (!users || !posts || !comments) return\n  // do something with users, posts, comments...\n}\n\ngetUsers(users => {\n  data.users = users\n  doSomething()\n})\ngetPosts(posts => {\n  data.posts = posts\n  doSomething()\n})\ngetComments(comments => {\n  data.comments = comments\n  doSomething()\n})\n```\n\n이번에는 세가지의 비동기 작업이 병렬적으로 진행됩니다. 하지만 세가지 데이터를 한번에 다룰 작업이 필요하다면 코드가 복잡해지고, 가독성도 떨어지게 됩니다.\n\n## 2. 그럼... Promise 어떻게 사용할까요?\n\n이제 본격적으로 **Promise**에 대해 알아보겠습니다. **Promise**는 콜백 방식에 비해 비동기 작업을 조금 더 유연하게 다룰 수 있습니다.\n\n> Promise 개체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다.\n> [_(출처: MDN)_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\n**Promise**는 비동기 작업을 하나의 객체로 다루는 개념입니다. 단순히 **Callback**보다 깔끔한 코드를 위해서가 아니라 작업 자체를 값으로 생각하는 것입니다.\n\n### 2.1 Promise 객체 생성하기\n\n그럼 **Promise**가 어떻게 사용되어지고, 동작하는지 한번 알아봅시다.\n\n```js\nconst promise = new Promise((resolve, reject) => {\n  // ... do something with async process\n  resolve('완료!')\n})\nconsole.log(promise) // output: Promise {<resolved>: \"완료!\"}\n```\n\n`Promise`는 `new Promise()`를 통해 객체를 생성합니다. 생성자의 인자로 넘겨준 `executor(callback)`함수에서 `resolve`를 호출하여 작업을 처리합니다. 그렇게 출력되어진 결과는 `완료!`라는 값을 가진 `Promise` 객체입니다.\n\n### 2.2 Promise의 상태\n\n- 대기(pending): 이행하거나 거부되지 않은 초기 상태\n- 이행(fulfilled): 연산이 성공적으로 완료됨\n- 거부(rejected): 연산이 실패함\n\n**Promise**는 위와 같은 세가지 중 하나의 상태를 가집니다. 위의 코드에서 `new Promise()`에 전달한 함수에서 첫번째 인자인 `resolve`를 호출하면 **이행(fulfilled)** 상태가 됩니다. 만약 두번째 인자인 `reject`를 호출하면 **거부(rejected)** 상태가 됩니다. 그리고 주석 처리된 부분에서 비동기 작업이 아직 진행 중이면 아직 `resolve`나 `reject`를 호출하지 않았기 때문에 **대기(pending)** 상태가 됩니다.  \n_(**대기** 중이지 않으며 **이행** 또는 **거부** 상태가 된 것을 **처리(settled)** 라고 부르기도 합니다.)_\n\n```js\nconst pending = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('대기!'), 1000)\n})\nconst fulfilled = new Promise((resolve, reject) => {\n  resolve('완료!')\n})\nconst rejected = new Promise((resolve, reject) => {\n  reject('거부!')\n})\n\nconsole.log(pending) // output: Promise {<pending>}\nconsole.log(fulfilled) // output: Promise {<resolved>: \"완료!\"}\nconsole.log(rejected) // output: Promise {<rejected>: \"거부!\"}\nsetTimeout(() => console.log(pending), 1000) // output: Promise {<resolved>: \"대기!\"}\n```\n\n`Promise` 객체를 콘솔에 출력해보면 각각의 상태와 값을 볼 수 있습니다. `pending`의 경우에는 처음에는 `대기`상태였지만, 1초 후에 출력하면 `이행`상태가 되어 있는 것을 확인할 수 있습니다.\n\n이렇게 `Promise` 객체를 통해 비동기 작업을 코드의 순서와 관계없이 객체에 담아서 다룰 수 있습니다. 하지만 `Promise` 객체 자체를 데이터로 사용할 순 없으니, `이행` 또는 `거부`된 `Promise` 객체에서 값을 꺼내 다루는 법을 알아보겠습니다.\n\n### 2.3 Promise 사용하기\n\n`Promise`객체는 다음과 같은 메소드를 가집니다. 메소드를 호출하여 `Promise`객체에 담긴 값을 다룰 수 있습니다.\n\n- then: Promise에 이행 또는 거부에 대한 처리기(callback)를 추가합니다.\n- catch: Promise에 거부에 대한 처리기(callback)를 추가합니다.\n- finally: Promise가 처리(settled)되면 무조건 실행되는 처리기(callback)를 추가합니다.\n\n```js\nconst promise = new Promise((res, rej) => {\n  // 무언가 비동기 작업...\n  const data = { users: ['Jason', 'Conan'] }\n  if (data) {\n    res(data)\n  } else {\n    rej(new Error('data가 없어요'))\n  }\n})\n\npromise\n  .then(value => {\n    console.log(value.users) // output: ['Jason', 'Conan']\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n\n위의 3가지 메소드는 모두 `Promise`객체를 반환합니다. `then`과 `catch`는 콜백함수의 반환값이 담긴 `이행(fulfilled)`된 `Promise`가 반환됩니다. `finally`는 콜백 함수에서 에러가 발생하면 `거부`된 `Promise`가 반환되고, 그렇지 않으면 `finally`가 호출된 `Promise`가 반환됩니다.\n\n`Promise`의 메소드는 값의 변경이 있든 아니든 다시 `Promise`를 반환하기 때문에 메소드 체이닝(Chaining)이 가능합니다. 이미 위의 `then`과 `catch`를 이어서 호출한 것도 그때문에 가능합니다.\n\n```js\nconst promise = new Promise((res, rej) => {\n  // 무언가 비동기 작업...\n  const data = { users: ['Jason', 'Conan'] }\n  if (data) {\n    res(data)\n  } else {\n    rej(new Error('data가 없어요'))\n  }\n})\n\npromise\n  .then(value => {\n    return new Promise(res => {\n      // 무언가...\n      res(value.users)\n    })\n  })\n  .then(users => {\n    return new Promise(res => {\n      // 비동기...\n      res(users.map(user => user.length))\n    })\n  })\n  .then(counts => {\n    // 작업...\n    console.log(counts) // output: [5, 5]\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n\n이렇게 `Promise`의 체이닝을 이용해서 연속적인 비동기 작업을 처리할 수 있습니다. 위의 코드에서는 `new Promise()`를 선언하여 객체를 생성했지만, 비동기 작업에 대한 코드를 미리 `Promise`객체를 반환하는 라이브러리를 사용하거나 함수를 선언해두면 더 보기 좋게 코드를 작성할 수 있습니다.\n\n### 2.4 Promise 메소드 더 알아보기\n\n`Promise`에는 자체 메소드가 몇가지 있습니다.\n\n- Promise.all()\n- Promise.race()\n- Promise.resolve()\n- Promise.reject()\n\n#### 2.4.1 Promise.all\n\n`Promise.all()` 메소드는 여러 개의 `Promise`객체의 처리 여부에 대한 작업을 수행합니다. 또한 인자로 받는 `iterable`의 모든 처리 결과가 `이행(fulfilled)`이면 `Promise.all()`은 `이행`된 `Promise`객체를 반환합니다. 만약 하나의 `Promise` 객체라도 `거부(rejected)`되면 `Promise.all()`은 즉시 `거부`된 `Promise`를 반환합니다.\n\n```js\nconst promise1 = new Promise(res => res(1))\nconst promise2 = new Promise(res => res(2))\nconst promise3 = new Promise((r, j) => r(3))\nconst promise = Promise.all([promise1, promise2, promise3])\npromise.then(value => {\n  console.log(value) // output: [1, 2, 3]\n})\n```\n\n위의 코드에서는 간단히 작성 하였지만, 여러개의 비동기 작업을 처리해야 할 때 잘 활용하면 좋습니다. `이행`된 값을 확인해 보면 `Promise.all()`의 매개변수로 넘겨준 `iterable`의 각각의 `이행`된 값을 가지고 있습니다.\n\n#### 2.4.2 Promise.race()\n\n`Promise.race()` 메소드는 여러 개의 `Promise`객체를 매개변수로 받아 가장 먼저 `처리(settled)`된 `Promise` 객체를 반환합니.\n\n```js\nconst promise1 = new Promise(res => setTimeout(() => res(1), 1000))\nconst promise2 = new Promise(res => setTimeout(() => res(2), 500))\nconst promise3 = new Promise((res, rej) => rej(3))\nconst promise = Promise.race([promise1, promise2, promise3])\npromise\n  .then(value => {\n    console.log(value) // \"이행되지 않음\"\n  })\n  .catch(err => {\n    console.log('error:', err) // output: error: 3\n  })\n```\n\n#### 2.4.3 Promise.resolve() / Promise.reject()\n\n`Promise.resolve()`메소드는 파라미터로 넘겨준 값을 가진 `이행`된 `Promise` 객체를 즉시 반환합니다. 만약 어떤 값을 처리할 때, `Promise`인지 아닌지 확실하지 않은데 `Promise`로 처리하고자 하면 `Promise.resolve(value)`를 이행한 후 반환된 `Promise`에 대해 값을 처리하면 됩니다.\n\n`Promise.reject()`메소드는 파라미터로 넘겨준 이유로 `거부`된 `Promise` 객체를 반환합니다.\n\n## 마무리\n\n이렇게 **Promise**를 다루는 방법을 알아 보았습니다. 어떻게 사용되어지고 어떠한 메소드들이 있는지 알아보았는데, 사실 이번 글을 통해 비동기를 다루는 **Promise**의 특징과 장점에 대해서는 많이 알지 못해서 조금 아쉽습니다. 단순히 사용법을 넘어서 **Promise**를 이용해 비동기를 더 유연하고, 쉽게 다루는 스킬을 익혀야겠습니다.\n","html":"<p><img src=\"/javascript/javascript-promise-concept-and-usage/img/promise.png\" alt=\"promise\"></p>\n<p>오늘은 자바스크립트에서 비동기 처리를 다루는 <strong>Promise</strong>에 대해 알아보겠습니다.</p>\n<h2 id=\"1-promise-왜-필요할까요\">1. Promise? 왜 필요할까요?</h2>\n<p>자바스크립트 코드가 동작할 때, 어떠한 작업을 기다리게 된다면 어떻게 될까요? 만약 브라우저에서 실행되는 코드라면 웹 페이지의 동작이 멈추게 될 것입니다. 특히 웹 페이지에서는 1-2초의 먹통에도 사용자는 답답함을 느끼게 됩니다. 개발자는 이러한 상황을 만들지 않고 싶을 것입니다.</p>\n<p>자바스크립트는 그러한 상황에서 그 작업을 기다리지 않고 다음 작업을 수행하는 특성을 가지고 있습니다. 그래서 즉시 응답을 보장하지 못하는 경우에는 따로 비동기를 위한 처리를 해주어야 합니다. 대표적인 방법으로 기존에 많이 쓰였던 <strong>Callback</strong>함수를 이용한 패턴이 있습니다.</p>\n<p>예시 코드를 통해서 <strong>Callback</strong>함수를 사용하는 방식을 간단히 짚어보겠습니다.</p>\n<pre><code class=\"language-js\">// getUsers: 사용자 목록을 불러오는 함수\ngetUsers(users =&gt; {\n  console.log(users)\n})\n</code></pre>\n<p><code>getUsers</code>라는 함수를 통해 사용자의 데이터를 불러오는 작업을 가정해봅시다. 불러오는 값이 즉시 반환되지 못하고, API서버나 DB 등에서 불러오는 작업을 한다면 비동기 작업으로 이루어집니다. <code>getUsers</code> 내부에서는 불러온 <code>users</code> 데이터를 <code>Callback</code>함수의 인자로 전달해 주어, 해당 데이터를 다룰 수 있게 됩니다.</p>\n<p>만약 이러한 작업이 여러 개이면 어떨까요?</p>\n<pre><code class=\"language-js\">// getUsers: 사용자 목록을 불러오는 함수\n// getPosts: 게시글 목록을 불러오는 함수\n// getComments: 댓글 목록을 불러오는 함수\ngetUsers(users =&gt; {\n  getPosts(posts =&gt; {\n    getComments(comments =&gt; {\n      console.log(users, posts, comments)\n    })\n  })\n})\n</code></pre>\n<p>위와 같이 비동기 작업이 연속적으로 여러 개라면 콜백 안의 콜백으로 이루어져 조금 더 복잡해 보입니다. 또 다른 경우를 봅시다.</p>\n<pre><code class=\"language-js\">// getUsers: 사용자 목록을 불러오는 함수\n// getPosts: 게시글 목록을 불러오는 함수\n// getComments: 댓글 목록을 불러오는 함수\nconst data = {}\nfunction doSomething() {\n  const { users, posts, comments } = data\n  if (!users || !posts || !comments) return\n  // do something with users, posts, comments...\n}\n\ngetUsers(users =&gt; {\n  data.users = users\n  doSomething()\n})\ngetPosts(posts =&gt; {\n  data.posts = posts\n  doSomething()\n})\ngetComments(comments =&gt; {\n  data.comments = comments\n  doSomething()\n})\n</code></pre>\n<p>이번에는 세가지의 비동기 작업이 병렬적으로 진행됩니다. 하지만 세가지 데이터를 한번에 다룰 작업이 필요하다면 코드가 복잡해지고, 가독성도 떨어지게 됩니다.</p>\n<h2 id=\"2-그럼-promise-어떻게-사용할까요\">2. 그럼... Promise 어떻게 사용할까요?</h2>\n<p>이제 본격적으로 <strong>Promise</strong>에 대해 알아보겠습니다. <strong>Promise</strong>는 콜백 방식에 비해 비동기 작업을 조금 더 유연하게 다룰 수 있습니다.</p>\n<blockquote>\n<p>Promise 개체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다.\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><em>(출처: MDN)</em></a></p>\n</blockquote>\n<p><strong>Promise</strong>는 비동기 작업을 하나의 객체로 다루는 개념입니다. 단순히 <strong>Callback</strong>보다 깔끔한 코드를 위해서가 아니라 작업 자체를 값으로 생각하는 것입니다.</p>\n<h3 id=\"21-promise-객체-생성하기\">2.1 Promise 객체 생성하기</h3>\n<p>그럼 <strong>Promise</strong>가 어떻게 사용되어지고, 동작하는지 한번 알아봅시다.</p>\n<pre><code class=\"language-js\">const promise = new Promise((resolve, reject) =&gt; {\n  // ... do something with async process\n  resolve(&#39;완료!&#39;)\n})\nconsole.log(promise) // output: Promise {&lt;resolved&gt;: &quot;완료!&quot;}\n</code></pre>\n<p><code>Promise</code>는 <code>new Promise()</code>를 통해 객체를 생성합니다. 생성자의 인자로 넘겨준 <code>executor(callback)</code>함수에서 <code>resolve</code>를 호출하여 작업을 처리합니다. 그렇게 출력되어진 결과는 <code>완료!</code>라는 값을 가진 <code>Promise</code> 객체입니다.</p>\n<h3 id=\"22-promise의-상태\">2.2 Promise의 상태</h3>\n<ul>\n<li>대기(pending): 이행하거나 거부되지 않은 초기 상태</li>\n<li>이행(fulfilled): 연산이 성공적으로 완료됨</li>\n<li>거부(rejected): 연산이 실패함</li>\n</ul>\n<p><strong>Promise</strong>는 위와 같은 세가지 중 하나의 상태를 가집니다. 위의 코드에서 <code>new Promise()</code>에 전달한 함수에서 첫번째 인자인 <code>resolve</code>를 호출하면 <strong>이행(fulfilled)</strong> 상태가 됩니다. 만약 두번째 인자인 <code>reject</code>를 호출하면 <strong>거부(rejected)</strong> 상태가 됩니다. 그리고 주석 처리된 부분에서 비동기 작업이 아직 진행 중이면 아직 <code>resolve</code>나 <code>reject</code>를 호출하지 않았기 때문에 <strong>대기(pending)</strong> 상태가 됩니다.<br><em>(<strong>대기</strong> 중이지 않으며 <strong>이행</strong> 또는 <strong>거부</strong> 상태가 된 것을 <strong>처리(settled)</strong> 라고 부르기도 합니다.)</em></p>\n<pre><code class=\"language-js\">const pending = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; resolve(&#39;대기!&#39;), 1000)\n})\nconst fulfilled = new Promise((resolve, reject) =&gt; {\n  resolve(&#39;완료!&#39;)\n})\nconst rejected = new Promise((resolve, reject) =&gt; {\n  reject(&#39;거부!&#39;)\n})\n\nconsole.log(pending) // output: Promise {&lt;pending&gt;}\nconsole.log(fulfilled) // output: Promise {&lt;resolved&gt;: &quot;완료!&quot;}\nconsole.log(rejected) // output: Promise {&lt;rejected&gt;: &quot;거부!&quot;}\nsetTimeout(() =&gt; console.log(pending), 1000) // output: Promise {&lt;resolved&gt;: &quot;대기!&quot;}\n</code></pre>\n<p><code>Promise</code> 객체를 콘솔에 출력해보면 각각의 상태와 값을 볼 수 있습니다. <code>pending</code>의 경우에는 처음에는 <code>대기</code>상태였지만, 1초 후에 출력하면 <code>이행</code>상태가 되어 있는 것을 확인할 수 있습니다.</p>\n<p>이렇게 <code>Promise</code> 객체를 통해 비동기 작업을 코드의 순서와 관계없이 객체에 담아서 다룰 수 있습니다. 하지만 <code>Promise</code> 객체 자체를 데이터로 사용할 순 없으니, <code>이행</code> 또는 <code>거부</code>된 <code>Promise</code> 객체에서 값을 꺼내 다루는 법을 알아보겠습니다.</p>\n<h3 id=\"23-promise-사용하기\">2.3 Promise 사용하기</h3>\n<p><code>Promise</code>객체는 다음과 같은 메소드를 가집니다. 메소드를 호출하여 <code>Promise</code>객체에 담긴 값을 다룰 수 있습니다.</p>\n<ul>\n<li>then: Promise에 이행 또는 거부에 대한 처리기(callback)를 추가합니다.</li>\n<li>catch: Promise에 거부에 대한 처리기(callback)를 추가합니다.</li>\n<li>finally: Promise가 처리(settled)되면 무조건 실행되는 처리기(callback)를 추가합니다.</li>\n</ul>\n<pre><code class=\"language-js\">const promise = new Promise((res, rej) =&gt; {\n  // 무언가 비동기 작업...\n  const data = { users: [&#39;Jason&#39;, &#39;Conan&#39;] }\n  if (data) {\n    res(data)\n  } else {\n    rej(new Error(&#39;data가 없어요&#39;))\n  }\n})\n\npromise\n  .then(value =&gt; {\n    console.log(value.users) // output: [&#39;Jason&#39;, &#39;Conan&#39;]\n  })\n  .catch(err =&gt; {\n    console.error(err)\n  })\n</code></pre>\n<p>위의 3가지 메소드는 모두 <code>Promise</code>객체를 반환합니다. <code>then</code>과 <code>catch</code>는 콜백함수의 반환값이 담긴 <code>이행(fulfilled)</code>된 <code>Promise</code>가 반환됩니다. <code>finally</code>는 콜백 함수에서 에러가 발생하면 <code>거부</code>된 <code>Promise</code>가 반환되고, 그렇지 않으면 <code>finally</code>가 호출된 <code>Promise</code>가 반환됩니다.</p>\n<p><code>Promise</code>의 메소드는 값의 변경이 있든 아니든 다시 <code>Promise</code>를 반환하기 때문에 메소드 체이닝(Chaining)이 가능합니다. 이미 위의 <code>then</code>과 <code>catch</code>를 이어서 호출한 것도 그때문에 가능합니다.</p>\n<pre><code class=\"language-js\">const promise = new Promise((res, rej) =&gt; {\n  // 무언가 비동기 작업...\n  const data = { users: [&#39;Jason&#39;, &#39;Conan&#39;] }\n  if (data) {\n    res(data)\n  } else {\n    rej(new Error(&#39;data가 없어요&#39;))\n  }\n})\n\npromise\n  .then(value =&gt; {\n    return new Promise(res =&gt; {\n      // 무언가...\n      res(value.users)\n    })\n  })\n  .then(users =&gt; {\n    return new Promise(res =&gt; {\n      // 비동기...\n      res(users.map(user =&gt; user.length))\n    })\n  })\n  .then(counts =&gt; {\n    // 작업...\n    console.log(counts) // output: [5, 5]\n  })\n  .catch(err =&gt; {\n    console.error(err)\n  })\n</code></pre>\n<p>이렇게 <code>Promise</code>의 체이닝을 이용해서 연속적인 비동기 작업을 처리할 수 있습니다. 위의 코드에서는 <code>new Promise()</code>를 선언하여 객체를 생성했지만, 비동기 작업에 대한 코드를 미리 <code>Promise</code>객체를 반환하는 라이브러리를 사용하거나 함수를 선언해두면 더 보기 좋게 코드를 작성할 수 있습니다.</p>\n<h3 id=\"24-promise-메소드-더-알아보기\">2.4 Promise 메소드 더 알아보기</h3>\n<p><code>Promise</code>에는 자체 메소드가 몇가지 있습니다.</p>\n<ul>\n<li>Promise.all()</li>\n<li>Promise.race()</li>\n<li>Promise.resolve()</li>\n<li>Promise.reject()</li>\n</ul>\n<h4 id=\"241-promiseall\">2.4.1 Promise.all</h4>\n<p><code>Promise.all()</code> 메소드는 여러 개의 <code>Promise</code>객체의 처리 여부에 대한 작업을 수행합니다. 또한 인자로 받는 <code>iterable</code>의 모든 처리 결과가 <code>이행(fulfilled)</code>이면 <code>Promise.all()</code>은 <code>이행</code>된 <code>Promise</code>객체를 반환합니다. 만약 하나의 <code>Promise</code> 객체라도 <code>거부(rejected)</code>되면 <code>Promise.all()</code>은 즉시 <code>거부</code>된 <code>Promise</code>를 반환합니다.</p>\n<pre><code class=\"language-js\">const promise1 = new Promise(res =&gt; res(1))\nconst promise2 = new Promise(res =&gt; res(2))\nconst promise3 = new Promise((r, j) =&gt; r(3))\nconst promise = Promise.all([promise1, promise2, promise3])\npromise.then(value =&gt; {\n  console.log(value) // output: [1, 2, 3]\n})\n</code></pre>\n<p>위의 코드에서는 간단히 작성 하였지만, 여러개의 비동기 작업을 처리해야 할 때 잘 활용하면 좋습니다. <code>이행</code>된 값을 확인해 보면 <code>Promise.all()</code>의 매개변수로 넘겨준 <code>iterable</code>의 각각의 <code>이행</code>된 값을 가지고 있습니다.</p>\n<h4 id=\"242-promiserace\">2.4.2 Promise.race()</h4>\n<p><code>Promise.race()</code> 메소드는 여러 개의 <code>Promise</code>객체를 매개변수로 받아 가장 먼저 <code>처리(settled)</code>된 <code>Promise</code> 객체를 반환합니.</p>\n<pre><code class=\"language-js\">const promise1 = new Promise(res =&gt; setTimeout(() =&gt; res(1), 1000))\nconst promise2 = new Promise(res =&gt; setTimeout(() =&gt; res(2), 500))\nconst promise3 = new Promise((res, rej) =&gt; rej(3))\nconst promise = Promise.race([promise1, promise2, promise3])\npromise\n  .then(value =&gt; {\n    console.log(value) // &quot;이행되지 않음&quot;\n  })\n  .catch(err =&gt; {\n    console.log(&#39;error:&#39;, err) // output: error: 3\n  })\n</code></pre>\n<h4 id=\"243-promiseresolve--promisereject\">2.4.3 Promise.resolve() / Promise.reject()</h4>\n<p><code>Promise.resolve()</code>메소드는 파라미터로 넘겨준 값을 가진 <code>이행</code>된 <code>Promise</code> 객체를 즉시 반환합니다. 만약 어떤 값을 처리할 때, <code>Promise</code>인지 아닌지 확실하지 않은데 <code>Promise</code>로 처리하고자 하면 <code>Promise.resolve(value)</code>를 이행한 후 반환된 <code>Promise</code>에 대해 값을 처리하면 됩니다.</p>\n<p><code>Promise.reject()</code>메소드는 파라미터로 넘겨준 이유로 <code>거부</code>된 <code>Promise</code> 객체를 반환합니다.</p>\n<h2 id=\"마무리\">마무리</h2>\n<p>이렇게 <strong>Promise</strong>를 다루는 방법을 알아 보았습니다. 어떻게 사용되어지고 어떠한 메소드들이 있는지 알아보았는데, 사실 이번 글을 통해 비동기를 다루는 <strong>Promise</strong>의 특징과 장점에 대해서는 많이 알지 못해서 조금 아쉽습니다. 단순히 사용법을 넘어서 <strong>Promise</strong>를 이용해 비동기를 더 유연하고, 쉽게 다루는 스킬을 익혀야겠습니다.</p>\n","excerpt":"싱글스레드 환경에서 동작하는 자바스크립트의 비동기 처리를 하기 위한 Promise의 개념과 기본적인 사용법을 알아보겠습니다. 오늘은 자바스크립트에서 비동기 처리를 다루는 Promise에 대해 알아보겠습니다. 1. Promise? 왜 필요할까요? 자바스크립트 코드가 동작할 때, 어떠한 작업을 기다리게 된다면 어떻게 될까요? 만약 브라우저에서 실행되는 코드라면 웹 페이지의 동작이 멈추게 될 것입니다. 특히 웹 페이지에서는 1-2초의 먹통에도 사용자는 답답함을 느끼게 됩니다. 개발자는","thumbnail":"/javascript/javascript-promise-concept-and-usage/img/promise.png","thumbnailUrl":"https://hoontae24.github.io/javascript/javascript-promise-concept-and-usage/img/promise.png"},"url":"https://hoontae24.github.io/6"}}