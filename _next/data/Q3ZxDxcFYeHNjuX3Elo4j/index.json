{"env":{"BASE_PATH":"","ARTICLES_ROOT":".articles","ARTICLE_FILENAME":"README.md"},"__N_SSG":true,"pageProps":{"posts":[{"href":"27","round":27,"paths":["principle","abstration-and-separation-of-concern-through-axios"],"slug":"abstration-and-separation-of-concern-through-axios","title":"axios로 살펴보는 관심사의 분리와 추상화","description":"소프트웨어 개발에 있어 자주 사용되는 개념인 관심사의 분리와 추상화에 대해서 axios의 코드를 예시로 보며 살펴봅니다.","date":"2022-09-03","category":"principle","tags":["principle","javascript"],"seriesId":null,"markdown":"\n소프트웨어 개발에는 여러 가지 원칙들이 있습니다. 원칙을 적용하면 소프트웨어를 더 유연하고 견고하게 만들 수 있습니다. 개발 관점에서 원칙이라는 것은 지켜야하는 수칙이라기 보다는 더 나은 소프트웨어를 위한 방법이라고 볼 수도 있습니다. 이번 글에서는 [axios](https://github.com/axios/axios)라는 자바스크립트 라이브러리를 살펴보면서 **관심사의 분리**와 **추상화**에 대해 살펴보겠습니다.\n\n## axios\n\n자바스크립트 개발자 중에서 axios를 모르는 분은 없을 겁니다. axios는 자바스크립트로 http 통신을 위해 사용하는 라이브러리입니다. 자바스크립트가 동작하는 대표적인 두 환경인 웹 브라우저와 nodejs를 지원합니다. 브라우저에서 http 요청을 하려면 [XHR](https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest)이나 [Fetch API](https://developer.mozilla.org/ko/docs/Web/API/Fetch_API)를 사용할 수 있습니다. 대부분의 브라우저에서 http 통신을 위해서 제공하는 기능입니다. nodejs 환경에서는 XHR이나 Fetch API를 사용할 수 없습니다. nodejs 런타임에서 http 요청을 하려면 [http](https://nodejs.org/api/http.html#http) nodejs 내장 모듈을 사용해야 합니다.\n\n![http-library-on-runtimes](/principle/abstration-and-separation-of-concern-through-axios/img/http-library-on-runtimes.png)\n\naxios를 사용하면 http 요청 관련 기능을 쉽게 사용할 뿐만 아니라, 브라우저 또는 nodejs와 같은 실행 환경에 구애받지 않고 코드를 작성할 수 있습니다. 각 환경에서 http 요청을 위한 동작은 axios 내부에서 처리해주기 때문입니다. 개발자는 환경이 달라도 같은 로직 코드를 작성할 수 있고, 같은 결과를 기대할 수 있습니다.\n\n## 관심사의 분리\n\n> 컴퓨터 과학에서 관심사 분리(separation of concerns, SoC)는 컴퓨터 프로그램을 구별된 부분으로 분리시키는 디자인 원칙으로, 각 부문은 개개의 관심사를 해결한다. ([위키백과](https://ko.wikipedia.org/wiki/%EA%B4%80%EC%8B%AC%EC%82%AC_%EB%B6%84%EB%A6%AC))\n\n브라우저와 nodejs는 http 통신을 위해서 서로 다른 인터페이스를 제공합니다. 만약 우리의 코드가 두 환경에서 동작해야하는 코드라면 각 환경에 따라 다른 인터페이스를 사용해서 구현해야 합니다. axios는 관심사의 분리를 통해 이 문제를 해결합니다. axios의 코드 중에서 http 요청을 실행하는 부분의 코드를 봅시다.\n\n```js\n// axios/lib/core/Axios.js (https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/core/Axios.js#L21)\nclass Axios {\n  // ...\n  request(configOrUrl, config) {\n    // ...\n    promise = dispatchRequest.call(this, newConfig);\n  }\n}\n```\n\n코드의 일부는 생략하고 `Axios` 객체가 http 요청을 실행하는 `request` 메소드를 살펴봅시다. 요청의 여러 분기 조건들이 있지만 최종적으로 http 요청을 수행하는 것은 `dispatchRequest` 함수를 호출하는 것입니다. Axios 객체가 http 요청을 실행하기 위해서 실행 환경에 대해서는 알 수도 없고, 알 필요도 없습니다. Axios를 통해 로직을 구현하는 개발자 역시 환경에 대한 처리를 할 필요가 없습니다. 개발자는 Axios 인터페이스를 통해 http 관련 로직에만 집중할 수 있습니다.\n\n```js\n// axios/lib/core/dispatchRequest.js (https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/core/dispatchRequest.js#L33)\nexport default function dispatchRequest(config) {\n  // ...\n  const adapter = config.adapter || defaults.adapter;\n\n  return adapter(config)\n    .then\n    // ...\n    ();\n}\n\n// axios/lib/defaults/index.js (https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/defaults/index.js#L22)\nfunction getDefaultAdapter() {\n  let adapter;\n  if (typeof XMLHttpRequest !== \"undefined\") {\n    // For browsers use XHR adapter\n    adapter = adapters.getAdapter(\"xhr\");\n  } else if (typeof process !== \"undefined\" && utils.kindOf(process) === \"process\") {\n    // For node use HTTP adapter\n    adapter = adapters.getAdapter(\"http\");\n  }\n  return adapter;\n}\n\n// axios/lib/adapters/index.js (https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/adapters/index.js#L2)\nimport httpAdapter from \"./http.js\";\nimport xhrAdapter from \"./xhr.js\";\n\nconst adapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n};\n```\n\n`dispatchRequest` 함수 내부를 살펴보면, `adapter`를 통해 요청을 처리합니다. `adapter`는 axios를 호출하는 개발자가 주입할 수도 있지만 기본값은 내부적으로 구현되어 있습니다. `getDefaultAdapter` 함수에서는 실행 환경에 따라 기본 어댑터를 지정합니다. 브라우저 또는 nodejs에서 동작하는 http 관련 로직을 구현해두고, 환경에 따라 특정 adapter로 연결만 해줍니다.\n\n![adapter-pattern-diagram](/principle/abstration-and-separation-of-concern-through-axios/img/adapter-pattern-diagram.png)\n\n위 다이어그램은 어댑터 패턴을 나타내는 클래스 다이어그램입니다. 어댑터 패턴 다이어그램의 요소들과 완전히 일치하진 않겠지만 비교를 하면 다음과 같습니다.\n\n- Client 클래스 -> Axios 클래스\n- Target 인터페이스 -> getDefaultAdapter 함수의 응답값\n- Adapter 구현 클래스 -> httpAdapter(nodejs), xhrAdapter(브라우저)\n- Adaptee 클래스 -> http 내장 라이브러리(nodejs), XMLHttpRequest(브라우저)\n\nAxios를 사용하는 개발자는 어댑터 패턴을 통해 http 요청에 대한 로직만 다루면 됩니다. 환경에 대한 분기처리나 제한사항은 axios의 각 환경별로 구현된 어댑터가 대신 처리할 것입니다. 관심사의 분리와 동시에 일종의 추상화가 이루어진 것인데요. axios의 다른 부분을 통해 추상화를 조금 더 살펴봅시다.\n\n## 추상화\n\n> 소프트웨어 개발관점에서 추상화란 인터페이스에 의존하고, 구체적인 구현에는 의존하지 않는다. ([https://choi3950.tistory.com/25](https://choi3950.tistory.com/25)) \\\n> 추상화는 뒷편 시스템의 기술적 복잡함을 단순한 API 뒤에 숨깁니다. ([MDN](https://developer.mozilla.org/ko/docs/Glossary/Abstraction))\n\n이미 우리는 관심사의 분리 예제를 통해 추상화를 다루었습니다. 개발자는 Axios를 사용하면서 환경 별로 다루어야할 로직을 처리할 필요가 없습니다. 그저 http 요청에 필요한 axios 인터페이스에만 집중할 수 있습니다. axios가 내부적으로 처리하는 환경에 대한 로직은 감추어져 있습니다. 만약 브라우저에서 XHR 인터페이스가 변경된다면, axios의 xhrAdapter만 수정하면 됩니다. Axios 객체를 다루는 코드를 변경할 필요는 없을 것입니다.\n\n또 여기 axios의 config 옵션들을 통해 추상화를 살펴볼 수 있습니다.\n\n```js\n// https://github.com/axios/axios#axiosconfig\n// Send a POST request\naxios({\n  method: \"post\",\n  url: \"/user/12345\",\n  data: {\n    firstName: \"Fred\",\n    lastName: \"Flintstone\",\n  },\n});\n```\n\n만약 우리가 http post 요청을 데이터와 함께 보낸다면 위 예시 코드와 같이 작성할 것입니다. 여기서 `data`라는 객체가 xhrAdapter, httpAdapter로 전달되고 http 요청으로 실행될 때 어떤 과정을 거치는 지 알 필요가 없습니다. 개발자는 그저 `data`라는 객체에 원하는 정보를 넘겨주기만 하면 됩니다.\n\n만약 `post` 요청이 아닌 `put` 요청을 하려면 `method: 'put'`으로 코드를 변경하면 됩니다. 우리는 `post`, `put` http 메소드가 어떤 과정을 통해 통신으로 전달되는 지 알 필요가 없습니다.\n\n## 마치며\n\naxios를 통해 소프트웨어 개발 원칙 중 하나인 추상화와 관심사의 분리에 대해 살펴봤습니다. 사실 예시로 소개한 코드들이 이 원칙들을 완벽히 설명하지는 않을 것입니다. 하지만 원칙을 이해하는 데 도움이 되고, 실제 개발 과정에서 나도 모르게 고려하고 있는 추상화에 대해 정리하는 시간이었습니다. 기술에 대한 이해와 성장 뿐만 아니라 개발 방법론, 개발 원리에 대한 넓은 시야와 통찰력을 가지고 좋은 소프트웨어를 만드는 개발자로 성장하길 스스로 응원하며 글을 마칩니다.\n","html":"<p>소프트웨어 개발에는 여러 가지 원칙들이 있습니다. 원칙을 적용하면 소프트웨어를 더 유연하고 견고하게 만들 수 있습니다. 개발 관점에서 원칙이라는 것은 지켜야하는 수칙이라기 보다는 더 나은 소프트웨어를 위한 방법이라고 볼 수도 있습니다. 이번 글에서는 <a href=\"https://github.com/axios/axios\">axios</a>라는 자바스크립트 라이브러리를 살펴보면서 <strong>관심사의 분리</strong>와 <strong>추상화</strong>에 대해 살펴보겠습니다.</p>\n<h2 id=\"axios\">axios</h2>\n<p>자바스크립트 개발자 중에서 axios를 모르는 분은 없을 겁니다. axios는 자바스크립트로 http 통신을 위해 사용하는 라이브러리입니다. 자바스크립트가 동작하는 대표적인 두 환경인 웹 브라우저와 nodejs를 지원합니다. 브라우저에서 http 요청을 하려면 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest\">XHR</a>이나 <a href=\"https://developer.mozilla.org/ko/docs/Web/API/Fetch_API\">Fetch API</a>를 사용할 수 있습니다. 대부분의 브라우저에서 http 통신을 위해서 제공하는 기능입니다. nodejs 환경에서는 XHR이나 Fetch API를 사용할 수 없습니다. nodejs 런타임에서 http 요청을 하려면 <a href=\"https://nodejs.org/api/http.html#http\">http</a> nodejs 내장 모듈을 사용해야 합니다.</p>\n<p><img src=\"/principle/abstration-and-separation-of-concern-through-axios/img/http-library-on-runtimes.png\" alt=\"http-library-on-runtimes\"></p>\n<p>axios를 사용하면 http 요청 관련 기능을 쉽게 사용할 뿐만 아니라, 브라우저 또는 nodejs와 같은 실행 환경에 구애받지 않고 코드를 작성할 수 있습니다. 각 환경에서 http 요청을 위한 동작은 axios 내부에서 처리해주기 때문입니다. 개발자는 환경이 달라도 같은 로직 코드를 작성할 수 있고, 같은 결과를 기대할 수 있습니다.</p>\n<h2 id=\"관심사의-분리\">관심사의 분리</h2>\n<blockquote>\n<p>컴퓨터 과학에서 관심사 분리(separation of concerns, SoC)는 컴퓨터 프로그램을 구별된 부분으로 분리시키는 디자인 원칙으로, 각 부문은 개개의 관심사를 해결한다. (<a href=\"https://ko.wikipedia.org/wiki/%EA%B4%80%EC%8B%AC%EC%82%AC_%EB%B6%84%EB%A6%AC\">위키백과</a>)</p>\n</blockquote>\n<p>브라우저와 nodejs는 http 통신을 위해서 서로 다른 인터페이스를 제공합니다. 만약 우리의 코드가 두 환경에서 동작해야하는 코드라면 각 환경에 따라 다른 인터페이스를 사용해서 구현해야 합니다. axios는 관심사의 분리를 통해 이 문제를 해결합니다. axios의 코드 중에서 http 요청을 실행하는 부분의 코드를 봅시다.</p>\n<pre><code class=\"language-js\">// axios/lib/core/Axios.js (https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/core/Axios.js#L21)\nclass Axios {\n  // ...\n  request(configOrUrl, config) {\n    // ...\n    promise = dispatchRequest.call(this, newConfig);\n  }\n}\n</code></pre>\n<p>코드의 일부는 생략하고 <code>Axios</code> 객체가 http 요청을 실행하는 <code>request</code> 메소드를 살펴봅시다. 요청의 여러 분기 조건들이 있지만 최종적으로 http 요청을 수행하는 것은 <code>dispatchRequest</code> 함수를 호출하는 것입니다. Axios 객체가 http 요청을 실행하기 위해서 실행 환경에 대해서는 알 수도 없고, 알 필요도 없습니다. Axios를 통해 로직을 구현하는 개발자 역시 환경에 대한 처리를 할 필요가 없습니다. 개발자는 Axios 인터페이스를 통해 http 관련 로직에만 집중할 수 있습니다.</p>\n<pre><code class=\"language-js\">// axios/lib/core/dispatchRequest.js (https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/core/dispatchRequest.js#L33)\nexport default function dispatchRequest(config) {\n  // ...\n  const adapter = config.adapter || defaults.adapter;\n\n  return adapter(config)\n    .then\n    // ...\n    ();\n}\n\n// axios/lib/defaults/index.js (https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/defaults/index.js#L22)\nfunction getDefaultAdapter() {\n  let adapter;\n  if (typeof XMLHttpRequest !== &quot;undefined&quot;) {\n    // For browsers use XHR adapter\n    adapter = adapters.getAdapter(&quot;xhr&quot;);\n  } else if (typeof process !== &quot;undefined&quot; &amp;&amp; utils.kindOf(process) === &quot;process&quot;) {\n    // For node use HTTP adapter\n    adapter = adapters.getAdapter(&quot;http&quot;);\n  }\n  return adapter;\n}\n\n// axios/lib/adapters/index.js (https://github.com/axios/axios/blob/649d739288c8e2c55829ac60e2345a0f3439c730/lib/adapters/index.js#L2)\nimport httpAdapter from &quot;./http.js&quot;;\nimport xhrAdapter from &quot;./xhr.js&quot;;\n\nconst adapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n};\n</code></pre>\n<p><code>dispatchRequest</code> 함수 내부를 살펴보면, <code>adapter</code>를 통해 요청을 처리합니다. <code>adapter</code>는 axios를 호출하는 개발자가 주입할 수도 있지만 기본값은 내부적으로 구현되어 있습니다. <code>getDefaultAdapter</code> 함수에서는 실행 환경에 따라 기본 어댑터를 지정합니다. 브라우저 또는 nodejs에서 동작하는 http 관련 로직을 구현해두고, 환경에 따라 특정 adapter로 연결만 해줍니다.</p>\n<p><img src=\"/principle/abstration-and-separation-of-concern-through-axios/img/adapter-pattern-diagram.png\" alt=\"adapter-pattern-diagram\"></p>\n<p>위 다이어그램은 어댑터 패턴을 나타내는 클래스 다이어그램입니다. 어댑터 패턴 다이어그램의 요소들과 완전히 일치하진 않겠지만 비교를 하면 다음과 같습니다.</p>\n<ul>\n<li>Client 클래스 -&gt; Axios 클래스</li>\n<li>Target 인터페이스 -&gt; getDefaultAdapter 함수의 응답값</li>\n<li>Adapter 구현 클래스 -&gt; httpAdapter(nodejs), xhrAdapter(브라우저)</li>\n<li>Adaptee 클래스 -&gt; http 내장 라이브러리(nodejs), XMLHttpRequest(브라우저)</li>\n</ul>\n<p>Axios를 사용하는 개발자는 어댑터 패턴을 통해 http 요청에 대한 로직만 다루면 됩니다. 환경에 대한 분기처리나 제한사항은 axios의 각 환경별로 구현된 어댑터가 대신 처리할 것입니다. 관심사의 분리와 동시에 일종의 추상화가 이루어진 것인데요. axios의 다른 부분을 통해 추상화를 조금 더 살펴봅시다.</p>\n<h2 id=\"추상화\">추상화</h2>\n<blockquote>\n<p>소프트웨어 개발관점에서 추상화란 인터페이스에 의존하고, 구체적인 구현에는 의존하지 않는다. (<a href=\"https://choi3950.tistory.com/25\">https://choi3950.tistory.com/25</a>) <br>추상화는 뒷편 시스템의 기술적 복잡함을 단순한 API 뒤에 숨깁니다. (<a href=\"https://developer.mozilla.org/ko/docs/Glossary/Abstraction\">MDN</a>)</p>\n</blockquote>\n<p>이미 우리는 관심사의 분리 예제를 통해 추상화를 다루었습니다. 개발자는 Axios를 사용하면서 환경 별로 다루어야할 로직을 처리할 필요가 없습니다. 그저 http 요청에 필요한 axios 인터페이스에만 집중할 수 있습니다. axios가 내부적으로 처리하는 환경에 대한 로직은 감추어져 있습니다. 만약 브라우저에서 XHR 인터페이스가 변경된다면, axios의 xhrAdapter만 수정하면 됩니다. Axios 객체를 다루는 코드를 변경할 필요는 없을 것입니다.</p>\n<p>또 여기 axios의 config 옵션들을 통해 추상화를 살펴볼 수 있습니다.</p>\n<pre><code class=\"language-js\">// https://github.com/axios/axios#axiosconfig\n// Send a POST request\naxios({\n  method: &quot;post&quot;,\n  url: &quot;/user/12345&quot;,\n  data: {\n    firstName: &quot;Fred&quot;,\n    lastName: &quot;Flintstone&quot;,\n  },\n});\n</code></pre>\n<p>만약 우리가 http post 요청을 데이터와 함께 보낸다면 위 예시 코드와 같이 작성할 것입니다. 여기서 <code>data</code>라는 객체가 xhrAdapter, httpAdapter로 전달되고 http 요청으로 실행될 때 어떤 과정을 거치는 지 알 필요가 없습니다. 개발자는 그저 <code>data</code>라는 객체에 원하는 정보를 넘겨주기만 하면 됩니다.</p>\n<p>만약 <code>post</code> 요청이 아닌 <code>put</code> 요청을 하려면 <code>method: &#39;put&#39;</code>으로 코드를 변경하면 됩니다. 우리는 <code>post</code>, <code>put</code> http 메소드가 어떤 과정을 통해 통신으로 전달되는 지 알 필요가 없습니다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>axios를 통해 소프트웨어 개발 원칙 중 하나인 추상화와 관심사의 분리에 대해 살펴봤습니다. 사실 예시로 소개한 코드들이 이 원칙들을 완벽히 설명하지는 않을 것입니다. 하지만 원칙을 이해하는 데 도움이 되고, 실제 개발 과정에서 나도 모르게 고려하고 있는 추상화에 대해 정리하는 시간이었습니다. 기술에 대한 이해와 성장 뿐만 아니라 개발 방법론, 개발 원리에 대한 넓은 시야와 통찰력을 가지고 좋은 소프트웨어를 만드는 개발자로 성장하길 스스로 응원하며 글을 마칩니다.</p>\n","excerpt":"소프트웨어 개발에 있어 자주 사용되는 개념인 관심사의 분리와 추상화에 대해서 axios의 코드를 예시로 보며 살펴봅니다. 소프트웨어 개발에는 여러 가지 원칙들이 있습니다. 원칙을 적용하면 소프트웨어를 더 유연하고 견고하게 만들 수 있습니다. 개발 관점에서 원칙이라는 것은 지켜야하는 수칙이라기 보다는 더 나은 소프트웨어를 위한 방법이라고 볼 수도 있습니다. 이번 글에서는 axios라는 자바스크립트 라이브러리를 살펴보면서 관심사의 분리와 추상화에 대해 살펴보겠습니다. axios ","thumbnail":"/principle/abstration-and-separation-of-concern-through-axios/img/http-library-on-runtimes.png","thumbnailUrl":"https://hoontae24.github.io/principle/abstration-and-separation-of-concern-through-axios/img/http-library-on-runtimes.png"},{"href":"26","round":26,"paths":["react","nextjs-page-props"],"slug":"nextjs-page-props","title":"Nextjs getServerSideProps에 대해 알아보자","description":"Nextjs 페이지 컴포넌트의 핵심 기능인 getServerSideProps가 props를 변경하고 전달하는 동작에 대해 알아보겠습니다.","date":"2022-06-01","category":"react","tags":["react","nextjs"],"seriesId":null,"markdown":"\n![NextJS](/react/nextjs-page-props/img/nextjs.png)\n\nNextjs는 리액트 생태계에서 가장 많이 사용하는 프레임워크 중 하나입니다. 주로 SSR 기반의 프로젝트에 사용합니다. 또한 파일 시스템 기반의 직관적인 라우팅, 이미지 최적화, 타입스크립트 지원 등 간단한 설정으로 사용할 수 있는 기능이 많아서 프로젝트를 구성하고 관리하는 작업이 줄어듭니다.\n\n여러 기능 중 SSR에서는 DataFetch를 쉽게 구현할 수 있습니다. SSR 페이지에서 초기 데이터를 로드하려면 `getServerSideProps` 함수를 정의하여 페이지 컴포넌트의 `Props`로 주입받을 수 있습니다. `getServerSideProps`를 사용해보고 동작하는 방식을 알아보겠습니다.\n\n> 예시로 작성된 코드 전체는 [여기](https://github.com/hoontae24/blog-examples/tree/main/react/nextjs-getServerSideProps)에서 볼 수 있습니다.\n\n## 사용법\n\n먼저 간단한 페이지 컴포넌트를 만들고, 페이지 컴포넌트 파일에 `getServerSideProps`라는 이름으로 함수를 정의합니다.\n\n```tsx\n// src/pages/index.tsx\ninterface IndexPageProps {\n  name: string;\n}\n\nconst IndexPage: NextPage<IndexPageProps> = (props) => {\n  const { name } = props;\n  return (\n    <div>\n      <h1>Hello {name}!</h1>\n    </div>\n  );\n};\n\nexport const getServerSideProps: GetServerSideProps<IndexPageProps> = async () => {\n  return {\n    props: {\n      name: \"Next\",\n    },\n  };\n};\n\nexport default IndexPage;\n```\n\n페이지 컴포넌트가 렌더링되기 전에 `getServerSideProps` 함수가 실행됩니다. Data Fetch 작업을 `getServerSideProps` 함수 내에서 처리하면, 페이지 컴포넌트의 `props`로 전달받아 렌더링합니다. 코드를 약간 수정해서 좀 더 의미있는 예시를 만들어 봅시다.\n\n```tsx\n// src/pages/index.tsx\n\ninterface Post {\n  id: number;\n  title: string;\n}\n\ninterface IndexPageProps {\n  name: string;\n  posts: Post[];\n}\n\nconst IndexPage: NextPage<IndexPageProps> = (props) => {\n  const { name, posts } = props;\n  return (\n    <div>\n      <h1>Hello {name}!</h1>\n      <ul>\n        {posts.map((post) => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport const getServerSideProps: GetServerSideProps<IndexPageProps> = async () => {\n  const url = \"https://jsonplaceholder.typicode.com/posts\";\n  const posts: Post[] = await fetch(url).then((res) => res.json());\n  return {\n    props: {\n      name: \"Next\",\n      posts: posts,\n    },\n  };\n};\n\nexport default IndexPage;\n```\n\n만약 리액트에서 다른 도구를 사용하지 않는다면 `useState`, `useEffect` 등으로 데이터를 불러와 상태로 다루게 됩니다. 하지만 `getServerSideProps`를 이용하면 데이터를 불러오고 관리하는 부분을 리액트 라이프사이클에서 분리하고, 페이지가 렌더링되기 전에 데이터를 불러와 Placeholder를 렌더링하지 않아도 됩니다.\n\n## 렌더링 과정에서의 동작 알아보기\n\n위 예시 코드에서 `getServerSideProps` 함수를 컴포넌트 내에 정의했지만, 리액트 컴포넌트의 라이프사이클과는 분리되어 있음을 알 수 있습니다. 또한 Nextjs에서 과거 Data Fetching을 위해 사용했던 `getInitialProps`는 컴포넌트의 `static method`로 정의된 것과 다르게 `export`를 사용하고 있습니다.\n\n위 예시 코드에서 함수가 호출되는 것을 디버깅하기 위해 로그를 찍어보겠습니다. 함수 컴포넌트 내부와 `getServerSideProps` 함수 내에서 디버깅 로그를 남깁니다.\n\n```tsx\nconst IndexPage = () => {\n  console.log(\"Logging from IndexPage Component\");\n  return (\n    // ...\n  )\n}\nexport const getServerSideProps = async () => {\n  console.log(\"Logging from getServerSideProps\");\n  return {\n    // ...\n  };\n};\n```\n\n이제 브라우저에서 해당 페이지에 접속한 다음 개발자도구의 콘솔과 Next가 실행 중인 콘솔을 열고 새로고침을 합니다. 브라우저 콘솔과 Next 콘솔에서 로그를 확인합니다.\n\n```sh\n# 브라우저 콘솔\nLogging from IndexPage Component\n```\n\n```sh\n# Next 콘솔\nLogging from getServerSideProps\nLogging from IndexPage Component\n```\n\n간단한 디버깅으로 알 수 있는 것은 Next가 `getServerSideProps` 함수를 먼저 호출하고, 페이지 컴포넌트를 렌더링합니다. 새로고침을 하면 페이지 초기 진입만 반복적으로 이루어지므로, 브라우저 콘솔에서 나타난 로그는 hydration 과정에서 페이지 컴포넌트의 렌더링 시점에 호출된 것으로 보입니다.\n\n이번에는 페이지 컴포넌트 파일의 루트 영역에 변수 하나를 추가합니다. 그리고 각각의 로그에서 변수를 출력하도록 합니다.\n\n```tsx\nlet count = 0;\n\nconst IndexPage = () => {\n  console.log(\"Logging from IndexPage Component\", ++count);\n  return (\n    // ...\n  )\n}\nexport const getServerSideProps = async () => {\n  console.log(\"Logging from getServerSideProps\", ++count);\n  return {\n    // ...\n  };\n};\n```\n\n브라우저에서 새로고침을 반복하고 각각의 로그를 살펴봅니다. 새로고침할 때 브라우저 로그를 유지하기 위해 브라우저 콘솔의 `Preserve log` 옵션을 켜줍니다.\n\n```sh\n# 브라우저 콘솔\nLogging from IndexPage Component 1\nLogging from IndexPage Component 1\nLogging from IndexPage Component 1\n```\n\n```sh\n# Next 콘솔\nLogging from getServerSideProps 1\nLogging from IndexPage Component 2\nLogging from getServerSideProps 3\nLogging from IndexPage Component 4\nLogging from getServerSideProps 5\nLogging from IndexPage Component 6\n```\n\nNodejs 런타임과 브라우저 런타임의 차이로 인해 로그가 다르게 나타납니다. 브라우저 콘솔에서는 계속 `1`이라는 값이 출력됩니다. 새로고침을 할 때 마다 hydration 과정이 새로 진행되기 때문에(서버에서 JS를 새로 불러오기 때문에) 매번 모듈에 선언된 `count` 값이 초기화 됩니다. 반대로 Next는 모듈이 서버 자원으로 로드되기 때문에 서버가 실행되는 동안 모듈의 변수가 지속됩니다. 그래서 함수가 호출될 때 마다 `count` 변수에 담긴 값이 계속 유지되고 변경됩니다.\n\n## 라우팅 과정에서의 동작 알아보기\n\nNext는 파일 기반의 Page 라우팅을 지원합니다. `src/pages` 폴더 하위의 파일 트리 구조를 그대로 라우팅에 매핑시켜 줍니다. 또한 SPA의 특징인 Client Side Routing 역시 제공된다는 것입니다. 예시 코드에 새로운 페이지 컴포넌트 파일을 추가해보겠습니다. 그리고 기존 컴포넌트에 새로운 페이지로 전환하는 링크를 추가합니다.\n\n```tsx\n// src/pages/about.tsx\nimport Link from \"next/link\";\n\nconst AboutPage = () => {\n  return (\n    <div>\n      <h1>About...</h1>\n      <Link href=\"/\">home</Link>\n    </div>\n  );\n};\n\nexport default AboutPage;\n```\n\n```tsx\n// src/pages/index.tsx\nconst IndexPage = () => {\n  // ...\n  return (\n    <div>\n      <h1>Hello {name}!</h1>\n      <Link href=\"/about\">about</Link>\n      {/* ... */}\n    </div>\n  );\n};\n```\n\n이전에 작성했던 디버깅 코드가 그대로 있는 상태에서 이번에는 새로고침이 아닌 페이지 전환을 반복해봅니다. `index` -> `about` -> `index` 순서로 왔다갔다 한 후에 로그를 살펴봅시다. `/index` 페이지를 방문할 때마다 디버깅 로그가 찍힙니다.\n\n```sh\n# 브라우저 콘솔\nLogging from IndexPage Component 1\nLogging from IndexPage Component 2\nLogging from IndexPage Component 3\n```\n\n```sh\n# Next 콘솔\nLogging from getServerSideProps 1\nLogging from IndexPage Component 2\nLogging from getServerSideProps 3\nLogging from getServerSideProps 4\n```\n\n이전에 새로고침만 했을 때와는 다른 결과를 보여줍니다. 최초 진입 이후에 브라우저에서는 렌더링이 진행되고 Next 서버에서는 `getServerSideProps`가 호출되는 것을 확인할 수 있습니다. 브라우저에서 CSR이 진행되는 과정에서 서버는 `getServerSideProps`를 호출하고 데이터를 네트워크로 보내줍니다. 브라우저는 해당 데이터를 받아 `IndexPage`의 `props`를 변경합니다.\n\n브라우저의 개발자도구 네트워크 탭에서 `/index` 페이지로 전환할 때 마다 데이터를 요청하고 응답받는 것을 확인할 수 있습니다.\n\n![Data Fetching on CSR](/react/nextjs-page-props/img/network-tab.png)\n![Data Fetching on CSR](/react/nextjs-page-props/img/network-tab-preview.png)\n\n`getServerSideProps`라는 이름처럼 서버에서 페이지 컴포넌트의 초기 렌더링 데이터를 서버에서 `props`로 가져오는 것입니다.\n\n> 앞에서 잠깐 언급했던 `getInitialProps`는 페이지에 진입할 때 마다, 렌더링하는 컨텍스트에서 함수가 실행됩니다. \\\n> 만약 새로고침이나 첫 페이지 진입처럼 서버에서 렌더링이 수행된다면 서버에서 `getInitialProps`가 호출되고, 브라우저 라우팅으로 진입하여 브라우저에서 렌더링이 수행된다면 브라우저에서 `getInitialProps`가 수행됩니다. \\\n> 실행되는 컨텍스트를 보장할 수 없기 때문에 각각의 컨텍스트에 따라 필요한 처리를 해주어야 합니다.\n\n## 코드 살펴보기\n\n지금까지 알아본 것은 Next가 디음과 같은 상황에서 `getServerSideProps`를 호출하여 페이지 컴포넌트에 `props`로 전달한다는 것입니다.\n\n1. 초기 진입 시 서버에서 페이지 컴포넌트가 렌더링 될 때\n2. 브라우저의 Next 앱 라우팅이 이루어져서 페이지 컴포넌트가 렌더링 될 때\n\n`getServerSideProps`에 대한 모든 상황이나 특징을 알아보진 않았지만 어떻게 동작하는 지 간단히 알아봤습니다. 이번에는 위 상황에서 `getServerSideProps`가 호출되기 위해서 코드에서 어떤 과정으로 진행되는 지 살펴보려합니다. 실제 Next의 코드를 따라가며 앱이 동작하는 방식을 살펴봅시다.\n\n먼저 위 예시 기준으로는 `<Link>` 컴포넌트부터 출발합니다.\n\n> 살펴볼 코드에 집중하기 위해 생략된 부분은 \"// ...\" 등의 주석으로 표시합니다. \\\n> 코드는 [Next.js Github](https://github.com/vercel/next.js/tree/canary/packages/next)에서 찾아볼 수 있습니다.\n\n### 1. Link 컴포넌트 클릭([Code](https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/client/link.tsx#L435))\n\n```tsx\n// next/client/link.tsx#L435\n<a {...restProps} {...childProps}>\n  {children}\n</a>\n```\n\n`Link` 컴포넌트도 React 컴포넌트이기 때문에 jsx로 렌더링되는 요소의 `onClick`을 추적해봅니다. 여기서는 `childProps`라는 값에 `onClick`에 대한 콜백이 포함되어 있습니다.\n\n### 2. onClick 콜백([Code](https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/client/link.tsx#L390))\n\n```tsx\n// next/client/link.tsx#L370\nonClick: (e: React.MouseEvent) => {\n  // ...\n  if (!e.defaultPrevented) {\n    linkClicked(e, router, href, as, replace, shallow, scroll, locale);\n  }\n};\n```\n\n`onClick`의 콜백을 따라가면 여러 예외를 처리하고 `linkClicked` 함수를 호출하여 동작을 위임합니다.\n\n### 3. 라우터 Push([Code](https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/client/link.tsx#L116))\n\n```tsx\n// next/client/link.tsx#L93\nfunction linkClicked(router: NextRouter /* ... */): void {\n  // ...\n  router[replace ? \"replace\" : \"push\"](href, as, {\n    shallow,\n    locale,\n    scroll,\n  });\n}\n```\n\n`linkClicked` 함수에서는 인자로 전달 받은 `router` 객체의 `push` 메소드를 호출합니다.\n\n```tsx\n// next/client/link.tsx#271\nlet router = React.useContext(RouterContext);\n```\n\n`linkClicked` 함수를 호출할 때, 매개변수로 전달한 `router` 객체는 `RouterContext`에서 가져옵니다. `RouterContext`의 초기화 단계에서 객체의 정의를 찾아봅니다.\n\n### 4. Router 객체 추적([Code](https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/client/index.tsx#L638))\n\n```tsx\n// next/client/index.tsx#L638\n<RouterContext.Provider value={makePublicRouterInstance(router)}>\n  {/* ... */}\n  {/* ... */}\n</RouterContext.Provider>\n```\n\n`RouterContext`의 값을 주입하고 있는 부분에서 `router` 객체를 추적합니다. `makePublicRouterInstance`함수는 라우터 객체를 Next에서 필요한 동작을 위한 clone 과정인 것 같습니다. 라우터 객체의 핵심은 `router` 변수에 담긴 객체입니다.\n\n```tsx\n// next/client/index.tsx#L397\nrouter = createRouter(/* ... */);\n```\n\n`createRouter`함수를 호출하여 `router` 객체를 생성합니다. 함수 내에서는 `Router` 클래스의 생성자를 호출하여 객체를 생성합니다.\n\n```tsx\n// next/client/router.ts#L147\nexport function createRouter(...args: RouterArgs): Router {\n  singletonRouter.router = new Router(...args);\n  singletonRouter.readyCallbacks.forEach((cb) => cb());\n  singletonRouter.readyCallbacks = [];\n\n  return singletonRouter.router;\n}\n```\n\n### 5. Router 클래스 정의([Code](https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/shared/lib/router/router.ts#L525))\n\n`Router` 클래스에서 `push` 메소드 정의를 찾습니다.\n\n```tsx\n// next/shared/lib/router/router.ts#L818\npush(url: Url, as?: Url, options: TransitionOptions = {}) {\n  // ...\n  return this.change(\"pushState\", url, as, options);\n}\n```\n\n`push` 메소드는 `Router` 클래스의 `change` 메소드를 호출하여 동작을 위임합니다.\n\n```tsx\n// next/shared/lib/router/router.ts#L847\nprivate async change(/* ... */): Promise<boolean> {\n  // ...\n  // next/shared/lib/router/router.ts#L1210\n  let routeInfo = await this.getRouteInfo(\n    route,\n    pathname,\n    query,\n    as,\n    resolvedAs,\n    routeProps,\n    nextState.locale,\n    nextState.isPreview\n  )\n}\n```\n\n`change` 메소드는 라우팅의 상태에 변경이 있을 때 호출되는 함수로 보입니다. 함수 내부에서 동작하는 로직이 많은데, 여기서 저는 `getRouteInfo` 메소드에 집중합니다.\n\n### 6. 라우팅 변경 시 컴포넌트 데이터 불러오기([Code](https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/shared/lib/router/router.ts#L1534))\n\n```tsx\n// next/shared/lib/router/router.ts#L1467\nasync getRouteInfo(\n    route: string,\n    pathname: string,\n    query: any,\n    as: string,\n    resolvedAs: string,\n    routeProps: RouteProperties,\n    locale: string | undefined,\n    isPreview: boolean\n  ): Promise<PrivateRouteInfo> {\n  // ...\n  // next/shared/lib/router/router.ts#L1534\n  const props = await this._getData<CompletePrivateRouteInfo>(() =>\n    // ...\n    fetchNextData(\n      dataHref!,\n      this.isSsr,\n      false,\n      __N_SSG ? this.sdc : this.sdr,\n      !!__N_SSG && !isPreview,\n      false\n    )\n    // ...\n  )\n}\n```\n\n`getRouteInfo` 메소드는 페이지 컴포넌트의 정의와 SSR, SSG, RSC 유무 등의 정보를 불러옵니다. 이 과정에서 서버에 변경될 `props`에 대한 데이터를 `fetchNextData` 함수를 호출하여 요청합니다.\n\n```tsx\n// next/shared/lib/router/router.ts#L1578\nrouteInfo.props = props;\nthis.components[route] = routeInfo;\nreturn routeInfo;\n```\n\n서버로부터 갱신된 `props`는(실제로는 `props.pageProps`에 페이지 컴포넌트의 `props`가 담겨 있음) `routeInfo` 객체에 할당되어 `return`됩니다. 다시 `getRouteInfo`를 호출했던 부분을 돌아가 `routeInfo` 객체를 추적합니다.\n\n### 7. 변경된 데이터를 컴포넌트에 적용하기([Code](https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/shared/lib/router/router.ts#L1310))\n\n```tsx\n// next/shared/lib/router/router.ts#L1310\nawait this.set(\n  {\n    ...nextState,\n    route,\n    pathname,\n    query,\n    asPath: cleanedAs,\n    isFallback: false,\n  },\n  routeInfo,\n  forcedScroll ?? resetScroll\n);\n```\n\n여기서 `this`는 `Router` 클래스 인스턴스입니다.\n\n```tsx\n// next/shared/lib/router/router.ts#L1952\nprivate set(\n  state: typeof this.state,\n  data: PrivateRouteInfo,\n  resetScroll: { x: number; y: number } | null\n): Promise<void> {\n  this.state = state\n\n  return this.sub(\n    data,\n    this.components['/_app'].Component as AppComponent,\n    resetScroll\n  )\n}\n```\n\n`set` 메소드에서는 다시 `sub` 메소드를 호출합니다. `sub` 메소드는 `Router` 클래스 생성자에서 `subscription` 인자를 받아 할당되는 콜백함수 입니다. `Router` 생성자를 호출하는 부분을 따라가면 `sub` 메소드로 넘겨주는 매개변수를 찾을 수 있습니다.\n\n```tsx\n// next/client/index.tsx#L397\nrouter = createRouter(\n  /* ... */\n  {\n    /* ... */\n    subscription: (info, App, scroll) =>\n      render(\n        Object.assign<{}, Omit<RenderRouteInfo, \"App\" | \"scroll\">, Pick<RenderRouteInfo, \"App\" | \"scroll\">>({}, info, {\n          App,\n          scroll,\n        }) as RenderRouteInfo\n      ),\n    /* ... */\n  }\n);\n```\n\n`subscription` 함수의 정의에서 첫번째 인자로 전달되는 객체가 위에서 살펴본 `routeInfo` 객체입니다. 페이지 컴포넌트의 `props`로 전달될 정보는 `info.props.pageProps`에 담겨 전달됩니다.\n\n`render` 함수를 호출하면서 변경된 데이터를 전달합니다.\n\n```tsx\n// next/client/index.tsx#L439\nasync function render(renderingProps: RenderRouteInfo): Promise<void> {\n  // ...\n  try {\n    await doRender(renderingProps);\n  } catch (err) {\n    // ...\n  }\n}\n```\n\n`render` 함수는 몇 가지 예외 처리를 수행하고 `doRender` 함수를 호출합니다.\n\n```tsx\n// next/client/index.tsx#L833\nfunction doRender(input: RenderRouteInfo): Promise<any> {\n  let { App, Component, props, err, __N_RSC }: RenderRouteInfo = input;\n\n  // ...\n\n  const appProps: AppProps = {\n    ...props,\n    Component: isRSC ? RSCComponent : Component,\n    err,\n    router,\n  };\n\n  // ...\n\n  // next/client/index.tsx#L987\n  const elem: JSX.Element = (\n    <>\n      <Head callback={onHeadCommit} />\n      <AppContainer>\n        {renderApp(App, appProps)}\n        <Portal type=\"next-route-announcer\">\n          <RouteAnnouncer />\n        </Portal>\n      </AppContainer>\n    </>\n  );\n  // ...\n}\n```\n\n`doRender` 함수에서는 변경된 데이터를 Next 루트인 `App` 컴포넌트에 전달하여 리액트 렌더링 트리가 재구성되도록 JSX를 생성합니다. 이후에는 리액트에서 변경된 사항을 ReactDOM 트리를 구성하면서 실제 DOM에 반영하게 됩니다.\n\n### 8. 서버는 어떻게 요청을 받을까\n\n이 과정 역시 `getServerSideProps`의 동작을 이해하는 데에 유익하지만, 내용이 너무 길어지기 때문에 추적할 수 있는 시작 포인트만 짚고 추적 과정은 생략하겠습니다.\n\n```ts\n// next/cli/next-start.ts#L69\nstartServer({\n  dir,\n  hostname: host,\n  port,\n})\n  .then(async (app) => {\n    const appUrl = `http://${app.hostname}:${app.port}`;\n    Log.ready(`started server on ${host}:${app.port}, url: ${appUrl}`);\n    await app.prepare();\n  })\n  .catch((err) => {\n    console.error(err);\n    process.exit(1);\n  });\n```\n\nNext 서버의 시작 부분입니다. `app.prepare()` 메소드를 통해 서버 라우팅 및 모든 동작을 준비합니다. 해당 메소드를 따라 추적하면 서버 앱의 `Router`를 생성하는 부분을 찾을 수 있습니다.\n\n```ts\n// next/server/dev/next-dev-server.ts#L444\nthis.router = new Router(this.generateRoutes());\n```\n\n조금 복잡하지만 `renderHtml`, `render` 함수 등을 거쳐 `getServerSideProps`를 호출하는 곳 까지 추적할 수 있습니다.\n\n```ts\n// next/server/render.tsx#L1041\ndata = await getServerSideProps({\n  req: req as IncomingMessage & {\n    cookies: NextApiRequestCookies;\n  },\n  res: resOrProxy,\n  query,\n  resolvedUrl: renderOpts.resolvedUrl as string,\n  ...(pageIsDynamic ? { params: params as ParsedUrlQuery } : undefined),\n  ...(previewData !== false ? { preview: true, previewData: previewData } : undefined),\n  locales: renderOpts.locales,\n  locale: renderOpts.locale,\n  defaultLocale: renderOpts.defaultLocale,\n});\n```\n\n`data` 객체에 전달된 데이터는 요청을 처리하는 부분에서 클라이언트로 전송됩니다.\n\n```ts\n// next/server/base-server.ts#L1154\nreturn this.pipe((ctx) => this.renderToResponse(ctx), {\n  req,\n  res,\n  pathname,\n  query,\n});\n```\n\n중간 과정이 조금 생략되었지만 `renderToResponse` 메서드 내에서 `getServerSideProps` 함수를 호출하는 것을 발견할 수 있습니다.\n\n## 마치며\n\nNext는 리액트 개발자가 편하게 이용할 수 있는 기능을 제공하는 유용한 프레임워크입니다. 오늘은 Next가 제공하는 `getServerSideProps` 함수가 어떤 동작을 하는지, 어떤 방식으로 구현되었는 지 살펴보았습니다. 코드를 살펴보는 부분에서는 내용이 다소 복잡하게 전달되었을 것 같습니다. 시간을 내어 한번 코드를 따라가면 어떤 메커니즘으로 동작하는 지 이해할 수 있을 것입니다.\n\n단순히 기능을 사용하는 프레임워크 사용자 입장에서 뿐만 아니라, 어떤 식으로 동작하는지 추적해보고 이와 같은 기능을 만들 수 있는 개발자가 되기 위해서 더 공부해야할 것 같습니다. 리액트와 Next를 사용하는 분이 있다면 도움이 되었기를 바랍니다. 긴 글 읽어주셔서 감사합니다.\n","html":"<p><img src=\"/react/nextjs-page-props/img/nextjs.png\" alt=\"NextJS\"></p>\n<p>Nextjs는 리액트 생태계에서 가장 많이 사용하는 프레임워크 중 하나입니다. 주로 SSR 기반의 프로젝트에 사용합니다. 또한 파일 시스템 기반의 직관적인 라우팅, 이미지 최적화, 타입스크립트 지원 등 간단한 설정으로 사용할 수 있는 기능이 많아서 프로젝트를 구성하고 관리하는 작업이 줄어듭니다.</p>\n<p>여러 기능 중 SSR에서는 DataFetch를 쉽게 구현할 수 있습니다. SSR 페이지에서 초기 데이터를 로드하려면 <code>getServerSideProps</code> 함수를 정의하여 페이지 컴포넌트의 <code>Props</code>로 주입받을 수 있습니다. <code>getServerSideProps</code>를 사용해보고 동작하는 방식을 알아보겠습니다.</p>\n<blockquote>\n<p>예시로 작성된 코드 전체는 <a href=\"https://github.com/hoontae24/blog-examples/tree/main/react/nextjs-getServerSideProps\">여기</a>에서 볼 수 있습니다.</p>\n</blockquote>\n<h2 id=\"사용법\">사용법</h2>\n<p>먼저 간단한 페이지 컴포넌트를 만들고, 페이지 컴포넌트 파일에 <code>getServerSideProps</code>라는 이름으로 함수를 정의합니다.</p>\n<pre><code class=\"language-tsx\">// src/pages/index.tsx\ninterface IndexPageProps {\n  name: string;\n}\n\nconst IndexPage: NextPage&lt;IndexPageProps&gt; = (props) =&gt; {\n  const { name } = props;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello {name}!&lt;/h1&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport const getServerSideProps: GetServerSideProps&lt;IndexPageProps&gt; = async () =&gt; {\n  return {\n    props: {\n      name: &quot;Next&quot;,\n    },\n  };\n};\n\nexport default IndexPage;\n</code></pre>\n<p>페이지 컴포넌트가 렌더링되기 전에 <code>getServerSideProps</code> 함수가 실행됩니다. Data Fetch 작업을 <code>getServerSideProps</code> 함수 내에서 처리하면, 페이지 컴포넌트의 <code>props</code>로 전달받아 렌더링합니다. 코드를 약간 수정해서 좀 더 의미있는 예시를 만들어 봅시다.</p>\n<pre><code class=\"language-tsx\">// src/pages/index.tsx\n\ninterface Post {\n  id: number;\n  title: string;\n}\n\ninterface IndexPageProps {\n  name: string;\n  posts: Post[];\n}\n\nconst IndexPage: NextPage&lt;IndexPageProps&gt; = (props) =&gt; {\n  const { name, posts } = props;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello {name}!&lt;/h1&gt;\n      &lt;ul&gt;\n        {posts.map((post) =&gt; (\n          &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport const getServerSideProps: GetServerSideProps&lt;IndexPageProps&gt; = async () =&gt; {\n  const url = &quot;https://jsonplaceholder.typicode.com/posts&quot;;\n  const posts: Post[] = await fetch(url).then((res) =&gt; res.json());\n  return {\n    props: {\n      name: &quot;Next&quot;,\n      posts: posts,\n    },\n  };\n};\n\nexport default IndexPage;\n</code></pre>\n<p>만약 리액트에서 다른 도구를 사용하지 않는다면 <code>useState</code>, <code>useEffect</code> 등으로 데이터를 불러와 상태로 다루게 됩니다. 하지만 <code>getServerSideProps</code>를 이용하면 데이터를 불러오고 관리하는 부분을 리액트 라이프사이클에서 분리하고, 페이지가 렌더링되기 전에 데이터를 불러와 Placeholder를 렌더링하지 않아도 됩니다.</p>\n<h2 id=\"렌더링-과정에서의-동작-알아보기\">렌더링 과정에서의 동작 알아보기</h2>\n<p>위 예시 코드에서 <code>getServerSideProps</code> 함수를 컴포넌트 내에 정의했지만, 리액트 컴포넌트의 라이프사이클과는 분리되어 있음을 알 수 있습니다. 또한 Nextjs에서 과거 Data Fetching을 위해 사용했던 <code>getInitialProps</code>는 컴포넌트의 <code>static method</code>로 정의된 것과 다르게 <code>export</code>를 사용하고 있습니다.</p>\n<p>위 예시 코드에서 함수가 호출되는 것을 디버깅하기 위해 로그를 찍어보겠습니다. 함수 컴포넌트 내부와 <code>getServerSideProps</code> 함수 내에서 디버깅 로그를 남깁니다.</p>\n<pre><code class=\"language-tsx\">const IndexPage = () =&gt; {\n  console.log(&quot;Logging from IndexPage Component&quot;);\n  return (\n    // ...\n  )\n}\nexport const getServerSideProps = async () =&gt; {\n  console.log(&quot;Logging from getServerSideProps&quot;);\n  return {\n    // ...\n  };\n};\n</code></pre>\n<p>이제 브라우저에서 해당 페이지에 접속한 다음 개발자도구의 콘솔과 Next가 실행 중인 콘솔을 열고 새로고침을 합니다. 브라우저 콘솔과 Next 콘솔에서 로그를 확인합니다.</p>\n<pre><code class=\"language-sh\"># 브라우저 콘솔\nLogging from IndexPage Component\n</code></pre>\n<pre><code class=\"language-sh\"># Next 콘솔\nLogging from getServerSideProps\nLogging from IndexPage Component\n</code></pre>\n<p>간단한 디버깅으로 알 수 있는 것은 Next가 <code>getServerSideProps</code> 함수를 먼저 호출하고, 페이지 컴포넌트를 렌더링합니다. 새로고침을 하면 페이지 초기 진입만 반복적으로 이루어지므로, 브라우저 콘솔에서 나타난 로그는 hydration 과정에서 페이지 컴포넌트의 렌더링 시점에 호출된 것으로 보입니다.</p>\n<p>이번에는 페이지 컴포넌트 파일의 루트 영역에 변수 하나를 추가합니다. 그리고 각각의 로그에서 변수를 출력하도록 합니다.</p>\n<pre><code class=\"language-tsx\">let count = 0;\n\nconst IndexPage = () =&gt; {\n  console.log(&quot;Logging from IndexPage Component&quot;, ++count);\n  return (\n    // ...\n  )\n}\nexport const getServerSideProps = async () =&gt; {\n  console.log(&quot;Logging from getServerSideProps&quot;, ++count);\n  return {\n    // ...\n  };\n};\n</code></pre>\n<p>브라우저에서 새로고침을 반복하고 각각의 로그를 살펴봅니다. 새로고침할 때 브라우저 로그를 유지하기 위해 브라우저 콘솔의 <code>Preserve log</code> 옵션을 켜줍니다.</p>\n<pre><code class=\"language-sh\"># 브라우저 콘솔\nLogging from IndexPage Component 1\nLogging from IndexPage Component 1\nLogging from IndexPage Component 1\n</code></pre>\n<pre><code class=\"language-sh\"># Next 콘솔\nLogging from getServerSideProps 1\nLogging from IndexPage Component 2\nLogging from getServerSideProps 3\nLogging from IndexPage Component 4\nLogging from getServerSideProps 5\nLogging from IndexPage Component 6\n</code></pre>\n<p>Nodejs 런타임과 브라우저 런타임의 차이로 인해 로그가 다르게 나타납니다. 브라우저 콘솔에서는 계속 <code>1</code>이라는 값이 출력됩니다. 새로고침을 할 때 마다 hydration 과정이 새로 진행되기 때문에(서버에서 JS를 새로 불러오기 때문에) 매번 모듈에 선언된 <code>count</code> 값이 초기화 됩니다. 반대로 Next는 모듈이 서버 자원으로 로드되기 때문에 서버가 실행되는 동안 모듈의 변수가 지속됩니다. 그래서 함수가 호출될 때 마다 <code>count</code> 변수에 담긴 값이 계속 유지되고 변경됩니다.</p>\n<h2 id=\"라우팅-과정에서의-동작-알아보기\">라우팅 과정에서의 동작 알아보기</h2>\n<p>Next는 파일 기반의 Page 라우팅을 지원합니다. <code>src/pages</code> 폴더 하위의 파일 트리 구조를 그대로 라우팅에 매핑시켜 줍니다. 또한 SPA의 특징인 Client Side Routing 역시 제공된다는 것입니다. 예시 코드에 새로운 페이지 컴포넌트 파일을 추가해보겠습니다. 그리고 기존 컴포넌트에 새로운 페이지로 전환하는 링크를 추가합니다.</p>\n<pre><code class=\"language-tsx\">// src/pages/about.tsx\nimport Link from &quot;next/link&quot;;\n\nconst AboutPage = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;About...&lt;/h1&gt;\n      &lt;Link href=&quot;/&quot;&gt;home&lt;/Link&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default AboutPage;\n</code></pre>\n<pre><code class=\"language-tsx\">// src/pages/index.tsx\nconst IndexPage = () =&gt; {\n  // ...\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello {name}!&lt;/h1&gt;\n      &lt;Link href=&quot;/about&quot;&gt;about&lt;/Link&gt;\n      {/* ... */}\n    &lt;/div&gt;\n  );\n};\n</code></pre>\n<p>이전에 작성했던 디버깅 코드가 그대로 있는 상태에서 이번에는 새로고침이 아닌 페이지 전환을 반복해봅니다. <code>index</code> -&gt; <code>about</code> -&gt; <code>index</code> 순서로 왔다갔다 한 후에 로그를 살펴봅시다. <code>/index</code> 페이지를 방문할 때마다 디버깅 로그가 찍힙니다.</p>\n<pre><code class=\"language-sh\"># 브라우저 콘솔\nLogging from IndexPage Component 1\nLogging from IndexPage Component 2\nLogging from IndexPage Component 3\n</code></pre>\n<pre><code class=\"language-sh\"># Next 콘솔\nLogging from getServerSideProps 1\nLogging from IndexPage Component 2\nLogging from getServerSideProps 3\nLogging from getServerSideProps 4\n</code></pre>\n<p>이전에 새로고침만 했을 때와는 다른 결과를 보여줍니다. 최초 진입 이후에 브라우저에서는 렌더링이 진행되고 Next 서버에서는 <code>getServerSideProps</code>가 호출되는 것을 확인할 수 있습니다. 브라우저에서 CSR이 진행되는 과정에서 서버는 <code>getServerSideProps</code>를 호출하고 데이터를 네트워크로 보내줍니다. 브라우저는 해당 데이터를 받아 <code>IndexPage</code>의 <code>props</code>를 변경합니다.</p>\n<p>브라우저의 개발자도구 네트워크 탭에서 <code>/index</code> 페이지로 전환할 때 마다 데이터를 요청하고 응답받는 것을 확인할 수 있습니다.</p>\n<p><img src=\"/react/nextjs-page-props/img/network-tab.png\" alt=\"Data Fetching on CSR\">\n<img src=\"/react/nextjs-page-props/img/network-tab-preview.png\" alt=\"Data Fetching on CSR\"></p>\n<p><code>getServerSideProps</code>라는 이름처럼 서버에서 페이지 컴포넌트의 초기 렌더링 데이터를 서버에서 <code>props</code>로 가져오는 것입니다.</p>\n<blockquote>\n<p>앞에서 잠깐 언급했던 <code>getInitialProps</code>는 페이지에 진입할 때 마다, 렌더링하는 컨텍스트에서 함수가 실행됩니다. <br>만약 새로고침이나 첫 페이지 진입처럼 서버에서 렌더링이 수행된다면 서버에서 <code>getInitialProps</code>가 호출되고, 브라우저 라우팅으로 진입하여 브라우저에서 렌더링이 수행된다면 브라우저에서 <code>getInitialProps</code>가 수행됩니다. <br>실행되는 컨텍스트를 보장할 수 없기 때문에 각각의 컨텍스트에 따라 필요한 처리를 해주어야 합니다.</p>\n</blockquote>\n<h2 id=\"코드-살펴보기\">코드 살펴보기</h2>\n<p>지금까지 알아본 것은 Next가 디음과 같은 상황에서 <code>getServerSideProps</code>를 호출하여 페이지 컴포넌트에 <code>props</code>로 전달한다는 것입니다.</p>\n<ol>\n<li>초기 진입 시 서버에서 페이지 컴포넌트가 렌더링 될 때</li>\n<li>브라우저의 Next 앱 라우팅이 이루어져서 페이지 컴포넌트가 렌더링 될 때</li>\n</ol>\n<p><code>getServerSideProps</code>에 대한 모든 상황이나 특징을 알아보진 않았지만 어떻게 동작하는 지 간단히 알아봤습니다. 이번에는 위 상황에서 <code>getServerSideProps</code>가 호출되기 위해서 코드에서 어떤 과정으로 진행되는 지 살펴보려합니다. 실제 Next의 코드를 따라가며 앱이 동작하는 방식을 살펴봅시다.</p>\n<p>먼저 위 예시 기준으로는 <code>&lt;Link&gt;</code> 컴포넌트부터 출발합니다.</p>\n<blockquote>\n<p>살펴볼 코드에 집중하기 위해 생략된 부분은 &quot;// ...&quot; 등의 주석으로 표시합니다. <br>코드는 <a href=\"https://github.com/vercel/next.js/tree/canary/packages/next\">Next.js Github</a>에서 찾아볼 수 있습니다.</p>\n</blockquote>\n<h3 id=\"1-link-컴포넌트-클릭code\">1. Link 컴포넌트 클릭(<a href=\"https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/client/link.tsx#L435\">Code</a>)</h3>\n<pre><code class=\"language-tsx\">// next/client/link.tsx#L435\n&lt;a {...restProps} {...childProps}&gt;\n  {children}\n&lt;/a&gt;\n</code></pre>\n<p><code>Link</code> 컴포넌트도 React 컴포넌트이기 때문에 jsx로 렌더링되는 요소의 <code>onClick</code>을 추적해봅니다. 여기서는 <code>childProps</code>라는 값에 <code>onClick</code>에 대한 콜백이 포함되어 있습니다.</p>\n<h3 id=\"2-onclick-콜백code\">2. onClick 콜백(<a href=\"https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/client/link.tsx#L390\">Code</a>)</h3>\n<pre><code class=\"language-tsx\">// next/client/link.tsx#L370\nonClick: (e: React.MouseEvent) =&gt; {\n  // ...\n  if (!e.defaultPrevented) {\n    linkClicked(e, router, href, as, replace, shallow, scroll, locale);\n  }\n};\n</code></pre>\n<p><code>onClick</code>의 콜백을 따라가면 여러 예외를 처리하고 <code>linkClicked</code> 함수를 호출하여 동작을 위임합니다.</p>\n<h3 id=\"3-라우터-pushcode\">3. 라우터 Push(<a href=\"https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/client/link.tsx#L116\">Code</a>)</h3>\n<pre><code class=\"language-tsx\">// next/client/link.tsx#L93\nfunction linkClicked(router: NextRouter /* ... */): void {\n  // ...\n  router[replace ? &quot;replace&quot; : &quot;push&quot;](href, as, {\n    shallow,\n    locale,\n    scroll,\n  });\n}\n</code></pre>\n<p><code>linkClicked</code> 함수에서는 인자로 전달 받은 <code>router</code> 객체의 <code>push</code> 메소드를 호출합니다.</p>\n<pre><code class=\"language-tsx\">// next/client/link.tsx#271\nlet router = React.useContext(RouterContext);\n</code></pre>\n<p><code>linkClicked</code> 함수를 호출할 때, 매개변수로 전달한 <code>router</code> 객체는 <code>RouterContext</code>에서 가져옵니다. <code>RouterContext</code>의 초기화 단계에서 객체의 정의를 찾아봅니다.</p>\n<h3 id=\"4-router-객체-추적code\">4. Router 객체 추적(<a href=\"https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/client/index.tsx#L638\">Code</a>)</h3>\n<pre><code class=\"language-tsx\">// next/client/index.tsx#L638\n&lt;RouterContext.Provider value={makePublicRouterInstance(router)}&gt;\n  {/* ... */}\n  {/* ... */}\n&lt;/RouterContext.Provider&gt;\n</code></pre>\n<p><code>RouterContext</code>의 값을 주입하고 있는 부분에서 <code>router</code> 객체를 추적합니다. <code>makePublicRouterInstance</code>함수는 라우터 객체를 Next에서 필요한 동작을 위한 clone 과정인 것 같습니다. 라우터 객체의 핵심은 <code>router</code> 변수에 담긴 객체입니다.</p>\n<pre><code class=\"language-tsx\">// next/client/index.tsx#L397\nrouter = createRouter(/* ... */);\n</code></pre>\n<p><code>createRouter</code>함수를 호출하여 <code>router</code> 객체를 생성합니다. 함수 내에서는 <code>Router</code> 클래스의 생성자를 호출하여 객체를 생성합니다.</p>\n<pre><code class=\"language-tsx\">// next/client/router.ts#L147\nexport function createRouter(...args: RouterArgs): Router {\n  singletonRouter.router = new Router(...args);\n  singletonRouter.readyCallbacks.forEach((cb) =&gt; cb());\n  singletonRouter.readyCallbacks = [];\n\n  return singletonRouter.router;\n}\n</code></pre>\n<h3 id=\"5-router-클래스-정의code\">5. Router 클래스 정의(<a href=\"https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/shared/lib/router/router.ts#L525\">Code</a>)</h3>\n<p><code>Router</code> 클래스에서 <code>push</code> 메소드 정의를 찾습니다.</p>\n<pre><code class=\"language-tsx\">// next/shared/lib/router/router.ts#L818\npush(url: Url, as?: Url, options: TransitionOptions = {}) {\n  // ...\n  return this.change(&quot;pushState&quot;, url, as, options);\n}\n</code></pre>\n<p><code>push</code> 메소드는 <code>Router</code> 클래스의 <code>change</code> 메소드를 호출하여 동작을 위임합니다.</p>\n<pre><code class=\"language-tsx\">// next/shared/lib/router/router.ts#L847\nprivate async change(/* ... */): Promise&lt;boolean&gt; {\n  // ...\n  // next/shared/lib/router/router.ts#L1210\n  let routeInfo = await this.getRouteInfo(\n    route,\n    pathname,\n    query,\n    as,\n    resolvedAs,\n    routeProps,\n    nextState.locale,\n    nextState.isPreview\n  )\n}\n</code></pre>\n<p><code>change</code> 메소드는 라우팅의 상태에 변경이 있을 때 호출되는 함수로 보입니다. 함수 내부에서 동작하는 로직이 많은데, 여기서 저는 <code>getRouteInfo</code> 메소드에 집중합니다.</p>\n<h3 id=\"6-라우팅-변경-시-컴포넌트-데이터-불러오기code\">6. 라우팅 변경 시 컴포넌트 데이터 불러오기(<a href=\"https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/shared/lib/router/router.ts#L1534\">Code</a>)</h3>\n<pre><code class=\"language-tsx\">// next/shared/lib/router/router.ts#L1467\nasync getRouteInfo(\n    route: string,\n    pathname: string,\n    query: any,\n    as: string,\n    resolvedAs: string,\n    routeProps: RouteProperties,\n    locale: string | undefined,\n    isPreview: boolean\n  ): Promise&lt;PrivateRouteInfo&gt; {\n  // ...\n  // next/shared/lib/router/router.ts#L1534\n  const props = await this._getData&lt;CompletePrivateRouteInfo&gt;(() =&gt;\n    // ...\n    fetchNextData(\n      dataHref!,\n      this.isSsr,\n      false,\n      __N_SSG ? this.sdc : this.sdr,\n      !!__N_SSG &amp;&amp; !isPreview,\n      false\n    )\n    // ...\n  )\n}\n</code></pre>\n<p><code>getRouteInfo</code> 메소드는 페이지 컴포넌트의 정의와 SSR, SSG, RSC 유무 등의 정보를 불러옵니다. 이 과정에서 서버에 변경될 <code>props</code>에 대한 데이터를 <code>fetchNextData</code> 함수를 호출하여 요청합니다.</p>\n<pre><code class=\"language-tsx\">// next/shared/lib/router/router.ts#L1578\nrouteInfo.props = props;\nthis.components[route] = routeInfo;\nreturn routeInfo;\n</code></pre>\n<p>서버로부터 갱신된 <code>props</code>는(실제로는 <code>props.pageProps</code>에 페이지 컴포넌트의 <code>props</code>가 담겨 있음) <code>routeInfo</code> 객체에 할당되어 <code>return</code>됩니다. 다시 <code>getRouteInfo</code>를 호출했던 부분을 돌아가 <code>routeInfo</code> 객체를 추적합니다.</p>\n<h3 id=\"7-변경된-데이터를-컴포넌트에-적용하기code\">7. 변경된 데이터를 컴포넌트에 적용하기(<a href=\"https://github.com/vercel/next.js/blob/5384171bb651ab24398168ac26f76fac37a0f841/packages/next/shared/lib/router/router.ts#L1310\">Code</a>)</h3>\n<pre><code class=\"language-tsx\">// next/shared/lib/router/router.ts#L1310\nawait this.set(\n  {\n    ...nextState,\n    route,\n    pathname,\n    query,\n    asPath: cleanedAs,\n    isFallback: false,\n  },\n  routeInfo,\n  forcedScroll ?? resetScroll\n);\n</code></pre>\n<p>여기서 <code>this</code>는 <code>Router</code> 클래스 인스턴스입니다.</p>\n<pre><code class=\"language-tsx\">// next/shared/lib/router/router.ts#L1952\nprivate set(\n  state: typeof this.state,\n  data: PrivateRouteInfo,\n  resetScroll: { x: number; y: number } | null\n): Promise&lt;void&gt; {\n  this.state = state\n\n  return this.sub(\n    data,\n    this.components[&#39;/_app&#39;].Component as AppComponent,\n    resetScroll\n  )\n}\n</code></pre>\n<p><code>set</code> 메소드에서는 다시 <code>sub</code> 메소드를 호출합니다. <code>sub</code> 메소드는 <code>Router</code> 클래스 생성자에서 <code>subscription</code> 인자를 받아 할당되는 콜백함수 입니다. <code>Router</code> 생성자를 호출하는 부분을 따라가면 <code>sub</code> 메소드로 넘겨주는 매개변수를 찾을 수 있습니다.</p>\n<pre><code class=\"language-tsx\">// next/client/index.tsx#L397\nrouter = createRouter(\n  /* ... */\n  {\n    /* ... */\n    subscription: (info, App, scroll) =&gt;\n      render(\n        Object.assign&lt;{}, Omit&lt;RenderRouteInfo, &quot;App&quot; | &quot;scroll&quot;&gt;, Pick&lt;RenderRouteInfo, &quot;App&quot; | &quot;scroll&quot;&gt;&gt;({}, info, {\n          App,\n          scroll,\n        }) as RenderRouteInfo\n      ),\n    /* ... */\n  }\n);\n</code></pre>\n<p><code>subscription</code> 함수의 정의에서 첫번째 인자로 전달되는 객체가 위에서 살펴본 <code>routeInfo</code> 객체입니다. 페이지 컴포넌트의 <code>props</code>로 전달될 정보는 <code>info.props.pageProps</code>에 담겨 전달됩니다.</p>\n<p><code>render</code> 함수를 호출하면서 변경된 데이터를 전달합니다.</p>\n<pre><code class=\"language-tsx\">// next/client/index.tsx#L439\nasync function render(renderingProps: RenderRouteInfo): Promise&lt;void&gt; {\n  // ...\n  try {\n    await doRender(renderingProps);\n  } catch (err) {\n    // ...\n  }\n}\n</code></pre>\n<p><code>render</code> 함수는 몇 가지 예외 처리를 수행하고 <code>doRender</code> 함수를 호출합니다.</p>\n<pre><code class=\"language-tsx\">// next/client/index.tsx#L833\nfunction doRender(input: RenderRouteInfo): Promise&lt;any&gt; {\n  let { App, Component, props, err, __N_RSC }: RenderRouteInfo = input;\n\n  // ...\n\n  const appProps: AppProps = {\n    ...props,\n    Component: isRSC ? RSCComponent : Component,\n    err,\n    router,\n  };\n\n  // ...\n\n  // next/client/index.tsx#L987\n  const elem: JSX.Element = (\n    &lt;&gt;\n      &lt;Head callback={onHeadCommit} /&gt;\n      &lt;AppContainer&gt;\n        {renderApp(App, appProps)}\n        &lt;Portal type=&quot;next-route-announcer&quot;&gt;\n          &lt;RouteAnnouncer /&gt;\n        &lt;/Portal&gt;\n      &lt;/AppContainer&gt;\n    &lt;/&gt;\n  );\n  // ...\n}\n</code></pre>\n<p><code>doRender</code> 함수에서는 변경된 데이터를 Next 루트인 <code>App</code> 컴포넌트에 전달하여 리액트 렌더링 트리가 재구성되도록 JSX를 생성합니다. 이후에는 리액트에서 변경된 사항을 ReactDOM 트리를 구성하면서 실제 DOM에 반영하게 됩니다.</p>\n<h3 id=\"8-서버는-어떻게-요청을-받을까\">8. 서버는 어떻게 요청을 받을까</h3>\n<p>이 과정 역시 <code>getServerSideProps</code>의 동작을 이해하는 데에 유익하지만, 내용이 너무 길어지기 때문에 추적할 수 있는 시작 포인트만 짚고 추적 과정은 생략하겠습니다.</p>\n<pre><code class=\"language-ts\">// next/cli/next-start.ts#L69\nstartServer({\n  dir,\n  hostname: host,\n  port,\n})\n  .then(async (app) =&gt; {\n    const appUrl = `http://${app.hostname}:${app.port}`;\n    Log.ready(`started server on ${host}:${app.port}, url: ${appUrl}`);\n    await app.prepare();\n  })\n  .catch((err) =&gt; {\n    console.error(err);\n    process.exit(1);\n  });\n</code></pre>\n<p>Next 서버의 시작 부분입니다. <code>app.prepare()</code> 메소드를 통해 서버 라우팅 및 모든 동작을 준비합니다. 해당 메소드를 따라 추적하면 서버 앱의 <code>Router</code>를 생성하는 부분을 찾을 수 있습니다.</p>\n<pre><code class=\"language-ts\">// next/server/dev/next-dev-server.ts#L444\nthis.router = new Router(this.generateRoutes());\n</code></pre>\n<p>조금 복잡하지만 <code>renderHtml</code>, <code>render</code> 함수 등을 거쳐 <code>getServerSideProps</code>를 호출하는 곳 까지 추적할 수 있습니다.</p>\n<pre><code class=\"language-ts\">// next/server/render.tsx#L1041\ndata = await getServerSideProps({\n  req: req as IncomingMessage &amp; {\n    cookies: NextApiRequestCookies;\n  },\n  res: resOrProxy,\n  query,\n  resolvedUrl: renderOpts.resolvedUrl as string,\n  ...(pageIsDynamic ? { params: params as ParsedUrlQuery } : undefined),\n  ...(previewData !== false ? { preview: true, previewData: previewData } : undefined),\n  locales: renderOpts.locales,\n  locale: renderOpts.locale,\n  defaultLocale: renderOpts.defaultLocale,\n});\n</code></pre>\n<p><code>data</code> 객체에 전달된 데이터는 요청을 처리하는 부분에서 클라이언트로 전송됩니다.</p>\n<pre><code class=\"language-ts\">// next/server/base-server.ts#L1154\nreturn this.pipe((ctx) =&gt; this.renderToResponse(ctx), {\n  req,\n  res,\n  pathname,\n  query,\n});\n</code></pre>\n<p>중간 과정이 조금 생략되었지만 <code>renderToResponse</code> 메서드 내에서 <code>getServerSideProps</code> 함수를 호출하는 것을 발견할 수 있습니다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>Next는 리액트 개발자가 편하게 이용할 수 있는 기능을 제공하는 유용한 프레임워크입니다. 오늘은 Next가 제공하는 <code>getServerSideProps</code> 함수가 어떤 동작을 하는지, 어떤 방식으로 구현되었는 지 살펴보았습니다. 코드를 살펴보는 부분에서는 내용이 다소 복잡하게 전달되었을 것 같습니다. 시간을 내어 한번 코드를 따라가면 어떤 메커니즘으로 동작하는 지 이해할 수 있을 것입니다.</p>\n<p>단순히 기능을 사용하는 프레임워크 사용자 입장에서 뿐만 아니라, 어떤 식으로 동작하는지 추적해보고 이와 같은 기능을 만들 수 있는 개발자가 되기 위해서 더 공부해야할 것 같습니다. 리액트와 Next를 사용하는 분이 있다면 도움이 되었기를 바랍니다. 긴 글 읽어주셔서 감사합니다.</p>\n","excerpt":"Nextjs 페이지 컴포넌트의 핵심 기능인 getServerSideProps가 props를 변경하고 전달하는 동작에 대해 알아보겠습니다. Nextjs는 리액트 생태계에서 가장 많이 사용하는 프레임워크 중 하나입니다. 주로 SSR 기반의 프로젝트에 사용합니다. 또한 파일 시스템 기반의 직관적인 라우팅, 이미지 최적화, 타입스크립트 지원 등 간단한 설정으로 사용할 수 있는 기능이 많아서 프로젝트를 구성하고 관리하는 작업이 줄어듭니다. 여러 기능 중 SSR에서는 DataFetch를 쉽게 구현할 수","thumbnail":"/react/nextjs-page-props/img/nextjs.png","thumbnailUrl":"https://hoontae24.github.io/react/nextjs-page-props/img/nextjs.png"},{"href":"25","round":25,"paths":["cicd","build-docker-image-using-github-actions"],"slug":"build-docker-image-using-github-actions","title":"Github Actions를 이용하여 docker image 빌드하기","description":"Github Actions를 이용하여 어플리케이션을 Docker 이미지로 빌드하고 ghcr.io 저장소에 푸시하는 과정을 알아봅니다.","date":"2022-05-02","category":"cicd","tags":["ci/cd","github"],"seriesId":null,"markdown":"\n![github actions icon](/cicd/build-docker-image-using-github-actions/img/github-actions-icon.png)\n\n소프트웨어 제품이나 서비스의 운영에 있어 배포는 적지 않게 중요합니다. 특히 운영 규모가 커지거나 많은 사람이 협업하는 경우에는 더욱 강조될 것입니다. 그렇기에 배포 프로세스를 자동화하면 생산성을 높이고, 휴먼 에러를 줄일 수 있습니다.\n\n요즘은 서비스 운영 환경이 컨테이너 기반으로 이루어진 경우도 많이 있습니다. 만약 kubernetes를 사용한다면 필수적입니다. 오늘은 그러한 운영 환경을 위한 배포 프로세스의 일부분이 될 수 있는 이미지 빌드에 대한 작업을 알아보겠습니다. 또한 많은 개발자들이 사용하는 Github에서 제공하는 기능인 Github Actions를 이용하여 이미지 빌드를 자동화해보겠습니다.\n\n> 오늘 다룰 내용에서는 배포를 위한 이미지 빌드 이후에 운영 환경에 배포하는 작업은 포함하지 않습니다.\n\n모든 소스코드는 [이 저장소](https://github.com/hoontae24/node-http-server)에서 보실 수 있습니다.\n\n## 1. 어플리케이션 준비\n\n먼저 배포할 어플리케이션을 준비합니다. Node.js 기반의 간단한 HTTP 서버를 작성합니다. npm 패키지를 포함하기 위해 `lodash`도 추가했습니다.\n\n```js\nconst http = require(\"http\");\nconst lodash = require(\"lodash\");\n\nhttp\n  .createServer((request, response) => {\n    const url = lodash.get(request, \"url\");\n    console.log(\"incoming request\", url);\n    response.end(`Hello World on ${url}`);\n  })\n  .listen(8080, () => console.log(\"Server is listening on port 8080\"));\n```\n\n빌드된 이미지로 컨테이너를 생성할 때, 명령어를 통해 서버를 실행할 수 있도록 `package.json`에 다음 내용을 추가했습니다.\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"node index.js\"\n  }\n}\n```\n\n## 2. Dockerfile 작성\n\n작성된 서버를 docker 이미지로 빌드하려면 Dockerfile을 작성하여 이미지 빌드에 대한 스펙 및 동작을 작성해주어야 합니다. Node.js 이미지를 빌드하기 위한 Dockerfile에 대한 예시는 [여기](https://nodejs.org/ko/docs/guides/nodejs-docker-webapp/)서 참고할 수 있습니다.\n\n```Dockerfile\nFROM node:16\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 8080\n\nCMD [ \"npm\", \"start\" ]\n```\n\n작성된 `Dockerfile`이 제대로 빌드되는지 로컬에서 먼저 테스트 해봅니다. 제대로 빌드가 되었다면 이미지 목록에서 확인할 수 있습니다.\n\n```sh\ndocker build -t node-http-server:latest .\n\ndocker images\n```\n\n빌드된 이미지를 컨테이너로 실행해봅니다.\n\n```sh\ndocker run -itd -p 8080:8080 --name node-http-server node-http-server:latest\n```\n\n위 명령어로 빌드된 어플리케이션 이미지가 `8080`포트로 개방된 컨테이너로 실행됩니다.\n\n```sh\ncurl localhost:8080\n\ncurl localhost:8080/hello-world\n```\n\n`Dockerfile`로 작성된 어플리케이션 이미지는 잘 동작되는 것을 확인했으니, 이제 Github Actions를 사용하여 이미지가 자동으로 빌드되는 방법을 알아보겠습니다.\n\n## 3. Github Token(PAT) 생성 및 등록\n\ndocker 이미지를 빌드한 후 저장할 이미지 저장소가 필요합니다. `dockerhub`, `aws ecr`, `ghcr` 등이 있습니다. 이번 글에서는 Github Container Registry인 `ghcr`에 빌드된 이미지를 저장하겠습니다.\n\n`ghcr`에 접근하기 위해서는 Github 계정의 `Personal Access Token`이 필요합니다. Github Actions 또는 다른 자동화 스크립트에서 Github에 접근할 수 있도록 인증을 위한 토큰입니다.\n\nGithub에서 `Settings` > `Developer Settings` > `Personal Access Token` 메뉴로 진입하여, `Generate new token`을 선택합니다.\n\n![generate new token](/cicd/build-docker-image-using-github-actions/img/generate-new-token.png)\n\n적당한 토큰에 대한 내용을 입력하고 `write:packages`, `read:packages`, `delete:packages` 권한을 선택한 후 토큰을 생성합니다. 생성된 토큰은 복사하여 따로 저장해둡니다.\n\n이제 Github Actions가 실행될 저장소에 토큰을 등록하겠습니다. `Repository's settings` > `Secrets` > `Actions` 메뉴로 진입하여 `New repository secret`을 선택합니다.\n\n![add repository secret](/cicd/build-docker-image-using-github-actions/img/add-repository-secret.png)\n\n## 4. Github workflows 작성\n\n이제 Github Actions를 사용하여 이미지를 빌드하기 위해 저장소에 workflow를 작성합니다. `.github/workflows/build-image.yml` 파일을 생성하고 다음을 작성합니다. 빌드와 이미지 태깅에 대한 부분 모두 marketplace에서 불러와 사용합니다.\n\n```yml\nname: build-image\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  build-and-push-image:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Log in to the Container registry\n        uses: docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.BUILD_IMAGE_FOR_GHCR }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@98669ae865ea3cffbcbaa878cf57c20bbf1c6c38\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n          tags: |\n            type=sha\n          flavor: |\n            latest=true\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n```\n\n각 부분을 간단하게만 짚어 보겠습니다.\n\n```yml\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n```\n\nworkflow 내에서 사용할 환경변수를 선언합니다. 빌드된 이미지의 이름을 현재 저장소 이름으로 지정합니다.\n\n```yml\npermissions:\n  contents: read\n  packages: write\n```\n\n저장소의 컨텐츠에 대한 권한과 패키지에 대한 권한을 지정합니다.([자세히](https://docs.github.com/en/actions/using-jobs/assigning-permissions-to-jobs))\n\n```yml\n- name: Log in to the Container registry\n  uses: docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9\n  with:\n    registry: ${{ env.REGISTRY }}\n    username: ${{ github.actor }}\n    password: ${{ secrets.BUILD_IMAGE_FOR_GHCR }}\n```\n\nGithub Container Registry에 접근할 수 있도록 인증 절차를 진행합니다. 저장소에 등록해둔 PAT를 불러와 로그인합니다.\n\n```yml\n- name: Build and push Docker image\n  uses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\n  with:\n    context: .\n    push: true\n    tags: ${{ steps.meta.outputs.tags }}\n    labels: ${{ steps.meta.outputs.labels }}\n```\n\n이미지를 빌드하고 로그인된 저장소에 푸시합니다. 이 때, 이미지 태그를 지정해줄 수 있습니다. 여기서는 앞선 step에서 저장소 이름을 사용하도록 지정했습니다.\n\n이제 작성된 workflow 파일을 저장하고 커밋한 뒤 `git push` 명령으로 코드를 푸시합니다. workflow가 푸시되면 Github Actions가 동작합니다. Github 저장소에서 `Actions` 탭을 확인해보겠습니다.\n\n![github actions](/cicd/build-docker-image-using-github-actions/img/github-actions.png)\n\n정상적으로 workflow가 성공한다면 해당 저장소의 `packages`에서 빌드된 이미지를 확인할 수 있습니다.\n\n![github new package](/cicd/build-docker-image-using-github-actions/img/github-repository-home-for-new-package.png)\n\n![github packages](/cicd/build-docker-image-using-github-actions/img/github-packages.png)\n\n## 5. 빌드된 이미지 Pull 받아 컨테이너로 실행하기\n\n`ghcr`에 올라간 이미지를 수동으로 내려 받아 컨테이너로 실행하여 제대로 빌드된 것인지 확인해보겠습니다. ghcr에 접근하기 위해 앞 단계에서 생성했던 PAT가 필요합니다.\n\n로컬에서 docker 이미지 저장소를 `ghcr.io`로 로그인합니다. `$PAT`에는 PAT를 입력하고, `$USERNAME`에는 github username을 입력합니다.\n\n```sh\necho \"$PAT\" | docker login ghcr.io -u $USERNAME --password-stdin\n```\n\n![login to ghcr](/cicd/build-docker-image-using-github-actions/img/login-to-ghcr.png)\n\n이제 빌드된 이미지를 Pull하여 내려 받습니다.\n\n```sh\ndocker pull ghcr.io/hoontae24/node-http-server\n```\n\n![docker pull image](/cicd/build-docker-image-using-github-actions/img/docker-pull.png)\n\n이제 앞 단계와 같이 컨테이너를 실행해봅니다.\n\n```sh\ndocker run -itd -p 8080:8080 --name node-http-server ghcr.io/hoontae24/node-http-server:latest\n```\n\n![docker run container](/cicd/build-docker-image-using-github-actions/img/docker-run-conatiner.png)\n\n`ghcr`로부터 내려받은 이미지가 컨테이너로 잘 동작하는 것을 확인할 수 있습니다.\n\n## 마치며\n\n오늘은 Github Actions를 이용하여 Docker 이미지를 빌드하고 Github Container Registry에 올리는 작업을 진행해봤습니다. 배포 프로세스를 자동화하는 과정 중 일부를 Github Actions를 이용하면 어렵지 않게 진행할 수 있을 것으로 보입니다.\n\n이번에는 편의를 위해 `ghcr.io`에 작업을 하였는데, 자주 사용하는 `dockerhub`나 `aws ecr`에도 적용해보면 좋을 것 같습니다. 또한 이미지 빌드뿐만 아니라 운영 서비스를 업데이트 하는 배포 과정에도 Github Actions를 사용해보면 좋을 것 같습니다.\n\n> 도움을 받은 자료\n>\n> - https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry\n","html":"<p><img src=\"/cicd/build-docker-image-using-github-actions/img/github-actions-icon.png\" alt=\"github actions icon\"></p>\n<p>소프트웨어 제품이나 서비스의 운영에 있어 배포는 적지 않게 중요합니다. 특히 운영 규모가 커지거나 많은 사람이 협업하는 경우에는 더욱 강조될 것입니다. 그렇기에 배포 프로세스를 자동화하면 생산성을 높이고, 휴먼 에러를 줄일 수 있습니다.</p>\n<p>요즘은 서비스 운영 환경이 컨테이너 기반으로 이루어진 경우도 많이 있습니다. 만약 kubernetes를 사용한다면 필수적입니다. 오늘은 그러한 운영 환경을 위한 배포 프로세스의 일부분이 될 수 있는 이미지 빌드에 대한 작업을 알아보겠습니다. 또한 많은 개발자들이 사용하는 Github에서 제공하는 기능인 Github Actions를 이용하여 이미지 빌드를 자동화해보겠습니다.</p>\n<blockquote>\n<p>오늘 다룰 내용에서는 배포를 위한 이미지 빌드 이후에 운영 환경에 배포하는 작업은 포함하지 않습니다.</p>\n</blockquote>\n<p>모든 소스코드는 <a href=\"https://github.com/hoontae24/node-http-server\">이 저장소</a>에서 보실 수 있습니다.</p>\n<h2 id=\"1-어플리케이션-준비\">1. 어플리케이션 준비</h2>\n<p>먼저 배포할 어플리케이션을 준비합니다. Node.js 기반의 간단한 HTTP 서버를 작성합니다. npm 패키지를 포함하기 위해 <code>lodash</code>도 추가했습니다.</p>\n<pre><code class=\"language-js\">const http = require(&quot;http&quot;);\nconst lodash = require(&quot;lodash&quot;);\n\nhttp\n  .createServer((request, response) =&gt; {\n    const url = lodash.get(request, &quot;url&quot;);\n    console.log(&quot;incoming request&quot;, url);\n    response.end(`Hello World on ${url}`);\n  })\n  .listen(8080, () =&gt; console.log(&quot;Server is listening on port 8080&quot;));\n</code></pre>\n<p>빌드된 이미지로 컨테이너를 생성할 때, 명령어를 통해 서버를 실행할 수 있도록 <code>package.json</code>에 다음 내용을 추가했습니다.</p>\n<pre><code class=\"language-json\">{\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;node index.js&quot;\n  }\n}\n</code></pre>\n<h2 id=\"2-dockerfile-작성\">2. Dockerfile 작성</h2>\n<p>작성된 서버를 docker 이미지로 빌드하려면 Dockerfile을 작성하여 이미지 빌드에 대한 스펙 및 동작을 작성해주어야 합니다. Node.js 이미지를 빌드하기 위한 Dockerfile에 대한 예시는 <a href=\"https://nodejs.org/ko/docs/guides/nodejs-docker-webapp/\">여기</a>서 참고할 수 있습니다.</p>\n<pre><code class=\"language-Dockerfile\">FROM node:16\n\nWORKDIR /usr/src/app\n\nCOPY package*.json ./\n\nRUN npm ci --only=production\n\nCOPY . .\n\nEXPOSE 8080\n\nCMD [ &quot;npm&quot;, &quot;start&quot; ]\n</code></pre>\n<p>작성된 <code>Dockerfile</code>이 제대로 빌드되는지 로컬에서 먼저 테스트 해봅니다. 제대로 빌드가 되었다면 이미지 목록에서 확인할 수 있습니다.</p>\n<pre><code class=\"language-sh\">docker build -t node-http-server:latest .\n\ndocker images\n</code></pre>\n<p>빌드된 이미지를 컨테이너로 실행해봅니다.</p>\n<pre><code class=\"language-sh\">docker run -itd -p 8080:8080 --name node-http-server node-http-server:latest\n</code></pre>\n<p>위 명령어로 빌드된 어플리케이션 이미지가 <code>8080</code>포트로 개방된 컨테이너로 실행됩니다.</p>\n<pre><code class=\"language-sh\">curl localhost:8080\n\ncurl localhost:8080/hello-world\n</code></pre>\n<p><code>Dockerfile</code>로 작성된 어플리케이션 이미지는 잘 동작되는 것을 확인했으니, 이제 Github Actions를 사용하여 이미지가 자동으로 빌드되는 방법을 알아보겠습니다.</p>\n<h2 id=\"3-github-tokenpat-생성-및-등록\">3. Github Token(PAT) 생성 및 등록</h2>\n<p>docker 이미지를 빌드한 후 저장할 이미지 저장소가 필요합니다. <code>dockerhub</code>, <code>aws ecr</code>, <code>ghcr</code> 등이 있습니다. 이번 글에서는 Github Container Registry인 <code>ghcr</code>에 빌드된 이미지를 저장하겠습니다.</p>\n<p><code>ghcr</code>에 접근하기 위해서는 Github 계정의 <code>Personal Access Token</code>이 필요합니다. Github Actions 또는 다른 자동화 스크립트에서 Github에 접근할 수 있도록 인증을 위한 토큰입니다.</p>\n<p>Github에서 <code>Settings</code> &gt; <code>Developer Settings</code> &gt; <code>Personal Access Token</code> 메뉴로 진입하여, <code>Generate new token</code>을 선택합니다.</p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/generate-new-token.png\" alt=\"generate new token\"></p>\n<p>적당한 토큰에 대한 내용을 입력하고 <code>write:packages</code>, <code>read:packages</code>, <code>delete:packages</code> 권한을 선택한 후 토큰을 생성합니다. 생성된 토큰은 복사하여 따로 저장해둡니다.</p>\n<p>이제 Github Actions가 실행될 저장소에 토큰을 등록하겠습니다. <code>Repository&#39;s settings</code> &gt; <code>Secrets</code> &gt; <code>Actions</code> 메뉴로 진입하여 <code>New repository secret</code>을 선택합니다.</p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/add-repository-secret.png\" alt=\"add repository secret\"></p>\n<h2 id=\"4-github-workflows-작성\">4. Github workflows 작성</h2>\n<p>이제 Github Actions를 사용하여 이미지를 빌드하기 위해 저장소에 workflow를 작성합니다. <code>.github/workflows/build-image.yml</code> 파일을 생성하고 다음을 작성합니다. 빌드와 이미지 태깅에 대한 부분 모두 marketplace에서 불러와 사용합니다.</p>\n<pre><code class=\"language-yml\">name: build-image\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  build-and-push-image:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Log in to the Container registry\n        uses: docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.BUILD_IMAGE_FOR_GHCR }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@98669ae865ea3cffbcbaa878cf57c20bbf1c6c38\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n          tags: |\n            type=sha\n          flavor: |\n            latest=true\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n</code></pre>\n<p>각 부분을 간단하게만 짚어 보겠습니다.</p>\n<pre><code class=\"language-yml\">env:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n</code></pre>\n<p>workflow 내에서 사용할 환경변수를 선언합니다. 빌드된 이미지의 이름을 현재 저장소 이름으로 지정합니다.</p>\n<pre><code class=\"language-yml\">permissions:\n  contents: read\n  packages: write\n</code></pre>\n<p>저장소의 컨텐츠에 대한 권한과 패키지에 대한 권한을 지정합니다.(<a href=\"https://docs.github.com/en/actions/using-jobs/assigning-permissions-to-jobs\">자세히</a>)</p>\n<pre><code class=\"language-yml\">- name: Log in to the Container registry\n  uses: docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9\n  with:\n    registry: ${{ env.REGISTRY }}\n    username: ${{ github.actor }}\n    password: ${{ secrets.BUILD_IMAGE_FOR_GHCR }}\n</code></pre>\n<p>Github Container Registry에 접근할 수 있도록 인증 절차를 진행합니다. 저장소에 등록해둔 PAT를 불러와 로그인합니다.</p>\n<pre><code class=\"language-yml\">- name: Build and push Docker image\n  uses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\n  with:\n    context: .\n    push: true\n    tags: ${{ steps.meta.outputs.tags }}\n    labels: ${{ steps.meta.outputs.labels }}\n</code></pre>\n<p>이미지를 빌드하고 로그인된 저장소에 푸시합니다. 이 때, 이미지 태그를 지정해줄 수 있습니다. 여기서는 앞선 step에서 저장소 이름을 사용하도록 지정했습니다.</p>\n<p>이제 작성된 workflow 파일을 저장하고 커밋한 뒤 <code>git push</code> 명령으로 코드를 푸시합니다. workflow가 푸시되면 Github Actions가 동작합니다. Github 저장소에서 <code>Actions</code> 탭을 확인해보겠습니다.</p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/github-actions.png\" alt=\"github actions\"></p>\n<p>정상적으로 workflow가 성공한다면 해당 저장소의 <code>packages</code>에서 빌드된 이미지를 확인할 수 있습니다.</p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/github-repository-home-for-new-package.png\" alt=\"github new package\"></p>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/github-packages.png\" alt=\"github packages\"></p>\n<h2 id=\"5-빌드된-이미지-pull-받아-컨테이너로-실행하기\">5. 빌드된 이미지 Pull 받아 컨테이너로 실행하기</h2>\n<p><code>ghcr</code>에 올라간 이미지를 수동으로 내려 받아 컨테이너로 실행하여 제대로 빌드된 것인지 확인해보겠습니다. ghcr에 접근하기 위해 앞 단계에서 생성했던 PAT가 필요합니다.</p>\n<p>로컬에서 docker 이미지 저장소를 <code>ghcr.io</code>로 로그인합니다. <code>$PAT</code>에는 PAT를 입력하고, <code>$USERNAME</code>에는 github username을 입력합니다.</p>\n<pre><code class=\"language-sh\">echo &quot;$PAT&quot; | docker login ghcr.io -u $USERNAME --password-stdin\n</code></pre>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/login-to-ghcr.png\" alt=\"login to ghcr\"></p>\n<p>이제 빌드된 이미지를 Pull하여 내려 받습니다.</p>\n<pre><code class=\"language-sh\">docker pull ghcr.io/hoontae24/node-http-server\n</code></pre>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/docker-pull.png\" alt=\"docker pull image\"></p>\n<p>이제 앞 단계와 같이 컨테이너를 실행해봅니다.</p>\n<pre><code class=\"language-sh\">docker run -itd -p 8080:8080 --name node-http-server ghcr.io/hoontae24/node-http-server:latest\n</code></pre>\n<p><img src=\"/cicd/build-docker-image-using-github-actions/img/docker-run-conatiner.png\" alt=\"docker run container\"></p>\n<p><code>ghcr</code>로부터 내려받은 이미지가 컨테이너로 잘 동작하는 것을 확인할 수 있습니다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>오늘은 Github Actions를 이용하여 Docker 이미지를 빌드하고 Github Container Registry에 올리는 작업을 진행해봤습니다. 배포 프로세스를 자동화하는 과정 중 일부를 Github Actions를 이용하면 어렵지 않게 진행할 수 있을 것으로 보입니다.</p>\n<p>이번에는 편의를 위해 <code>ghcr.io</code>에 작업을 하였는데, 자주 사용하는 <code>dockerhub</code>나 <code>aws ecr</code>에도 적용해보면 좋을 것 같습니다. 또한 이미지 빌드뿐만 아니라 운영 서비스를 업데이트 하는 배포 과정에도 Github Actions를 사용해보면 좋을 것 같습니다.</p>\n<blockquote>\n<p>도움을 받은 자료</p>\n<ul>\n<li><a href=\"https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry\">https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry</a></li>\n</ul>\n</blockquote>\n","excerpt":"Github Actions를 이용하여 어플리케이션을 Docker 이미지로 빌드하고 ghcr.io 저장소에 푸시하는 과정을 알아봅니다. 소프트웨어 제품이나 서비스의 운영에 있어 배포는 적지 않게 중요합니다. 특히 운영 규모가 커지거나 많은 사람이 협업하는 경우에는 더욱 강조될 것입니다. 그렇기에 배포 프로세스를 자동화하면 생산성을 높이고, 휴먼 에러를 줄일 수 있습니다. 요즘은 서비스 운영 환경이 컨테이너 기반으로 이루어진 경우도 많이 있습니다. 만약 kubernetes를 사용한다면 필수적","thumbnail":"/cicd/build-docker-image-using-github-actions/img/github-actions-icon.png","thumbnailUrl":"https://hoontae24.github.io/cicd/build-docker-image-using-github-actions/img/github-actions-icon.png"},{"href":"24","round":24,"paths":["vscode","first-contributing-for-vscode-extensions"],"slug":"first-contributing-for-vscode-extensions","title":"VSCode Extensions에 PR 제출하기(feat. vscode-github-pull-request)","description":"This is interesting features for development","date":"2022-04-16","category":"vscode","tags":["vscode","opensource"],"seriesId":null,"markdown":"\n![VSCode](/vscode/first-contributing-for-vscode-extensions/img/vscode.png)\n\n코드 작업을 하며 사용하는 vscode extensions 중에 [GitHub Pull Requests and Issues](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github)가 있습니다. 실제 개발보다는 협업에 가까운 도구입니다. Github과 연동하여 PR이나 이슈를 vscode에서 확인할 수 있는 확장앱입니다. 최근에 vscode로 회사 업무를 하면서 불편한 것이 생겨 이 확장앱을 직접 수정하고 기여한 내용을 공유해 보겠습니다.\n\n## 문제 인식\n\n![vscode-palette-permalink.png](/vscode/first-contributing-for-vscode-extensions/img/vscode-palette-permalink.png)\n\n확장앱에서 제공하는 기능 중에 `Copy Github Permalink`라는 것이 있습니다. 이것은 `Github Permalink`를 vscode 내에서 접근하여 복사해주는 기능입니다. ([Permalink](https://github.com/github/docs/blob/main/contributing/permalinks.md)는 github에 게시된 소스 코드의 특정 라인(또는 리소스)에 매핑된 URL 주소입니다.) 팀원들과 협업하면서 프로젝트의 특정 소스 코드를 지칭할 때, Permalink를 통해 공유할 수 있습니다.\n\n하지만 `Github Pull Requests and Issues` 확장앱에서 복사된 Permalink의 도메인은 `github.com`으로 고정되어 있었습니다. 현재 사내에 Github Enterprise Server를 따로 구축하여 사용하는 환경이기 때문에 사내 도메인으로 복사가 되어야 하는데, 그 부분이 지원되지 않고 있었습니다.\n\n```text\n# 유효한 사내 Github permalink\nhttps://github.myenterpriseserver.com/company-user/company-project/blob/ref/src/app.js#L10\n\n# 실제 복사된 permalink\nhttps://github.com/company-user/company-project/blob/ref/src/app.js#L10\n```\n\n그런데 해당 확장앱은 Github Enterprise Server를 지원하고 있습니다. 아래 사진과 같이 환경설정에서 `github-enterprise.uri` 정보를 입력하면 사내 Github Enterprise 서버에서 PR 및 이슈 등의 정보를 가져올 수 있습니다.\n\n![vscode-preferences-github-enterprise-uri.png](/vscode/first-contributing-for-vscode-extensions/img/vscode-preferences-github-enterprise-uri.png)\n\n그래서 Permalink에 대해 Enterprise Server의 도메인이 적용되지 않는 것이 버그이거나 자연스럽지 않은 동작으로 느껴졌습니다. 그래서 직접 확장앱의 코드를 수정하고 기여할 수 있는지 확인해 보았습니다.\n\n## 확장앱 정책 살펴보기\n\n해당 확장앱이 제3자인 제가 수정하여 기여할 수 있는 정책으로 되어있는지 확인해 보겠습니다. 일반 어플리케이션과 다르게 확장앱의 경우에는 오픈소스로 운영되는 경우가 있기 때문에 직접 기여할 수 있을 것입니다. 다행히 해당 확장앱의 [Github Repo](https://github.com/Microsoft/vscode-pull-request-github)에서 [Contributing](https://github.com/Microsoft/vscode-pull-request-github) 관련 내용을 확인할 수 있었습니다. 아마 MS에서 개발하고 있기 때문에 문서가 잘 정리된 것으로 보입니다.\n\n![Contributing](/vscode/first-contributing-for-vscode-extensions/img/github-pull-requests-and-issues-contributing.png)\n\n확장앱을 수정하기 위해서 개발 모드로 작업을 진행할 수 있게 가이드를 제공하고 있습니다. 확장앱의 모든 환경을 다 이해하진 못해도 해당 가이드를 따라 기능을 수정해보겠습니다.\n\n## 디버깅 및 기능 수정하기\n\n![Build and Run](/vscode/first-contributing-for-vscode-extensions/img/github-pull-requests-and-issues-contribute-guide-build-and-run.png)\n\n로컬 환경에 소스코드를 clone하여 내려받고 의존성 패키지를 설치합니다. 그리고 `yarn watch` 명령어를 실행하여 개발 환경에서 실행할 수 있게 되어 있습니다. 또는 `yarn bundle`이나 `yarn compile` 명령어를 통해 빌드할 수 있습니다. 저는 `yarn watch`를 통해 확장앱을 빌드하겠습니다.\n\n확장앱이 준비되면 vscode 디버깅 기능을 실행합니다. `F5`키를 누르거나 command palette에서 `Debug: Start Debugging`을 실행합니다. 디버깅 모드가 실행되면 `[Extensions Development Host]`라는 Prefix가 붙은 vscode 새 창이 실행됩니다.\n\n![Extensions Development Host](/vscode/first-contributing-for-vscode-extensions/img/vscode-extensions-host.png)\n\n이 vscode 환경에서는 제가 작업하는 확장앱의 수정이 반영된 버전을 다룰 수 있습니다. 기존 확장앱의 vscode에서 원하는 기능이 동작하도록 코드를 수정하고 빌드합니다. 그리고 디버깅 모드로 실행하여 제가 수정한 기능이 제대로 동작하는지 디버깅할 수 있습니다.\n\n## 프로젝트 메인 저장소에 PR로 기여하기\n\n원하는 기능이 동작하도록 확장앱의 소스코드를 수정하고 커밋까지 완료합니다. 그리고 원본이 되는 저장소에 PR을 요청합니다. PR 가이드를 살펴보면 사전에 특별히 해야할 작업은 없는 것 같습니다. 적당히 제목과 내용을 작성한 다음 PR을 생성합니다. (실제 생성된 [PR](https://github.com/microsoft/vscode-pull-request-github/pull/3460))\n\n![PR](/vscode/first-contributing-for-vscode-extensions/img/create-pr.png)\n\n해당 확장앱은 Microsoft의 CLA(Contributor License Agreement)에 동의하여야 기여할 수 있습니다. 가이드의 내용처럼 PR을 생성하면 [microsoft-cla bot](https://github.com/apps/microsoft-cla)이 CLA 동의를 위한 절차를 안내해줍니다. 라이선스 관련 내용을 확인하고 Github 계정을 이용하여 인증한 뒤 동의를 진행합니다.\n\nCLA 동의 작업이 끝나면 Maintainer의 리뷰가 진행되어야 PR이 머지될 수 있습니다. 제 경우에는 PR 생성일부터 3-4일 정도 후에 리뷰 및 머지가 되었습니다. 이렇게 저의 vscode 확장앱 기여를 끝냈습니다!\n\n![PR Comment](/vscode/first-contributing-for-vscode-extensions/img/pr-lgtm.png)\n\n## 마치며\n\n처음으로 vscode extensions를 개발하는 환경을 다루어 보았습니다. 사실 확장앱 개발 환경에 대해 제대로 살펴보진 않았지만 `Extensions Development Host`를 배운 것만으로도 새로운 경험이었습니다. 또한 확장앱에 필요한 기능을 수정하여 기여했던 것 또한 뿌듯한 경험이었습니다.\n\n이러한 경험은 개발에 대한 관점을 많이 넓혀줍니다. 개발자로서 참여할 수 있는 프로젝트의 환경 도메인이 하나 추가되었습니다. 필요한 아이디어를 잘 정리해서 vscode 확장앱을 하나 개발해보는 것도 재미있을 것 같습니다. 작은 경험이지만 vscode를 사용하는 개발자에게 도움이 되었기를 바랍니다.\n","html":"<p><img src=\"/vscode/first-contributing-for-vscode-extensions/img/vscode.png\" alt=\"VSCode\"></p>\n<p>코드 작업을 하며 사용하는 vscode extensions 중에 <a href=\"https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-pull-request-github\">GitHub Pull Requests and Issues</a>가 있습니다. 실제 개발보다는 협업에 가까운 도구입니다. Github과 연동하여 PR이나 이슈를 vscode에서 확인할 수 있는 확장앱입니다. 최근에 vscode로 회사 업무를 하면서 불편한 것이 생겨 이 확장앱을 직접 수정하고 기여한 내용을 공유해 보겠습니다.</p>\n<h2 id=\"문제-인식\">문제 인식</h2>\n<p><img src=\"/vscode/first-contributing-for-vscode-extensions/img/vscode-palette-permalink.png\" alt=\"vscode-palette-permalink.png\"></p>\n<p>확장앱에서 제공하는 기능 중에 <code>Copy Github Permalink</code>라는 것이 있습니다. 이것은 <code>Github Permalink</code>를 vscode 내에서 접근하여 복사해주는 기능입니다. (<a href=\"https://github.com/github/docs/blob/main/contributing/permalinks.md\">Permalink</a>는 github에 게시된 소스 코드의 특정 라인(또는 리소스)에 매핑된 URL 주소입니다.) 팀원들과 협업하면서 프로젝트의 특정 소스 코드를 지칭할 때, Permalink를 통해 공유할 수 있습니다.</p>\n<p>하지만 <code>Github Pull Requests and Issues</code> 확장앱에서 복사된 Permalink의 도메인은 <code>github.com</code>으로 고정되어 있었습니다. 현재 사내에 Github Enterprise Server를 따로 구축하여 사용하는 환경이기 때문에 사내 도메인으로 복사가 되어야 하는데, 그 부분이 지원되지 않고 있었습니다.</p>\n<pre><code class=\"language-text\"># 유효한 사내 Github permalink\nhttps://github.myenterpriseserver.com/company-user/company-project/blob/ref/src/app.js#L10\n\n# 실제 복사된 permalink\nhttps://github.com/company-user/company-project/blob/ref/src/app.js#L10\n</code></pre>\n<p>그런데 해당 확장앱은 Github Enterprise Server를 지원하고 있습니다. 아래 사진과 같이 환경설정에서 <code>github-enterprise.uri</code> 정보를 입력하면 사내 Github Enterprise 서버에서 PR 및 이슈 등의 정보를 가져올 수 있습니다.</p>\n<p><img src=\"/vscode/first-contributing-for-vscode-extensions/img/vscode-preferences-github-enterprise-uri.png\" alt=\"vscode-preferences-github-enterprise-uri.png\"></p>\n<p>그래서 Permalink에 대해 Enterprise Server의 도메인이 적용되지 않는 것이 버그이거나 자연스럽지 않은 동작으로 느껴졌습니다. 그래서 직접 확장앱의 코드를 수정하고 기여할 수 있는지 확인해 보았습니다.</p>\n<h2 id=\"확장앱-정책-살펴보기\">확장앱 정책 살펴보기</h2>\n<p>해당 확장앱이 제3자인 제가 수정하여 기여할 수 있는 정책으로 되어있는지 확인해 보겠습니다. 일반 어플리케이션과 다르게 확장앱의 경우에는 오픈소스로 운영되는 경우가 있기 때문에 직접 기여할 수 있을 것입니다. 다행히 해당 확장앱의 <a href=\"https://github.com/Microsoft/vscode-pull-request-github\">Github Repo</a>에서 <a href=\"https://github.com/Microsoft/vscode-pull-request-github\">Contributing</a> 관련 내용을 확인할 수 있었습니다. 아마 MS에서 개발하고 있기 때문에 문서가 잘 정리된 것으로 보입니다.</p>\n<p><img src=\"/vscode/first-contributing-for-vscode-extensions/img/github-pull-requests-and-issues-contributing.png\" alt=\"Contributing\"></p>\n<p>확장앱을 수정하기 위해서 개발 모드로 작업을 진행할 수 있게 가이드를 제공하고 있습니다. 확장앱의 모든 환경을 다 이해하진 못해도 해당 가이드를 따라 기능을 수정해보겠습니다.</p>\n<h2 id=\"디버깅-및-기능-수정하기\">디버깅 및 기능 수정하기</h2>\n<p><img src=\"/vscode/first-contributing-for-vscode-extensions/img/github-pull-requests-and-issues-contribute-guide-build-and-run.png\" alt=\"Build and Run\"></p>\n<p>로컬 환경에 소스코드를 clone하여 내려받고 의존성 패키지를 설치합니다. 그리고 <code>yarn watch</code> 명령어를 실행하여 개발 환경에서 실행할 수 있게 되어 있습니다. 또는 <code>yarn bundle</code>이나 <code>yarn compile</code> 명령어를 통해 빌드할 수 있습니다. 저는 <code>yarn watch</code>를 통해 확장앱을 빌드하겠습니다.</p>\n<p>확장앱이 준비되면 vscode 디버깅 기능을 실행합니다. <code>F5</code>키를 누르거나 command palette에서 <code>Debug: Start Debugging</code>을 실행합니다. 디버깅 모드가 실행되면 <code>[Extensions Development Host]</code>라는 Prefix가 붙은 vscode 새 창이 실행됩니다.</p>\n<p><img src=\"/vscode/first-contributing-for-vscode-extensions/img/vscode-extensions-host.png\" alt=\"Extensions Development Host\"></p>\n<p>이 vscode 환경에서는 제가 작업하는 확장앱의 수정이 반영된 버전을 다룰 수 있습니다. 기존 확장앱의 vscode에서 원하는 기능이 동작하도록 코드를 수정하고 빌드합니다. 그리고 디버깅 모드로 실행하여 제가 수정한 기능이 제대로 동작하는지 디버깅할 수 있습니다.</p>\n<h2 id=\"프로젝트-메인-저장소에-pr로-기여하기\">프로젝트 메인 저장소에 PR로 기여하기</h2>\n<p>원하는 기능이 동작하도록 확장앱의 소스코드를 수정하고 커밋까지 완료합니다. 그리고 원본이 되는 저장소에 PR을 요청합니다. PR 가이드를 살펴보면 사전에 특별히 해야할 작업은 없는 것 같습니다. 적당히 제목과 내용을 작성한 다음 PR을 생성합니다. (실제 생성된 <a href=\"https://github.com/microsoft/vscode-pull-request-github/pull/3460\">PR</a>)</p>\n<p><img src=\"/vscode/first-contributing-for-vscode-extensions/img/create-pr.png\" alt=\"PR\"></p>\n<p>해당 확장앱은 Microsoft의 CLA(Contributor License Agreement)에 동의하여야 기여할 수 있습니다. 가이드의 내용처럼 PR을 생성하면 <a href=\"https://github.com/apps/microsoft-cla\">microsoft-cla bot</a>이 CLA 동의를 위한 절차를 안내해줍니다. 라이선스 관련 내용을 확인하고 Github 계정을 이용하여 인증한 뒤 동의를 진행합니다.</p>\n<p>CLA 동의 작업이 끝나면 Maintainer의 리뷰가 진행되어야 PR이 머지될 수 있습니다. 제 경우에는 PR 생성일부터 3-4일 정도 후에 리뷰 및 머지가 되었습니다. 이렇게 저의 vscode 확장앱 기여를 끝냈습니다!</p>\n<p><img src=\"/vscode/first-contributing-for-vscode-extensions/img/pr-lgtm.png\" alt=\"PR Comment\"></p>\n<h2 id=\"마치며\">마치며</h2>\n<p>처음으로 vscode extensions를 개발하는 환경을 다루어 보았습니다. 사실 확장앱 개발 환경에 대해 제대로 살펴보진 않았지만 <code>Extensions Development Host</code>를 배운 것만으로도 새로운 경험이었습니다. 또한 확장앱에 필요한 기능을 수정하여 기여했던 것 또한 뿌듯한 경험이었습니다.</p>\n<p>이러한 경험은 개발에 대한 관점을 많이 넓혀줍니다. 개발자로서 참여할 수 있는 프로젝트의 환경 도메인이 하나 추가되었습니다. 필요한 아이디어를 잘 정리해서 vscode 확장앱을 하나 개발해보는 것도 재미있을 것 같습니다. 작은 경험이지만 vscode를 사용하는 개발자에게 도움이 되었기를 바랍니다.</p>\n","excerpt":"This is interesting features for development 코드 작업을 하며 사용하는 vscode extensions 중에 GitHub Pull Requests and Issues가 있습니다. 실제 개발보다는 협업에 가까운 도구입니다. Github과 연동하여 PR이나 이슈를 vscode에서 확인할 수 있는 확장앱입니다. 최근에 vscode로 회사 업무를 하면서 불편한 것이 생겨 이 확장앱을 직접 수정하고 기여한 내","thumbnail":"/vscode/first-contributing-for-vscode-extensions/img/vscode.png","thumbnailUrl":"https://hoontae24.github.io/vscode/first-contributing-for-vscode-extensions/img/vscode.png"},{"href":"23","round":23,"paths":["react","hooks-for-state-update-on-consumed"],"slug":"hooks-for-state-update-on-consumed","title":"소비되는 상태의 변경에 대해서만 컴포넌트를 업데이트 하는 Hook","description":"","date":"2022-01-21","category":"react","tags":["react","hooks"],"seriesId":null,"markdown":"\n![React](/react/hooks-for-state-update-on-consumed/img/React.jpeg)\n\nuseState를 이용한 상태 관리 코드는 직관적이고, 재사용 가능하며, 관리하기 쉽습니다. 특정 기능별로 커스텀훅을 작성하면 일반적인 함수를 작성하는 것처럼 코드를 목적에 따라 분리할 수 있습니다. 하지만 하나의 커스텀훅을 사용하는 모든 컴포넌트가 같은 목적을 가진 것은 아닙니다. 만약 어떤 기능을 위해 커스텀훅을 호출했지만, 그중 필요하지 않은 상태를 컴포넌트가 추적한다면 이는 비효율적입니다.\n\n> 이 글은 [SWR - Dependency Collection](https://swr.vercel.app/docs/advanced/performance#dependency-collection)에서 영감을 받아 작성하였습니다.\n\n## 1. 여러 상태를 가진 커스텀훅\n\n먼저 코드를 보며 문제를 알아보겠습니다. 아래의 커스텀훅은 API로부터 데이터를 가져와 상태로 저장하는 커스텀훅입니다. 데이터를 저장하기 위한 `post`와 비동기 작업이 진행 중임을 나타내는 `loading` 2개의 상태를 제공합니다.\n\n```ts\nexport interface Post {\n  id: number;\n  userId: number;\n  title: string;\n  body: string;\n}\n\nexport interface Store<T> {\n  loading: boolean;\n  data: T | undefined;\n}\n\nexport const usePost = (postId: number): Store<Post> => {\n  const [loading, setLoading] = useState(false);\n  const [post, setPost] = useState<Post | undefined>(undefined);\n\n  useEffect(() => {\n    setLoading(true);\n    getPost(postId).then((post) => {\n      setPost(post);\n      setLoading(false);\n    });\n  }, [postId]);\n\n  console.log({ loading, data: post });\n  return { loading, data: post };\n};\n```\n\n`usePost` 훅을 사용하는 `App`컴포넌트를 아래와 같이 작성합니다.\n\n```tsx\nfunction App() {\n  const { loading, data: post } = usePost(1);\n\n  return (\n    <div className=\"App\">\n      {!loading && post ? (\n        <>\n          <h1>{post.title}</h1>\n          <p>{post.body}</p>\n        </>\n      ) : (\n        <>loading</>\n      )}\n    </div>\n  );\n}\n```\n\n컴포넌트가 렌더링될 때, `usePost`가 호출되면서 콘솔에는 다음과 같이 출력될 것입니다.\n\n```js\n{loading: false, data: undefined} // 1. 최초 컴포넌트 렌더링\n{loading: true, data: undefined} // 2. Mount 후 API 호출 직전 loading의 변경으로 인한 리렌더링\n{loading: true, data: {…}} // 3. API 호출 후 post의 변경으로 인한 리렌더링\n{loading: false, data: {…}} // 4. API 호출 후 loading의 변경으로 인한 리렌더링\n```\n\n`loading`과 `post` 두 개의 각각의 상태가 변경될 때 마다 컴포넌트는 리렌더링됩니다.\n\n> 일반적으로 여러 `useState`의 상태 변경 액션은 배치로 실행되지만, 비동기 로직 이후에는 적용되지 않습니다.([참조](https://stackoverflow.com/questions/53574614/multiple-calls-to-state-updater-from-usestate-in-component-causes-multiple-re-re?rq=1))\n\n## 2. 필요하지 않은 상태에 대한 추적\n\n이번에는 `usePost`를 호출하는 다른 컴포넌트를 작성해보겠습니다. `App2`컴포넌트는 `App`컴포넌트와는 달리 `post` 상태만 사용합니다.\n\n```tsx\nfunction App2() {\n  const { data: post } = usePost(1);\n\n  return (\n    <div className=\"App\">\n      {post && (\n        <>\n          <h1>{post.title}</h1>\n          <p>{post.body}</p>\n        </>\n      }\n    </div>\n  );\n}\n```\n\n`App2`컴포넌트가 렌더링될 때, 콘솔에는 다음과 같이 출력됩니다.\n\n```js\n{loading: false, data: undefined}\n{loading: true, data: undefined}\n{loading: true, data: {…}}\n{loading: false, data: {…}}\n```\n\n`App2`컴포넌트는 `loading` 상태를 사용하지 않아도, 여전히 커스텀훅 내에서 선언된 모든 상태의 변경을 추적합니다. `usePost`훅을 수정하여 조금 더 효율적으로 만들어 봅시다.\n\n```ts\nexport const usePost = (postId: number): Store<Post> => {\n  const [state, setState] = useState<Store<Post>>({\n    loading: false,\n    data: undefined,\n  });\n\n  useEffect(() => {\n    setState((p) => ({ ...p, loading: true }));\n    getPost(postId).then((post) => setState({ loading: false, data: post }));\n  }, [postId]);\n\n  console.log(state);\n  return state;\n};\n```\n\n`loading`과 `post`를 하나의 상태로 관리하도록 코드를 수정했습니다. 이제 두 상태를 동시에 변경할 때, 한번의 리렌더링만 발생합니다. 콘솔의 출력을 봅시다.\n\n```js\n{loading: false, data: undefined} // 1. 최초 컴포넌트 렌더링\n{loading: true, data: undefined} // 2. Mount 후 API 호출 직전 loading의 변경으로 인한 리렌더링\n{loading: false, data: {…}} // 3. API 호출 후 post와 loading의 변경으로 인한 리렌더링\n```\n\n컴포넌트의 리렌더링 횟수는 줄었지만, 여전히 사용하지 않는 상태인 `loading`에 대해 추적하는 것이 못마땅합니다. 이 비효율을 해결하기 위해서는 `post`를 관리하는 로직과 `loading`을 관리하는 로직을 분리하여 각각의 커스텀훅으로 만들어 사용해야 합니다. 하지만 그것 또한 상태의 개수가 늘어나거나 로직이 복잡해지면 각각의 상태를 조합하는 것이 쉽지 않을 것입니다.\n\n## 3. 사용하는 상태만 추적하는 Hook (본론)\n\nSWR을 사용하며 위와 같은 상황에서도 리렌더링이 되지 않는 것을 보고, SWR 코드[[1](https://github.com/vercel/swr/blob/7dfd89081d818cba940b7d6bc786e9cdcba24c8e/src/use-swr.ts#L516), [2](https://github.com/vercel/swr/blob/7dfd89081d818cba940b7d6bc786e9cdcba24c8e/src/utils/state.ts#L12)]를 살펴보다가 아래와 같은 커스텀훅을 발견하였습니다.\n\n```ts\nconst useStateWithDeps = <Data, Error, S = State<Data, Error>>(\n  state: S,\n  unmountedRef: MutableRefObject<boolean>\n): [MutableRefObject<S>, Record<StateKeys, boolean>, (payload: S) => void] => {\n  const rerender = useState<Record<string, unknown>>({})[1];\n  const stateRef = useRef(state);\n\n  const stateDependenciesRef = useRef<StateDeps>({\n    data: false,\n    error: false,\n    isValidating: false,\n  });\n\n  const setState = useCallback((payload: S) => {\n    let shouldRerender = false;\n\n    const currentState = stateRef.current;\n    for (const _ in payload) {\n      const k = _ as keyof S & StateKeys;\n\n      if (currentState[k] !== payload[k]) {\n        currentState[k] = payload[k];\n\n        if (stateDependenciesRef.current[k]) {\n          shouldRerender = true;\n        }\n      }\n    }\n\n    if (shouldRerender && !unmountedRef.current) {\n      rerender({});\n    }\n  }, []);\n\n  // Always update the state reference.\n  useIsomorphicLayoutEffect(() => {\n    stateRef.current = state;\n  });\n\n  return [stateRef, stateDependenciesRef.current, setState];\n};\n```\n\n```ts\nexport const useSWRHandler = <Data = any, Error = any>(\n  _key: Key,\n  fetcher: Fetcher<Data> | null,\n  config: typeof defaultConfig & SWRConfiguration<Data, Error>\n) => {\n  const [stateRef, stateDependencies, setState] = useStateWithDeps<Data, Error>(\n    {\n      data,\n      error,\n      isValidating,\n    },\n    unmountedRef\n  );\n\n  return {\n    get data() {\n      stateDependencies.data = true;\n      return data;\n    },\n    get error() {\n      stateDependencies.error = true;\n      return error;\n    },\n    get isValidating() {\n      stateDependencies.isValidating = true;\n      return isValidating;\n    },\n  } as SWRResponse<Data, Error>;\n};\n```\n\n실제 코드에서 오늘의 핵심 주제인 컴포넌트 업데이트 관점에서 코드를 살펴봅시다. 먼저 실제 사용자 컴포넌트에서 사용하는 커스텀훅(`useSWRHandler`)은 `data`, `error`, `isValidating`이라는 3개의 상태를 제공합니다.\n\n```ts\nconst rerender = useState<Record<string, unknown>>({})[1];\n```\n\n`renderer`함수는 `useState`를 활용한 상태 업데이트용 함수입니다. 호출부에서 용도를 설명하겠습니다.\n\n```ts\nconst stateRef = useRef(state);\n```\n\n`stateRef`는 실제 상태로 사용할 데이터가 저장되는 객체입니다. `ref`객체를 이용하여 데이터가 변경되더라도 컴포넌트는 업데이트되지 않도록 합니다.\n\n```ts\nconst stateDependenciesRef = useRef<StateDeps>({\n  data: false,\n  error: false,\n  isValidating: false,\n});\n```\n\n`stateDependenciesRef`는 각 상태가 사용되었는지를 저장하는 값입니다. 사용하지 않는 상태를 추적할 필요가 없도록 어떤 상태를 사용하는지 이 객체에 저장해둡니다.\n\n```ts\nconst setState = useCallback((payload: S) => {\n  // ...\n  if (stateDependenciesRef.current[k]) {\n    shouldRerender = true;\n  }\n  // ...\n  if (shouldRerender && !unmountedRef.current) {\n    rerender({});\n  }\n}, []);\n```\n\n상태를 업데이트하는 함수인 `setState`입니다. `payload`로 전달되는 값을 상태에 덮어쓰는 로직이 있습니다. 여기서 중요한 부분이 나옵니다. `stateDependenciesRef`에서 각 key에 대한 상태를 사용하는지 체크합니다. 이후 사용하는 상태에 대한 변경이 있을 때만 컴포넌트를 업데이트하도록 `renderer({})`구문을 실행합니다.\n\n```ts\nreturn {\n  get data() {\n    stateDependencies.data = true;\n    return data;\n  },\n  get error() {\n    stateDependencies.error = true;\n    return error;\n  },\n  get isValidating() {\n    stateDependencies.isValidating = true;\n    return isValidating;\n  },\n} as SWRResponse<Data, Error>;\n```\n\n그리고 훅의 마지막 부분에서 각각의 상태를 [Getter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)로 제공합니다. 만약 `data`라는 상태 값을 읽는다면 `stateDependencies.data = true`구문이 실행되어 해당 상태가 사용되고 있는 지 체크해둡니다.\n\n정리하면, 1) 사용하는 상태를 따로 체크해두고 2) 체크된 상태가 변경될 때만 컴포넌트를 업데이트하는 방식으로 이루어져 있습니다. `useSWR`을 사용할 때, 훅의 리턴값을 사용하지 않으면, 데이터가 로드되더라도 컴포넌트가 업데이트되지 않는 것을 볼 수 있습니다.\n\n## 마치며\n\n오늘은 이렇게 SWR 코드를 살펴보다가 흥미로운 부분이 있어 장황하게 글을 작성해봤습니다. 무엇보다도 Getter를 이용하여 **상태의 사용을 체크**하는 것이 인상적이었습니다. 다른 방법으로는 [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)를 이용하면 비슷한 기능을 구현할 수 있을 것 같기도 합니다.\n\n리액트 사용자가 많아진 만큼 다양한 코드 패턴이 생겨납니다. 많은 개발자들과 조직들이 코드를 공개하는 오픈소스 패키지 덕분에 좋은 패턴과 코드에 대한 고민을 엿볼 수 있는 것 같습니다. 참 감사한 일입니다. 혹시 내용에 대한 오류나 오늘 문제에 대한 더 좋은 방법이 있다면 댓글로 알려주시면 감사하겠습니다.\n","html":"<p><img src=\"/react/hooks-for-state-update-on-consumed/img/React.jpeg\" alt=\"React\"></p>\n<p>useState를 이용한 상태 관리 코드는 직관적이고, 재사용 가능하며, 관리하기 쉽습니다. 특정 기능별로 커스텀훅을 작성하면 일반적인 함수를 작성하는 것처럼 코드를 목적에 따라 분리할 수 있습니다. 하지만 하나의 커스텀훅을 사용하는 모든 컴포넌트가 같은 목적을 가진 것은 아닙니다. 만약 어떤 기능을 위해 커스텀훅을 호출했지만, 그중 필요하지 않은 상태를 컴포넌트가 추적한다면 이는 비효율적입니다.</p>\n<blockquote>\n<p>이 글은 <a href=\"https://swr.vercel.app/docs/advanced/performance#dependency-collection\">SWR - Dependency Collection</a>에서 영감을 받아 작성하였습니다.</p>\n</blockquote>\n<h2 id=\"1-여러-상태를-가진-커스텀훅\">1. 여러 상태를 가진 커스텀훅</h2>\n<p>먼저 코드를 보며 문제를 알아보겠습니다. 아래의 커스텀훅은 API로부터 데이터를 가져와 상태로 저장하는 커스텀훅입니다. 데이터를 저장하기 위한 <code>post</code>와 비동기 작업이 진행 중임을 나타내는 <code>loading</code> 2개의 상태를 제공합니다.</p>\n<pre><code class=\"language-ts\">export interface Post {\n  id: number;\n  userId: number;\n  title: string;\n  body: string;\n}\n\nexport interface Store&lt;T&gt; {\n  loading: boolean;\n  data: T | undefined;\n}\n\nexport const usePost = (postId: number): Store&lt;Post&gt; =&gt; {\n  const [loading, setLoading] = useState(false);\n  const [post, setPost] = useState&lt;Post | undefined&gt;(undefined);\n\n  useEffect(() =&gt; {\n    setLoading(true);\n    getPost(postId).then((post) =&gt; {\n      setPost(post);\n      setLoading(false);\n    });\n  }, [postId]);\n\n  console.log({ loading, data: post });\n  return { loading, data: post };\n};\n</code></pre>\n<p><code>usePost</code> 훅을 사용하는 <code>App</code>컴포넌트를 아래와 같이 작성합니다.</p>\n<pre><code class=\"language-tsx\">function App() {\n  const { loading, data: post } = usePost(1);\n\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      {!loading &amp;&amp; post ? (\n        &lt;&gt;\n          &lt;h1&gt;{post.title}&lt;/h1&gt;\n          &lt;p&gt;{post.body}&lt;/p&gt;\n        &lt;/&gt;\n      ) : (\n        &lt;&gt;loading&lt;/&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>컴포넌트가 렌더링될 때, <code>usePost</code>가 호출되면서 콘솔에는 다음과 같이 출력될 것입니다.</p>\n<pre><code class=\"language-js\">{loading: false, data: undefined} // 1. 최초 컴포넌트 렌더링\n{loading: true, data: undefined} // 2. Mount 후 API 호출 직전 loading의 변경으로 인한 리렌더링\n{loading: true, data: {…}} // 3. API 호출 후 post의 변경으로 인한 리렌더링\n{loading: false, data: {…}} // 4. API 호출 후 loading의 변경으로 인한 리렌더링\n</code></pre>\n<p><code>loading</code>과 <code>post</code> 두 개의 각각의 상태가 변경될 때 마다 컴포넌트는 리렌더링됩니다.</p>\n<blockquote>\n<p>일반적으로 여러 <code>useState</code>의 상태 변경 액션은 배치로 실행되지만, 비동기 로직 이후에는 적용되지 않습니다.(<a href=\"https://stackoverflow.com/questions/53574614/multiple-calls-to-state-updater-from-usestate-in-component-causes-multiple-re-re?rq=1\">참조</a>)</p>\n</blockquote>\n<h2 id=\"2-필요하지-않은-상태에-대한-추적\">2. 필요하지 않은 상태에 대한 추적</h2>\n<p>이번에는 <code>usePost</code>를 호출하는 다른 컴포넌트를 작성해보겠습니다. <code>App2</code>컴포넌트는 <code>App</code>컴포넌트와는 달리 <code>post</code> 상태만 사용합니다.</p>\n<pre><code class=\"language-tsx\">function App2() {\n  const { data: post } = usePost(1);\n\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      {post &amp;&amp; (\n        &lt;&gt;\n          &lt;h1&gt;{post.title}&lt;/h1&gt;\n          &lt;p&gt;{post.body}&lt;/p&gt;\n        &lt;/&gt;\n      }\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p><code>App2</code>컴포넌트가 렌더링될 때, 콘솔에는 다음과 같이 출력됩니다.</p>\n<pre><code class=\"language-js\">{loading: false, data: undefined}\n{loading: true, data: undefined}\n{loading: true, data: {…}}\n{loading: false, data: {…}}\n</code></pre>\n<p><code>App2</code>컴포넌트는 <code>loading</code> 상태를 사용하지 않아도, 여전히 커스텀훅 내에서 선언된 모든 상태의 변경을 추적합니다. <code>usePost</code>훅을 수정하여 조금 더 효율적으로 만들어 봅시다.</p>\n<pre><code class=\"language-ts\">export const usePost = (postId: number): Store&lt;Post&gt; =&gt; {\n  const [state, setState] = useState&lt;Store&lt;Post&gt;&gt;({\n    loading: false,\n    data: undefined,\n  });\n\n  useEffect(() =&gt; {\n    setState((p) =&gt; ({ ...p, loading: true }));\n    getPost(postId).then((post) =&gt; setState({ loading: false, data: post }));\n  }, [postId]);\n\n  console.log(state);\n  return state;\n};\n</code></pre>\n<p><code>loading</code>과 <code>post</code>를 하나의 상태로 관리하도록 코드를 수정했습니다. 이제 두 상태를 동시에 변경할 때, 한번의 리렌더링만 발생합니다. 콘솔의 출력을 봅시다.</p>\n<pre><code class=\"language-js\">{loading: false, data: undefined} // 1. 최초 컴포넌트 렌더링\n{loading: true, data: undefined} // 2. Mount 후 API 호출 직전 loading의 변경으로 인한 리렌더링\n{loading: false, data: {…}} // 3. API 호출 후 post와 loading의 변경으로 인한 리렌더링\n</code></pre>\n<p>컴포넌트의 리렌더링 횟수는 줄었지만, 여전히 사용하지 않는 상태인 <code>loading</code>에 대해 추적하는 것이 못마땅합니다. 이 비효율을 해결하기 위해서는 <code>post</code>를 관리하는 로직과 <code>loading</code>을 관리하는 로직을 분리하여 각각의 커스텀훅으로 만들어 사용해야 합니다. 하지만 그것 또한 상태의 개수가 늘어나거나 로직이 복잡해지면 각각의 상태를 조합하는 것이 쉽지 않을 것입니다.</p>\n<h2 id=\"3-사용하는-상태만-추적하는-hook-본론\">3. 사용하는 상태만 추적하는 Hook (본론)</h2>\n<p>SWR을 사용하며 위와 같은 상황에서도 리렌더링이 되지 않는 것을 보고, SWR 코드[<a href=\"https://github.com/vercel/swr/blob/7dfd89081d818cba940b7d6bc786e9cdcba24c8e/src/use-swr.ts#L516\">1</a>, <a href=\"https://github.com/vercel/swr/blob/7dfd89081d818cba940b7d6bc786e9cdcba24c8e/src/utils/state.ts#L12\">2</a>]를 살펴보다가 아래와 같은 커스텀훅을 발견하였습니다.</p>\n<pre><code class=\"language-ts\">const useStateWithDeps = &lt;Data, Error, S = State&lt;Data, Error&gt;&gt;(\n  state: S,\n  unmountedRef: MutableRefObject&lt;boolean&gt;\n): [MutableRefObject&lt;S&gt;, Record&lt;StateKeys, boolean&gt;, (payload: S) =&gt; void] =&gt; {\n  const rerender = useState&lt;Record&lt;string, unknown&gt;&gt;({})[1];\n  const stateRef = useRef(state);\n\n  const stateDependenciesRef = useRef&lt;StateDeps&gt;({\n    data: false,\n    error: false,\n    isValidating: false,\n  });\n\n  const setState = useCallback((payload: S) =&gt; {\n    let shouldRerender = false;\n\n    const currentState = stateRef.current;\n    for (const _ in payload) {\n      const k = _ as keyof S &amp; StateKeys;\n\n      if (currentState[k] !== payload[k]) {\n        currentState[k] = payload[k];\n\n        if (stateDependenciesRef.current[k]) {\n          shouldRerender = true;\n        }\n      }\n    }\n\n    if (shouldRerender &amp;&amp; !unmountedRef.current) {\n      rerender({});\n    }\n  }, []);\n\n  // Always update the state reference.\n  useIsomorphicLayoutEffect(() =&gt; {\n    stateRef.current = state;\n  });\n\n  return [stateRef, stateDependenciesRef.current, setState];\n};\n</code></pre>\n<pre><code class=\"language-ts\">export const useSWRHandler = &lt;Data = any, Error = any&gt;(\n  _key: Key,\n  fetcher: Fetcher&lt;Data&gt; | null,\n  config: typeof defaultConfig &amp; SWRConfiguration&lt;Data, Error&gt;\n) =&gt; {\n  const [stateRef, stateDependencies, setState] = useStateWithDeps&lt;Data, Error&gt;(\n    {\n      data,\n      error,\n      isValidating,\n    },\n    unmountedRef\n  );\n\n  return {\n    get data() {\n      stateDependencies.data = true;\n      return data;\n    },\n    get error() {\n      stateDependencies.error = true;\n      return error;\n    },\n    get isValidating() {\n      stateDependencies.isValidating = true;\n      return isValidating;\n    },\n  } as SWRResponse&lt;Data, Error&gt;;\n};\n</code></pre>\n<p>실제 코드에서 오늘의 핵심 주제인 컴포넌트 업데이트 관점에서 코드를 살펴봅시다. 먼저 실제 사용자 컴포넌트에서 사용하는 커스텀훅(<code>useSWRHandler</code>)은 <code>data</code>, <code>error</code>, <code>isValidating</code>이라는 3개의 상태를 제공합니다.</p>\n<pre><code class=\"language-ts\">const rerender = useState&lt;Record&lt;string, unknown&gt;&gt;({})[1];\n</code></pre>\n<p><code>renderer</code>함수는 <code>useState</code>를 활용한 상태 업데이트용 함수입니다. 호출부에서 용도를 설명하겠습니다.</p>\n<pre><code class=\"language-ts\">const stateRef = useRef(state);\n</code></pre>\n<p><code>stateRef</code>는 실제 상태로 사용할 데이터가 저장되는 객체입니다. <code>ref</code>객체를 이용하여 데이터가 변경되더라도 컴포넌트는 업데이트되지 않도록 합니다.</p>\n<pre><code class=\"language-ts\">const stateDependenciesRef = useRef&lt;StateDeps&gt;({\n  data: false,\n  error: false,\n  isValidating: false,\n});\n</code></pre>\n<p><code>stateDependenciesRef</code>는 각 상태가 사용되었는지를 저장하는 값입니다. 사용하지 않는 상태를 추적할 필요가 없도록 어떤 상태를 사용하는지 이 객체에 저장해둡니다.</p>\n<pre><code class=\"language-ts\">const setState = useCallback((payload: S) =&gt; {\n  // ...\n  if (stateDependenciesRef.current[k]) {\n    shouldRerender = true;\n  }\n  // ...\n  if (shouldRerender &amp;&amp; !unmountedRef.current) {\n    rerender({});\n  }\n}, []);\n</code></pre>\n<p>상태를 업데이트하는 함수인 <code>setState</code>입니다. <code>payload</code>로 전달되는 값을 상태에 덮어쓰는 로직이 있습니다. 여기서 중요한 부분이 나옵니다. <code>stateDependenciesRef</code>에서 각 key에 대한 상태를 사용하는지 체크합니다. 이후 사용하는 상태에 대한 변경이 있을 때만 컴포넌트를 업데이트하도록 <code>renderer({})</code>구문을 실행합니다.</p>\n<pre><code class=\"language-ts\">return {\n  get data() {\n    stateDependencies.data = true;\n    return data;\n  },\n  get error() {\n    stateDependencies.error = true;\n    return error;\n  },\n  get isValidating() {\n    stateDependencies.isValidating = true;\n    return isValidating;\n  },\n} as SWRResponse&lt;Data, Error&gt;;\n</code></pre>\n<p>그리고 훅의 마지막 부분에서 각각의 상태를 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\">Getter</a>로 제공합니다. 만약 <code>data</code>라는 상태 값을 읽는다면 <code>stateDependencies.data = true</code>구문이 실행되어 해당 상태가 사용되고 있는 지 체크해둡니다.</p>\n<p>정리하면, 1) 사용하는 상태를 따로 체크해두고 2) 체크된 상태가 변경될 때만 컴포넌트를 업데이트하는 방식으로 이루어져 있습니다. <code>useSWR</code>을 사용할 때, 훅의 리턴값을 사용하지 않으면, 데이터가 로드되더라도 컴포넌트가 업데이트되지 않는 것을 볼 수 있습니다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>오늘은 이렇게 SWR 코드를 살펴보다가 흥미로운 부분이 있어 장황하게 글을 작성해봤습니다. 무엇보다도 Getter를 이용하여 <strong>상태의 사용을 체크</strong>하는 것이 인상적이었습니다. 다른 방법으로는 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>를 이용하면 비슷한 기능을 구현할 수 있을 것 같기도 합니다.</p>\n<p>리액트 사용자가 많아진 만큼 다양한 코드 패턴이 생겨납니다. 많은 개발자들과 조직들이 코드를 공개하는 오픈소스 패키지 덕분에 좋은 패턴과 코드에 대한 고민을 엿볼 수 있는 것 같습니다. 참 감사한 일입니다. 혹시 내용에 대한 오류나 오늘 문제에 대한 더 좋은 방법이 있다면 댓글로 알려주시면 감사하겠습니다.</p>\n","excerpt":" useState를 이용한 상태 관리 코드는 직관적이고, 재사용 가능하며, 관리하기 쉽습니다. 특정 기능별로 커스텀훅을 작성하면 일반적인 함수를 작성하는 것처럼 코드를 목적에 따라 분리할 수 있습니다. 하지만 하나의 커스텀훅을 사용하는 모든 컴포넌트가 같은 목적을 가진 것은 아닙니다. 만약 어떤 기능을 위해 커스텀훅을 호출했지만, 그중 필요하지 않은 상태를 ","thumbnail":"/react/hooks-for-state-update-on-consumed/img/React.jpeg","thumbnailUrl":"https://hoontae24.github.io/react/hooks-for-state-update-on-consumed/img/React.jpeg"},{"href":"22","round":22,"paths":["svelte","how-does-svelte-change-dom"],"slug":"how-does-svelte-change-dom","title":"Svelte가 DOM을 조작하는 과정 알아보기","description":"","date":"2022-01-15","category":"svelte","tags":["javascript","svelte"],"seriesId":null,"markdown":"\n![Svelte](/svelte/how-does-svelte-change-dom/img/svelte_2.png)\n\nReact, Vue와 같은 라이브러리를 통해 Virtual DOM의 개념은 많이 알려져 있습니다. 개발자는 DOM을 직접 조작하지 않고 선언적으로 \"상태\"라고 부르는 데이터만 관리합니다. DOM을 업데이트하는 것은 React와 같은 라이브러리가 Virtual DOM을 사용해 알아서 합니다.\n\n> Instead of using techniques like virtual DOM diffing, Svelte writes code that surgically updates the DOM when the state of your app changes.\n\n컴포넌트 기반 웹 프레임워크 중 하나인 Svelte의 메인 페이지에서는 위와 같이 소개합니다. Svelte는 상태가 변경될 때 직접 DOM을 수정하는 코드를 작성해줍니다. 그것이 Svelte를 Compiler라고 소개하는 이유입니다. Svelte는 브라우저에서 실행되는 것이 아닌 앱을 빌드할 때 실행됩니다.\n\n이번 글에서는 Svelte를 이용하여 빌드된 자바스크립트 코드를 분석하며, 우리가 작성한 Svelte 컴포넌트가 어떻게 DOM을 수정하는 코드로 컴파일되는지 알아보겠습니다.\n\n## 실습 프로젝트 준비\n\n[Svelte 공식 문서](https://svelte.dev)에 소개하는 Quickstart template를 설치합니다.\n\n```shell\nnpx degit sveltejs/template hello-svelte\ncd hello-svelte\nnpm install\n```\n\n프로젝트가 준비되었다면 `src/App.svelte`파일의 내용을 모두 지우고, 간단한 카운터 기능의 컴포넌트를 작성합니다.\n\n```svelte\n<script>\n  let count = 0;\n\n  const increase = () => {\n    count++;\n  };\n</script>\n\n<div>\n  <h1>Counter</h1>\n  <span>count: {count}</span>\n  <br />\n  <button on:click={increase}>increase</button>\n</div>\n```\n\n```shell\nnpm run dev\n```\n\n앱을 실행하여 카운터가 잘 동작하는지 확인해봅니다. 잘 동작한다면 빌드된 코드를 minify하는 옵션을 끄고 코드를 빌드해보겠습니다. `rollup.config.js`에서 `plugins` 속성에서 `terser()` 설정을 주석처리 하겠습니다.\n\n```js\n// rollup.config.js:71\n// If we're building for production (npm run build\n// instead of npm run dev), minify\nproduction && terser(); // <-- 주석처리\n```\n\n```shell\nnpm run build\n```\n\n빌드 후 `public/build/bundle.js` 파일을 확인해봅니다. 난독화 되지 않은 코드가 보인다면 이제 준비는 끝났습니다.\n\n## Svelte가 DOM을 생성하는 과정\n\n> 이 섹션의 제목은 \"Svelte가 컴파일한 코드가 DOM을 생성하는 과정\"이 더 적합하겠지만, 너무 길지 않게 했습니다.\n\n이제부터는 단순하게 `bundle.js`파일을 보면서 어떻게 DOM을 업데이트하는 지 코드를 읽어보겠습니다. 코드의 진입점은 `bundle.js` 파일의 마지막에 위치한 `new App()`부분입니다. 우리가 작성한 `App.svelte` 컴포넌트는 `App` 클래스로 변환됩니다.\n\n> `bundle.js:351`과 같은 표시로 파일의 추적을 돕기 위해 라인수를 표시합니다. 설정과 버전에 따라 차이가 있을 수 있습니다. 또한 코드에서 다루지 않을 부분을 중략한다는 의미로 `// ...`로 표시하겠습니다.\n\n```js\n// bundle.js:351\nclass App extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {});\n    // ...\n  }\n}\n```\n\n`App`클래스는 생성자 함수로 초기화할 때, `init`함수를 호출합니다. `init`함수의 파라미터로 넘겨지는 것 중 우리가 집중해서 볼 것은 `this`, `instance`, `create_fragment`입니다. 일단 세 변수를 눈으로 기억하고 `init`함수를 찾아봅시다.\n\n```js\n// bundle.js:186\nfunction init(\n  component,\n  options,\n  instance,\n  create_fragment /** ... 그 외 인자들 */\n) {\n  // ...\n  const $$ = (component.$$ = {\n    fragment: null,\n    ctx: null,\n    // ...\n  });\n}\n```\n\n`init`함수는 컴포넌트가 생성될 때, 모든 자원을 초기화합니다. 컴포넌트의 state, props, lifecycles 등이 등록됩니다. 여기서 우리가 관심을 가질 부분은 `$$` 객체와 `$$.fragment`, `$$.ctx`입니다. 이 `$$` 객체는 `component.$$`에 저장되고, `component`객체는 우리가 작성한 `App.svelte` 컴포넌트의 인스턴스입니다.\n\n조금 아래에서 `$$.ctx`에 할당되는 `instance`에 대한 구문을 찾을 수 있습니다.\n\n```js\n// bundle.js:212\n$$.ctx = instance\n  ? instance(component, options.props || {}, (i, ret, ...rest) => {\n      const value = rest.length ? rest[0] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    })\n  : [];\n```\n\n`instance`함수는 `init`의 3번째 인자로 전달받았습니다. `instance`함수를 호출할 때 1번째 매개변수로 `component` 객체를, 3번째 매개변수로 `(i, ret, ...rest) => {}`와 같은 콜백함수를 넘겨준다는 것을 눈으로 기억해주세요. 이제 `instance`함수를 찾아봅시다.\n\n`instance`는 `init`의 인자로 선언되었으니 `init`을 호출했던 `App`컴포넌트의 `constructor` 부분에서 넘겨준 매개변수 `instance`를 추적합니다.\n\n```js\n// bundle.js:351\nclass App extends SvelteComponentDev {\n  constructor(options) {\n    super(options);\n    // 3번째 매개변수인 `instance` 변수를 추적\n    init(this, options, instance, create_fragment, safe_not_equal, {});\n    // ...\n  }\n}\n```\n\n```js\n// bundle.js:334\nfunction instance($$self, $$props, $$invalidate) {\n  let count = 0;\n\n  const increase = () => {\n    $$invalidate(0, count++, count);\n  };\n\n  return [count, increase];\n}\n```\n\n여기서는 `instance`함수의 리턴 값인 `[count, increase]`가 `$$.ctx`에 할당된다는 것을 알 수 있습니다. 또한 카운터의 상태를 변경하는 `increase`가 호출되면 `$$invalidate`함수가 호출됩니다. `$$invalidate`함수가 궁금하지만 조금 후에 알아보겠습니다.\n\n이제 다시 `212`라인의 `init`함수로 돌아와 계속 따라가 보겠습니다. `228`라인의 `$$.fragment`를 찾아 살펴봅시다.\n\n```js\n// bundle.js:228\n$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n```\n\n`create_fragment`함수는 `init`함수의 인자로 전달 받았습니다. 다시 `App`클래스의 `constructor`에서 넘겨준 `create_fragment`변수를 추적해보겠습니다.\n\n```js\n// bundle.js:351\nclass App extends SvelteComponentDev {\n  constructor(options) {\n    super(options);\n    // 4번째 매개변수인 `create_fragment` 변수를 추적\n    init(this, options, instance, create_fragment, safe_not_equal, {});\n    // ...\n  }\n}\n```\n\n```js\n// bundle.js:275\n// `ctx`는 `$$.ctx`를 전달 받으므로 `[count, increase]`의 값이 할당되어 있을 것입니다.\nfunction create_fragment(ctx) {\n  // ...\n  return {\n    c() {\n      div = element(\"div\");\n      h1 = element(\"h1\");\n      h1.textContent = \"Counter\";\n      t1 = space();\n      span = element(\"span\");\n      t2 = text(\"count: \");\n      t3 = text(/*count*/ ctx[0]);\n      t4 = space();\n      br = element(\"br\");\n      t5 = space();\n      button = element(\"button\");\n      button.textContent = \"increase\";\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, h1);\n      append(div, t1);\n      append(div, span);\n      append(span, t2);\n      append(span, t3);\n      append(div, t4);\n      append(div, br);\n      append(div, t5);\n      append(div, button);\n\n      if (!mounted) {\n        dispose = listen(button, \"click\", /*increase*/ ctx[1]);\n        mounted = true;\n      }\n    },\n    // ...\n  };\n}\n```\n\n`create_fragment`함수는 현재 컴포넌트의 상태 컨텍스트인 `$$.ctx`를 인자로 전달받아 객체를 반환합니다. 반환되는 객체에서 `c() {}`메소드와 `m() {}`메소드를 살펴봅시다.\n\n`c() {}`메소드는 컴포넌트에서 작성된 요소를 HTML Element로 생성하는 부분입니다. `t3`변수에 `ctx[0]`인 `count`를 렌더링하는 `text`요소를 생성합니다.\n\n`m() {}`메소드는 생성된 Element를 DOM 트리에 추가하는 부분입니다. 그리고 `317`라인에서 `button`요소의 클릭 이벤트에 `ctx[1]`인 `increase`함수를 리스너로 지정합니다. 브라우저에서 `button`요소를 클릭하면 `increase`함수가 실행되도록 연결한 것입니다.\n\n`create_fragment`의 역할을 어느 정도 이해했으니 호출되었던 `228`라인의 `init`함수로 돌아갑니다. 이후 로직을 따라가면 `$$.fragment.c()`부분과 `mount_component(component, ...)`부분을 만나게 됩니다.\n\n```js\n// bundle.js:238\n$$.fragment && $$.fragment.c();\n\n// bundle.js:242\nmount_component(component /* ... */);\n\n// bundle.js:147\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment /* ... */ } = component.$$;\n  fragment && fragment.m(target, anchor);\n}\n```\n\n`init`함수를 분석해보니 **컴포넌트에서 정의한 요소를 생성**하고 **DOM 트리에 추가**하는 로직이 담겨있는 것을 알 수 있습니다. 또한 컴포넌트의 상태와 동작인 `count`, `increase`를 `$$.ctx`에 담아 관리하는 것을 알 수 있습니다. 여기까지 우리가 작성한 컴포넌트를 어떻게 DOM을 생성하는 코드로 변경했는 지 살펴보았습니다. 이제 이 글에서 핵심인 `count`가 변경될 때, DOM이 업데이트되는 과정을 살펴봅시다.\n\n## Svelte가 DOM을 변경하는 과정\n\n위 내용에서 살펴본 바, 우리는 `button`요소의 클릭 이벤트에 `$$.ctx[1]`인 `increase`를 리스너로 지정했다는 것을 알고 있습니다. 이번 과정은 거기에서부터 시작하겠습니다.\n\n`$$.ctx`에 할당된 객체가 생성되었던 `instance`함수로 갑시다.\n\n```js\n// bundle.js:334\nfunction instance($$self, $$props, $$invalidate) {\n  let count = 0;\n\n  const increase = () => {\n    $$invalidate(0, count++, count);\n  };\n\n  return [count, increase];\n}\n```\n\n`button`을 클릭하면 `increase`함수를 실행하고, 이어서 `$$invalidate`함수를 실행합니다. 카운터 값이 증가한 `count++`값을 전달합니다. `$$invalidate`함수는 인자로 넘어왔기 때문에 `instance`함수의 호출 부분인 `init`함수로 갑니다.\n\n```js\n// bundle.js:212\n$$.ctx = instance\n  ? instance(component, options.props || {}, (i, ret, ...rest) => {\n      const value = rest.length ? rest[0] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    })\n  : [];\n```\n\n이전에 `$$.ctx`를 살펴볼 때 봤던 코드입니다. 이번에 주의 깊게 볼 부분은 `instance`함수의 3번째 파라미터인 콜백함수입니다.\n\n`not_equal($$.ctx[i], ($$.ctx[i] = value))`부분에서 `i`의 값은 `$$invalidate`를 호출할 때 넘겨준 `0`입니다. 따라서 `$$.ctx[i]`는 `count`값을 나타냅니다. 그리고 비교값인 `value`는 `$$invalidate`를 호출할 때 넘겨준 증가된 값인 `count++`입니다. `button`을 클릭할 때, `count`의 값과 `count++`값을 비교하여 이후 로직을 수행합니다.\n\n이후 로직에서 살펴볼 부분은 바로 `make_dirty(component, i)`함수 입니다. 따라가봅시다.\n\n```js\n// bundle.js:178\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  // ...\n}\n```\n\n`make_dirty`함수에서 해당 컴포넌트는 변경된 값이 있으므로 `dirty_components`에 추가하고, `schedule_update()`함수를 호출합니다.\n\n```js\n// bundle.js:65\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\n```\n\n`schedule_update`함수는 `update_scheduled`를 `true`로 지정하여 업데이트할 컴포넌트가 있다는 것을 표시합니다. 이후 `resolved_promise.then(flush)`에서 `flush`함수를 호출합니다. `flush`함수를 즉시 호출하지 않고 `resolved_promise`의 이행 후에 호출하는 이유는 다른 컴포넌트에서의 변경사항이 있다면 해당 로직들을 동기적으로 수행한 후에 모든 컴포넌트의 상태 변경 작업이 끝나면 한번에 업데이트하기 위한 것으로 보입니다. (_이 방법은 virtual DOM을 사용하는 라이브러리에서도 비슷하게 진행됩니다._)\n\n```js\n// bundle.js:94\nfunction flush() {\n  // ...\n  update(component.$$); // line: 103\n  // ...\n}\n```\n\n`flush`함수에서 `update(component.$$)`함수를 통해 각 컴포넌트가 업데이트되도록 합니다. `update`함수를 따라가봅시다.\n\n```js\n// bundle.js:130\nfunction update($$) {\n  if ($$.fragment !== null) {\n    // ...\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    // ...\n  }\n}\n```\n\n`update`함수에서 `$$.fragment.p($$.ctx, dirty)`를 호출합니다. `$$.fragment`를 생성했던 `create_fragment`함수의 반환 객체에서 `p() {}`메소드를 찾아봅시다.\n\n```js\n// bundle.js:289\nreturn {\n  // ...\n  // bundle.js:321\n  p(ctx, [dirty]) {\n    if (dirty & /*count*/ 1) set_data(t3, /*count*/ ctx[0]);\n  },\n  // ...\n};\n```\n\n`p() {}`메소드의 `set_data(t3, /*count*/ ctx[0])`를 살펴봅시다. `t3`는 컴포넌트에서 `count`가 렌더링되는 HTML Element입니다. `ctx[0]`은 클릭으로 인해 증가된 `count`값 입니다.\n\n```js\n// bundle.js:48\nfunction set_data(text, data) {\n  data = \"\" + data;\n  if (text.wholeText !== data) text.data = data;\n}\n```\n\n`set_data`함수에서는 전달받은 `count`를 렌더링하는 HTML Element인 `t3`의 텍스트 값을 직접 변경합니다. 마침내 `클릭` -> `컴포넌트 상태 변경` -> `컴포넌트 업데이트` -> `DOM 요소 직접 변경`의 과정을 끝냈습니다.\n\n## 마치며\n\n이번 글에서는 Svelte가 `count`라는 상태를 반영하기 위해 직접 DOM을 조작하는 과정에 대해 살펴봤습니다. Svelte가 컴파일한 `bundle.js`파일에는 많은 코드가 있었지만, 우리가 컴포넌트에 정의한 상태가 어떤 과정으로 변경되는 지에 집중하여 살펴봤습니다. 화면의 변경에는 상태로 인한 텍스트 변경뿐만 아니라, 컴포넌트의 조건부 렌더링이나, 주입된 Context의 변경, CSS의 변경 등의 다양한 변경 사항이 있기 때문에 해당 기능을 정의하는 컴포넌트를 작성하면 더욱 복잡한 과정이 될 것입니다.\n\n사실 단순히 화면을 그리기 위해 라이브러리가 어떻게 동작하는지 모두 알 필요는 없습니다. 하지만 개발을 하면서 렌더링 관련 문제를 만나거나 다른 라이브러리와의 비교를 할 때, 각각의 기술이 어떻게 동작하는지 알아야 할 시기가 있을 것입니다. 또한 개발자로서 Svelte와 같은 기술이 어떻게 동작하길래 필요한 것인지 궁금하기도 합니다. 이 글을 통해 \"No virtual DOM\"인 Svelte를 이해하는데에 도움이 되었기를 바랍니다.\n","html":"<p><img src=\"/svelte/how-does-svelte-change-dom/img/svelte_2.png\" alt=\"Svelte\"></p>\n<p>React, Vue와 같은 라이브러리를 통해 Virtual DOM의 개념은 많이 알려져 있습니다. 개발자는 DOM을 직접 조작하지 않고 선언적으로 &quot;상태&quot;라고 부르는 데이터만 관리합니다. DOM을 업데이트하는 것은 React와 같은 라이브러리가 Virtual DOM을 사용해 알아서 합니다.</p>\n<blockquote>\n<p>Instead of using techniques like virtual DOM diffing, Svelte writes code that surgically updates the DOM when the state of your app changes.</p>\n</blockquote>\n<p>컴포넌트 기반 웹 프레임워크 중 하나인 Svelte의 메인 페이지에서는 위와 같이 소개합니다. Svelte는 상태가 변경될 때 직접 DOM을 수정하는 코드를 작성해줍니다. 그것이 Svelte를 Compiler라고 소개하는 이유입니다. Svelte는 브라우저에서 실행되는 것이 아닌 앱을 빌드할 때 실행됩니다.</p>\n<p>이번 글에서는 Svelte를 이용하여 빌드된 자바스크립트 코드를 분석하며, 우리가 작성한 Svelte 컴포넌트가 어떻게 DOM을 수정하는 코드로 컴파일되는지 알아보겠습니다.</p>\n<h2 id=\"실습-프로젝트-준비\">실습 프로젝트 준비</h2>\n<p><a href=\"https://svelte.dev\">Svelte 공식 문서</a>에 소개하는 Quickstart template를 설치합니다.</p>\n<pre><code class=\"language-shell\">npx degit sveltejs/template hello-svelte\ncd hello-svelte\nnpm install\n</code></pre>\n<p>프로젝트가 준비되었다면 <code>src/App.svelte</code>파일의 내용을 모두 지우고, 간단한 카운터 기능의 컴포넌트를 작성합니다.</p>\n<pre><code class=\"language-svelte\">&lt;script&gt;\n  let count = 0;\n\n  const increase = () =&gt; {\n    count++;\n  };\n&lt;/script&gt;\n\n&lt;div&gt;\n  &lt;h1&gt;Counter&lt;/h1&gt;\n  &lt;span&gt;count: {count}&lt;/span&gt;\n  &lt;br /&gt;\n  &lt;button on:click={increase}&gt;increase&lt;/button&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"language-shell\">npm run dev\n</code></pre>\n<p>앱을 실행하여 카운터가 잘 동작하는지 확인해봅니다. 잘 동작한다면 빌드된 코드를 minify하는 옵션을 끄고 코드를 빌드해보겠습니다. <code>rollup.config.js</code>에서 <code>plugins</code> 속성에서 <code>terser()</code> 설정을 주석처리 하겠습니다.</p>\n<pre><code class=\"language-js\">// rollup.config.js:71\n// If we&#39;re building for production (npm run build\n// instead of npm run dev), minify\nproduction &amp;&amp; terser(); // &lt;-- 주석처리\n</code></pre>\n<pre><code class=\"language-shell\">npm run build\n</code></pre>\n<p>빌드 후 <code>public/build/bundle.js</code> 파일을 확인해봅니다. 난독화 되지 않은 코드가 보인다면 이제 준비는 끝났습니다.</p>\n<h2 id=\"svelte가-dom을-생성하는-과정\">Svelte가 DOM을 생성하는 과정</h2>\n<blockquote>\n<p>이 섹션의 제목은 &quot;Svelte가 컴파일한 코드가 DOM을 생성하는 과정&quot;이 더 적합하겠지만, 너무 길지 않게 했습니다.</p>\n</blockquote>\n<p>이제부터는 단순하게 <code>bundle.js</code>파일을 보면서 어떻게 DOM을 업데이트하는 지 코드를 읽어보겠습니다. 코드의 진입점은 <code>bundle.js</code> 파일의 마지막에 위치한 <code>new App()</code>부분입니다. 우리가 작성한 <code>App.svelte</code> 컴포넌트는 <code>App</code> 클래스로 변환됩니다.</p>\n<blockquote>\n<p><code>bundle.js:351</code>과 같은 표시로 파일의 추적을 돕기 위해 라인수를 표시합니다. 설정과 버전에 따라 차이가 있을 수 있습니다. 또한 코드에서 다루지 않을 부분을 중략한다는 의미로 <code>// ...</code>로 표시하겠습니다.</p>\n</blockquote>\n<pre><code class=\"language-js\">// bundle.js:351\nclass App extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {});\n    // ...\n  }\n}\n</code></pre>\n<p><code>App</code>클래스는 생성자 함수로 초기화할 때, <code>init</code>함수를 호출합니다. <code>init</code>함수의 파라미터로 넘겨지는 것 중 우리가 집중해서 볼 것은 <code>this</code>, <code>instance</code>, <code>create_fragment</code>입니다. 일단 세 변수를 눈으로 기억하고 <code>init</code>함수를 찾아봅시다.</p>\n<pre><code class=\"language-js\">// bundle.js:186\nfunction init(\n  component,\n  options,\n  instance,\n  create_fragment /** ... 그 외 인자들 */\n) {\n  // ...\n  const $$ = (component.$$ = {\n    fragment: null,\n    ctx: null,\n    // ...\n  });\n}\n</code></pre>\n<p><code>init</code>함수는 컴포넌트가 생성될 때, 모든 자원을 초기화합니다. 컴포넌트의 state, props, lifecycles 등이 등록됩니다. 여기서 우리가 관심을 가질 부분은 <code>$$</code> 객체와 <code>$$.fragment</code>, <code>$$.ctx</code>입니다. 이 <code>$$</code> 객체는 <code>component.$$</code>에 저장되고, <code>component</code>객체는 우리가 작성한 <code>App.svelte</code> 컴포넌트의 인스턴스입니다.</p>\n<p>조금 아래에서 <code>$$.ctx</code>에 할당되는 <code>instance</code>에 대한 구문을 찾을 수 있습니다.</p>\n<pre><code class=\"language-js\">// bundle.js:212\n$$.ctx = instance\n  ? instance(component, options.props || {}, (i, ret, ...rest) =&gt; {\n      const value = rest.length ? rest[0] : ret;\n      if ($$.ctx &amp;&amp; not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n        if (!$$.skip_bound &amp;&amp; $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    })\n  : [];\n</code></pre>\n<p><code>instance</code>함수는 <code>init</code>의 3번째 인자로 전달받았습니다. <code>instance</code>함수를 호출할 때 1번째 매개변수로 <code>component</code> 객체를, 3번째 매개변수로 <code>(i, ret, ...rest) =&gt; {}</code>와 같은 콜백함수를 넘겨준다는 것을 눈으로 기억해주세요. 이제 <code>instance</code>함수를 찾아봅시다.</p>\n<p><code>instance</code>는 <code>init</code>의 인자로 선언되었으니 <code>init</code>을 호출했던 <code>App</code>컴포넌트의 <code>constructor</code> 부분에서 넘겨준 매개변수 <code>instance</code>를 추적합니다.</p>\n<pre><code class=\"language-js\">// bundle.js:351\nclass App extends SvelteComponentDev {\n  constructor(options) {\n    super(options);\n    // 3번째 매개변수인 `instance` 변수를 추적\n    init(this, options, instance, create_fragment, safe_not_equal, {});\n    // ...\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">// bundle.js:334\nfunction instance($$self, $$props, $$invalidate) {\n  let count = 0;\n\n  const increase = () =&gt; {\n    $$invalidate(0, count++, count);\n  };\n\n  return [count, increase];\n}\n</code></pre>\n<p>여기서는 <code>instance</code>함수의 리턴 값인 <code>[count, increase]</code>가 <code>$$.ctx</code>에 할당된다는 것을 알 수 있습니다. 또한 카운터의 상태를 변경하는 <code>increase</code>가 호출되면 <code>$$invalidate</code>함수가 호출됩니다. <code>$$invalidate</code>함수가 궁금하지만 조금 후에 알아보겠습니다.</p>\n<p>이제 다시 <code>212</code>라인의 <code>init</code>함수로 돌아와 계속 따라가 보겠습니다. <code>228</code>라인의 <code>$$.fragment</code>를 찾아 살펴봅시다.</p>\n<pre><code class=\"language-js\">// bundle.js:228\n$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n</code></pre>\n<p><code>create_fragment</code>함수는 <code>init</code>함수의 인자로 전달 받았습니다. 다시 <code>App</code>클래스의 <code>constructor</code>에서 넘겨준 <code>create_fragment</code>변수를 추적해보겠습니다.</p>\n<pre><code class=\"language-js\">// bundle.js:351\nclass App extends SvelteComponentDev {\n  constructor(options) {\n    super(options);\n    // 4번째 매개변수인 `create_fragment` 변수를 추적\n    init(this, options, instance, create_fragment, safe_not_equal, {});\n    // ...\n  }\n}\n</code></pre>\n<pre><code class=\"language-js\">// bundle.js:275\n// `ctx`는 `$$.ctx`를 전달 받으므로 `[count, increase]`의 값이 할당되어 있을 것입니다.\nfunction create_fragment(ctx) {\n  // ...\n  return {\n    c() {\n      div = element(&quot;div&quot;);\n      h1 = element(&quot;h1&quot;);\n      h1.textContent = &quot;Counter&quot;;\n      t1 = space();\n      span = element(&quot;span&quot;);\n      t2 = text(&quot;count: &quot;);\n      t3 = text(/*count*/ ctx[0]);\n      t4 = space();\n      br = element(&quot;br&quot;);\n      t5 = space();\n      button = element(&quot;button&quot;);\n      button.textContent = &quot;increase&quot;;\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, h1);\n      append(div, t1);\n      append(div, span);\n      append(span, t2);\n      append(span, t3);\n      append(div, t4);\n      append(div, br);\n      append(div, t5);\n      append(div, button);\n\n      if (!mounted) {\n        dispose = listen(button, &quot;click&quot;, /*increase*/ ctx[1]);\n        mounted = true;\n      }\n    },\n    // ...\n  };\n}\n</code></pre>\n<p><code>create_fragment</code>함수는 현재 컴포넌트의 상태 컨텍스트인 <code>$$.ctx</code>를 인자로 전달받아 객체를 반환합니다. 반환되는 객체에서 <code>c() {}</code>메소드와 <code>m() {}</code>메소드를 살펴봅시다.</p>\n<p><code>c() {}</code>메소드는 컴포넌트에서 작성된 요소를 HTML Element로 생성하는 부분입니다. <code>t3</code>변수에 <code>ctx[0]</code>인 <code>count</code>를 렌더링하는 <code>text</code>요소를 생성합니다.</p>\n<p><code>m() {}</code>메소드는 생성된 Element를 DOM 트리에 추가하는 부분입니다. 그리고 <code>317</code>라인에서 <code>button</code>요소의 클릭 이벤트에 <code>ctx[1]</code>인 <code>increase</code>함수를 리스너로 지정합니다. 브라우저에서 <code>button</code>요소를 클릭하면 <code>increase</code>함수가 실행되도록 연결한 것입니다.</p>\n<p><code>create_fragment</code>의 역할을 어느 정도 이해했으니 호출되었던 <code>228</code>라인의 <code>init</code>함수로 돌아갑니다. 이후 로직을 따라가면 <code>$$.fragment.c()</code>부분과 <code>mount_component(component, ...)</code>부분을 만나게 됩니다.</p>\n<pre><code class=\"language-js\">// bundle.js:238\n$$.fragment &amp;&amp; $$.fragment.c();\n\n// bundle.js:242\nmount_component(component /* ... */);\n\n// bundle.js:147\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment /* ... */ } = component.$$;\n  fragment &amp;&amp; fragment.m(target, anchor);\n}\n</code></pre>\n<p><code>init</code>함수를 분석해보니 <strong>컴포넌트에서 정의한 요소를 생성</strong>하고 <strong>DOM 트리에 추가</strong>하는 로직이 담겨있는 것을 알 수 있습니다. 또한 컴포넌트의 상태와 동작인 <code>count</code>, <code>increase</code>를 <code>$$.ctx</code>에 담아 관리하는 것을 알 수 있습니다. 여기까지 우리가 작성한 컴포넌트를 어떻게 DOM을 생성하는 코드로 변경했는 지 살펴보았습니다. 이제 이 글에서 핵심인 <code>count</code>가 변경될 때, DOM이 업데이트되는 과정을 살펴봅시다.</p>\n<h2 id=\"svelte가-dom을-변경하는-과정\">Svelte가 DOM을 변경하는 과정</h2>\n<p>위 내용에서 살펴본 바, 우리는 <code>button</code>요소의 클릭 이벤트에 <code>$$.ctx[1]</code>인 <code>increase</code>를 리스너로 지정했다는 것을 알고 있습니다. 이번 과정은 거기에서부터 시작하겠습니다.</p>\n<p><code>$$.ctx</code>에 할당된 객체가 생성되었던 <code>instance</code>함수로 갑시다.</p>\n<pre><code class=\"language-js\">// bundle.js:334\nfunction instance($$self, $$props, $$invalidate) {\n  let count = 0;\n\n  const increase = () =&gt; {\n    $$invalidate(0, count++, count);\n  };\n\n  return [count, increase];\n}\n</code></pre>\n<p><code>button</code>을 클릭하면 <code>increase</code>함수를 실행하고, 이어서 <code>$$invalidate</code>함수를 실행합니다. 카운터 값이 증가한 <code>count++</code>값을 전달합니다. <code>$$invalidate</code>함수는 인자로 넘어왔기 때문에 <code>instance</code>함수의 호출 부분인 <code>init</code>함수로 갑니다.</p>\n<pre><code class=\"language-js\">// bundle.js:212\n$$.ctx = instance\n  ? instance(component, options.props || {}, (i, ret, ...rest) =&gt; {\n      const value = rest.length ? rest[0] : ret;\n      if ($$.ctx &amp;&amp; not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n        if (!$$.skip_bound &amp;&amp; $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    })\n  : [];\n</code></pre>\n<p>이전에 <code>$$.ctx</code>를 살펴볼 때 봤던 코드입니다. 이번에 주의 깊게 볼 부분은 <code>instance</code>함수의 3번째 파라미터인 콜백함수입니다.</p>\n<p><code>not_equal($$.ctx[i], ($$.ctx[i] = value))</code>부분에서 <code>i</code>의 값은 <code>$$invalidate</code>를 호출할 때 넘겨준 <code>0</code>입니다. 따라서 <code>$$.ctx[i]</code>는 <code>count</code>값을 나타냅니다. 그리고 비교값인 <code>value</code>는 <code>$$invalidate</code>를 호출할 때 넘겨준 증가된 값인 <code>count++</code>입니다. <code>button</code>을 클릭할 때, <code>count</code>의 값과 <code>count++</code>값을 비교하여 이후 로직을 수행합니다.</p>\n<p>이후 로직에서 살펴볼 부분은 바로 <code>make_dirty(component, i)</code>함수 입니다. 따라가봅시다.</p>\n<pre><code class=\"language-js\">// bundle.js:178\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  // ...\n}\n</code></pre>\n<p><code>make_dirty</code>함수에서 해당 컴포넌트는 변경된 값이 있으므로 <code>dirty_components</code>에 추가하고, <code>schedule_update()</code>함수를 호출합니다.</p>\n<pre><code class=\"language-js\">// bundle.js:65\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\n</code></pre>\n<p><code>schedule_update</code>함수는 <code>update_scheduled</code>를 <code>true</code>로 지정하여 업데이트할 컴포넌트가 있다는 것을 표시합니다. 이후 <code>resolved_promise.then(flush)</code>에서 <code>flush</code>함수를 호출합니다. <code>flush</code>함수를 즉시 호출하지 않고 <code>resolved_promise</code>의 이행 후에 호출하는 이유는 다른 컴포넌트에서의 변경사항이 있다면 해당 로직들을 동기적으로 수행한 후에 모든 컴포넌트의 상태 변경 작업이 끝나면 한번에 업데이트하기 위한 것으로 보입니다. (<em>이 방법은 virtual DOM을 사용하는 라이브러리에서도 비슷하게 진행됩니다.</em>)</p>\n<pre><code class=\"language-js\">// bundle.js:94\nfunction flush() {\n  // ...\n  update(component.$$); // line: 103\n  // ...\n}\n</code></pre>\n<p><code>flush</code>함수에서 <code>update(component.$$)</code>함수를 통해 각 컴포넌트가 업데이트되도록 합니다. <code>update</code>함수를 따라가봅시다.</p>\n<pre><code class=\"language-js\">// bundle.js:130\nfunction update($$) {\n  if ($$.fragment !== null) {\n    // ...\n    $$.fragment &amp;&amp; $$.fragment.p($$.ctx, dirty);\n    // ...\n  }\n}\n</code></pre>\n<p><code>update</code>함수에서 <code>$$.fragment.p($$.ctx, dirty)</code>를 호출합니다. <code>$$.fragment</code>를 생성했던 <code>create_fragment</code>함수의 반환 객체에서 <code>p() {}</code>메소드를 찾아봅시다.</p>\n<pre><code class=\"language-js\">// bundle.js:289\nreturn {\n  // ...\n  // bundle.js:321\n  p(ctx, [dirty]) {\n    if (dirty &amp; /*count*/ 1) set_data(t3, /*count*/ ctx[0]);\n  },\n  // ...\n};\n</code></pre>\n<p><code>p() {}</code>메소드의 <code>set_data(t3, /*count*/ ctx[0])</code>를 살펴봅시다. <code>t3</code>는 컴포넌트에서 <code>count</code>가 렌더링되는 HTML Element입니다. <code>ctx[0]</code>은 클릭으로 인해 증가된 <code>count</code>값 입니다.</p>\n<pre><code class=\"language-js\">// bundle.js:48\nfunction set_data(text, data) {\n  data = &quot;&quot; + data;\n  if (text.wholeText !== data) text.data = data;\n}\n</code></pre>\n<p><code>set_data</code>함수에서는 전달받은 <code>count</code>를 렌더링하는 HTML Element인 <code>t3</code>의 텍스트 값을 직접 변경합니다. 마침내 <code>클릭</code> -&gt; <code>컴포넌트 상태 변경</code> -&gt; <code>컴포넌트 업데이트</code> -&gt; <code>DOM 요소 직접 변경</code>의 과정을 끝냈습니다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>이번 글에서는 Svelte가 <code>count</code>라는 상태를 반영하기 위해 직접 DOM을 조작하는 과정에 대해 살펴봤습니다. Svelte가 컴파일한 <code>bundle.js</code>파일에는 많은 코드가 있었지만, 우리가 컴포넌트에 정의한 상태가 어떤 과정으로 변경되는 지에 집중하여 살펴봤습니다. 화면의 변경에는 상태로 인한 텍스트 변경뿐만 아니라, 컴포넌트의 조건부 렌더링이나, 주입된 Context의 변경, CSS의 변경 등의 다양한 변경 사항이 있기 때문에 해당 기능을 정의하는 컴포넌트를 작성하면 더욱 복잡한 과정이 될 것입니다.</p>\n<p>사실 단순히 화면을 그리기 위해 라이브러리가 어떻게 동작하는지 모두 알 필요는 없습니다. 하지만 개발을 하면서 렌더링 관련 문제를 만나거나 다른 라이브러리와의 비교를 할 때, 각각의 기술이 어떻게 동작하는지 알아야 할 시기가 있을 것입니다. 또한 개발자로서 Svelte와 같은 기술이 어떻게 동작하길래 필요한 것인지 궁금하기도 합니다. 이 글을 통해 &quot;No virtual DOM&quot;인 Svelte를 이해하는데에 도움이 되었기를 바랍니다.</p>\n","excerpt":" React, Vue와 같은 라이브러리를 통해 Virtual DOM의 개념은 많이 알려져 있습니다. 개발자는 DOM을 직접 조작하지 않고 선언적으로 &quot;상태&quot;라고 부르는 데이터만 관리합니다. DOM을 업데이트하는 것은 React와 같은 라이브러리가 Virtual DOM을 사용해 알아서 합니다.  Instead of using technique","thumbnail":"/svelte/how-does-svelte-change-dom/img/svelte_2.png","thumbnailUrl":"https://hoontae24.github.io/svelte/how-does-svelte-change-dom/img/svelte_2.png"},{"href":"21","round":21,"paths":["javascript","typed-array"],"slug":"typed-array","title":"Array는 아니지만 더 배열 같은... ArrayBuffer와 TypedArray","description":"","date":"2021-11-13","category":"javascript","tags":["javascript","arraybuffer","typedarray"],"seriesId":null,"markdown":"\n![arraybuffer-typedarray](/javascript/typed-array/img/arraybuffer-typedarray.png)\n\n프로그래밍에 있어 빠질 수 없는 자료구조 중 하나는 바로 \"배열\"일 것입니다. 자바스크립트에는 \"Array\"라는 전역 객체로 배열을 사용할 수 있습니다. (_\"Array\"를 번역하면 \"배열\"이지만_) 실제로 자바스크립트의 Array는 일반적으로 컴퓨터과학에서 다루는 \"[배열](https://ko.wikipedia.org/wiki/배열)\"과는 다릅니다. JS Array는 기본적으로 객체 타입이며, 연속적인 데이터 저장을 보장하지 않습니다.\n\nJIT 컴파일러를 사용하는 V8과 같은 엔진에서는 개선된 부분이 있지만, 연속성과 고정 타입을 늘 강제할 수는 없습니다. 만약 파일이나 이미지 등의 바이너리 데이터를 다룬다면 연속적인 메모리에 저장된 데이터 구조를 사용하는 것이 성능에 도움이 될 수 있습니다. 그러한 문제를 위해 ArrayBuffer와 TypedArray를 사용할 수 있습니다.\n\n## ArrayBuffer\n\n> \"버퍼(buffer)\"는 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역이다.\n\n**ArrayBuffer**의 의미적인 이해를 돕기 위해 **Buffer**의 뜻을 검색해봤습니다. Buffer와 Array가 결합된 ArrayBuffer는 \"연속적인 데이터를 보관하는 메모리의 영역\"정도로 이해할 수 있습니다. MDN에서는 \"바이트로 구성된 배열\"이라고 표현하고 있습니다.\n\n하지만 ArrayBuffer는\b 데이터를 직접 다루는 기능을 제공하지 않습니다. TypedArray나 DataView 등의 객체를 이용하여 ArrayBuffer에 할당된 공간을 특정 타입의 데이터로 읽거나 쓸 수 있습니다. (_마치 ArrayBuffer는 종이, 다른 도구는 펜과 잉크 같은 역할이라고나 할까요..._)\n\n```js\nconst buffer = new ArrayBuffer(8);\nconsole.log(buffer.byteLength); // output: 8\n```\n\n위 코드와 같이 `ArrayBuffer(8)` 생성자를 이용해 고정된 길이(8)를 가진 객체를 직접 생성할 수 있습니다.\n\n```js\nconst src =\n  \"https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\";\n\nfetch(src)\n  .then((res) => res.arrayBuffer())\n  .then((buffer) => console.log(buffer.byteLength)); // output: 13504\n```\n\n이미지를 바이너리로 다룰 때, ArrayBuffer를 이용할 수 있습니다. 간단히 예제로 구글 홈페이지의 로고를 `fetch` API로 가져와 `ArrayBuffer`로 변환하는 코드입니다. 이미지 데이터의 버퍼 길이와 실제 구글 로고의 용량을 비교해보면 같은 것을 볼 수 있습니다. 실제 데이터의 용량만큼 ArrayBuffer가 생성됩니다.\n\n```js\nconst src =\n  \"https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\";\n\nfetch(src)\n  .then((res) => res.arrayBuffer())\n  .then((buffer) => {\n    const blob = new Blob([buffer]);\n    const dataUrl = window.URL.createObjectURL(blob);\n    const img = document.createElement(\"img\");\n    img.src = dataUrl;\n    document.body.appendChild(img);\n  });\n```\n\n위 예제처럼 ArrayBuffer에 담긴 데이터를 이용해 Blob으로 변환해 이용할 수도 있습니다. 구글 메인 페이지에서 개발자도구로 실행해보세요. 실제로 ArrayBuffer를 위처럼 사용하지는 않지만 데이터가 저장되는 공간을 다루는 ArrayBuffer를 다양하게 활용할 수 있을 것입니다.\n\n## TypedArray (Int8Array, Int16Array)\n\n앞서 ArrayBuffer에 데이터를 직접 수정할 수 없다고 했습니다. ArrayBuffer를 다루는 방법으로 TypedArray에 대해 알아보겠습니다. TypedArray는 \"형식화 배열\"이라고 번역되며 의미는 이름에서와 같이 \"타입이 지정된 배열\"로 이해할 수 있습니다.\n\n```js\nconst buffer = new ArrayBuffer(8);\n\nconst int8arr = new Int8Array(buffer);\nconst int16arr = new Int16Array(buffer);\n\nconsole.log(int8arr); // Int8Array [0, 0, 0, 0, 0, 0, 0, 0]\nconsole.log(int16arr); // Int16Array [0, 0, 0, 0]\n```\n\n`ArrayBuffer` 객체를 생성하고 그 버퍼에 대해서 TypedArray 중 하나인 `Int8Array`객체를 생성했습니다. **Int8Array**는 **2의 보수 8비트 부호 있는 정수의 배열**입니다. 현재 선언된 버퍼의 크기는 `8bytes`이고 Int8Array의 각 요소의 크기는 `8bits === 1byte`이므로 길이가 `8`인 Int8Array가 생성되었습니다.\n\n이어서 같은 버퍼를 참조하여 생성된 **Int16Array**는 길이가 `4`입니다. Int16Array의 각 요소의 크기는 `2bytes`이기 때문입니다.\n\n```js\nconst buffer = new ArrayBuffer(8);\n\nconst int8arr = new Int8Array(buffer);\nconst int16arr = new Int16Array(buffer);\n\nint8arr[1] = 1;\nint16arr[3] = 1;\n\nconsole.log(int8arr); // Int8Array [0, 1, 0, 0, 0, 0, 1, 0]\nconsole.log(int16arr); // Int16Array [256, 0, 0, 1]\n```\n\n위 코드에서는 각각의 배열의 값을 변경했지만, 같은 ArrayBuffer를 공유하고 있기 때문에 두 배열이 영향을 받습니다. ArrayBuffer의 또 다른 **뷰**인 [DataView](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/DataView)를 이용하면 **엔디언**방식을 지정하여 값을 다룰 수 있습니다. (엔디언에 관한 자세한 정보는 [여기](https://developer.mozilla.org/ko/docs/Glossary/Endianness)를 참고해주세요.)\n\n![buffer and typedarray](/javascript/typed-array/img/buffer-and-typedarray.jpeg)\n\n이처럼 형식화 배열이 ArrayBuffer를 어떻게 이용하는 지 살펴보았습니다. 실제 개발을 하면서 데이터를 다룰 때 같은 buffer를 가지고 다른 배열에서 접근하여 사용할 일은 거의 없을 것이지만요.\n\n## Examples for Threejs\n\n```js\nconst geometry = new THREE.SphereGeometry(15, 32, 16);\nconsole.log(geometry.attributes.position.array); // Float32Array [-0, 15, 0, -0, 15, 0, -0, 15, 0, -0, …]\n```\n\n**WebGL**을 이용한 3D 시각화 라이브러리 [Threejs](https://threejs.org)의 코드에서 TypedArray를 사용합니다. 3차원의 입체 도형을 나타내기 위해 Vertex의 위치 정보를 Float32Array에 담아 사용합니다. 3D 이미지 자료이기 때문에 큰 용량의 데이터를 처리할 때 TypedArray를 쓰는 것이 장점이 있을 것으로 보입니다.\n\n## 마치며\n\n이번 글에서는 ArrayBuffer와 TypedArray에 대해서 간단히 살펴봤습니다. 프로그래밍을 하다 보면 성능에 대한 문제를 마주칠 때가 많은데, 그런 경우에 자료구조나 메모리를 다루는 방법이 필요합니다. ArrayBuffer를 통해 자바스크립트에서도 연속적인 메모리 영역에 저장된 데이터를 다룰 수 있다는 것을 살짝 찍먹해보았습니다.\n\nArrayBuffer가 추가된 것처럼 자바스크립트는 계속해서 발전하고 있습니다. 약한 타입과 스크립트 기반의 언어로서 단점이 많이 있기도 하지만, 많은 개발자들이 계속해서 고민하면서 한계를 점점 넓혀가고 있습니다. 새로운 것을 배우는 것이 때로는 소소한 즐거움이 되는 것 같습니다.\n","html":"<p><img src=\"/javascript/typed-array/img/arraybuffer-typedarray.png\" alt=\"arraybuffer-typedarray\"></p>\n<p>프로그래밍에 있어 빠질 수 없는 자료구조 중 하나는 바로 &quot;배열&quot;일 것입니다. 자바스크립트에는 &quot;Array&quot;라는 전역 객체로 배열을 사용할 수 있습니다. (<em>&quot;Array&quot;를 번역하면 &quot;배열&quot;이지만</em>) 실제로 자바스크립트의 Array는 일반적으로 컴퓨터과학에서 다루는 &quot;<a href=\"https://ko.wikipedia.org/wiki/%EB%B0%B0%EC%97%B4\">배열</a>&quot;과는 다릅니다. JS Array는 기본적으로 객체 타입이며, 연속적인 데이터 저장을 보장하지 않습니다.</p>\n<p>JIT 컴파일러를 사용하는 V8과 같은 엔진에서는 개선된 부분이 있지만, 연속성과 고정 타입을 늘 강제할 수는 없습니다. 만약 파일이나 이미지 등의 바이너리 데이터를 다룬다면 연속적인 메모리에 저장된 데이터 구조를 사용하는 것이 성능에 도움이 될 수 있습니다. 그러한 문제를 위해 ArrayBuffer와 TypedArray를 사용할 수 있습니다.</p>\n<h2 id=\"arraybuffer\">ArrayBuffer</h2>\n<blockquote>\n<p>&quot;버퍼(buffer)&quot;는 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역이다.</p>\n</blockquote>\n<p><strong>ArrayBuffer</strong>의 의미적인 이해를 돕기 위해 <strong>Buffer</strong>의 뜻을 검색해봤습니다. Buffer와 Array가 결합된 ArrayBuffer는 &quot;연속적인 데이터를 보관하는 메모리의 영역&quot;정도로 이해할 수 있습니다. MDN에서는 &quot;바이트로 구성된 배열&quot;이라고 표현하고 있습니다.</p>\n<p>하지만 ArrayBuffer는\b 데이터를 직접 다루는 기능을 제공하지 않습니다. TypedArray나 DataView 등의 객체를 이용하여 ArrayBuffer에 할당된 공간을 특정 타입의 데이터로 읽거나 쓸 수 있습니다. (<em>마치 ArrayBuffer는 종이, 다른 도구는 펜과 잉크 같은 역할이라고나 할까요...</em>)</p>\n<pre><code class=\"language-js\">const buffer = new ArrayBuffer(8);\nconsole.log(buffer.byteLength); // output: 8\n</code></pre>\n<p>위 코드와 같이 <code>ArrayBuffer(8)</code> 생성자를 이용해 고정된 길이(8)를 가진 객체를 직접 생성할 수 있습니다.</p>\n<pre><code class=\"language-js\">const src =\n  &quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;;\n\nfetch(src)\n  .then((res) =&gt; res.arrayBuffer())\n  .then((buffer) =&gt; console.log(buffer.byteLength)); // output: 13504\n</code></pre>\n<p>이미지를 바이너리로 다룰 때, ArrayBuffer를 이용할 수 있습니다. 간단히 예제로 구글 홈페이지의 로고를 <code>fetch</code> API로 가져와 <code>ArrayBuffer</code>로 변환하는 코드입니다. 이미지 데이터의 버퍼 길이와 실제 구글 로고의 용량을 비교해보면 같은 것을 볼 수 있습니다. 실제 데이터의 용량만큼 ArrayBuffer가 생성됩니다.</p>\n<pre><code class=\"language-js\">const src =\n  &quot;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png&quot;;\n\nfetch(src)\n  .then((res) =&gt; res.arrayBuffer())\n  .then((buffer) =&gt; {\n    const blob = new Blob([buffer]);\n    const dataUrl = window.URL.createObjectURL(blob);\n    const img = document.createElement(&quot;img&quot;);\n    img.src = dataUrl;\n    document.body.appendChild(img);\n  });\n</code></pre>\n<p>위 예제처럼 ArrayBuffer에 담긴 데이터를 이용해 Blob으로 변환해 이용할 수도 있습니다. 구글 메인 페이지에서 개발자도구로 실행해보세요. 실제로 ArrayBuffer를 위처럼 사용하지는 않지만 데이터가 저장되는 공간을 다루는 ArrayBuffer를 다양하게 활용할 수 있을 것입니다.</p>\n<h2 id=\"typedarray-int8array-int16array\">TypedArray (Int8Array, Int16Array)</h2>\n<p>앞서 ArrayBuffer에 데이터를 직접 수정할 수 없다고 했습니다. ArrayBuffer를 다루는 방법으로 TypedArray에 대해 알아보겠습니다. TypedArray는 &quot;형식화 배열&quot;이라고 번역되며 의미는 이름에서와 같이 &quot;타입이 지정된 배열&quot;로 이해할 수 있습니다.</p>\n<pre><code class=\"language-js\">const buffer = new ArrayBuffer(8);\n\nconst int8arr = new Int8Array(buffer);\nconst int16arr = new Int16Array(buffer);\n\nconsole.log(int8arr); // Int8Array [0, 0, 0, 0, 0, 0, 0, 0]\nconsole.log(int16arr); // Int16Array [0, 0, 0, 0]\n</code></pre>\n<p><code>ArrayBuffer</code> 객체를 생성하고 그 버퍼에 대해서 TypedArray 중 하나인 <code>Int8Array</code>객체를 생성했습니다. <strong>Int8Array</strong>는 <strong>2의 보수 8비트 부호 있는 정수의 배열</strong>입니다. 현재 선언된 버퍼의 크기는 <code>8bytes</code>이고 Int8Array의 각 요소의 크기는 <code>8bits === 1byte</code>이므로 길이가 <code>8</code>인 Int8Array가 생성되었습니다.</p>\n<p>이어서 같은 버퍼를 참조하여 생성된 <strong>Int16Array</strong>는 길이가 <code>4</code>입니다. Int16Array의 각 요소의 크기는 <code>2bytes</code>이기 때문입니다.</p>\n<pre><code class=\"language-js\">const buffer = new ArrayBuffer(8);\n\nconst int8arr = new Int8Array(buffer);\nconst int16arr = new Int16Array(buffer);\n\nint8arr[1] = 1;\nint16arr[3] = 1;\n\nconsole.log(int8arr); // Int8Array [0, 1, 0, 0, 0, 0, 1, 0]\nconsole.log(int16arr); // Int16Array [256, 0, 0, 1]\n</code></pre>\n<p>위 코드에서는 각각의 배열의 값을 변경했지만, 같은 ArrayBuffer를 공유하고 있기 때문에 두 배열이 영향을 받습니다. ArrayBuffer의 또 다른 <strong>뷰</strong>인 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/DataView\">DataView</a>를 이용하면 <strong>엔디언</strong>방식을 지정하여 값을 다룰 수 있습니다. (엔디언에 관한 자세한 정보는 <a href=\"https://developer.mozilla.org/ko/docs/Glossary/Endianness\">여기</a>를 참고해주세요.)</p>\n<p><img src=\"/javascript/typed-array/img/buffer-and-typedarray.jpeg\" alt=\"buffer and typedarray\"></p>\n<p>이처럼 형식화 배열이 ArrayBuffer를 어떻게 이용하는 지 살펴보았습니다. 실제 개발을 하면서 데이터를 다룰 때 같은 buffer를 가지고 다른 배열에서 접근하여 사용할 일은 거의 없을 것이지만요.</p>\n<h2 id=\"examples-for-threejs\">Examples for Threejs</h2>\n<pre><code class=\"language-js\">const geometry = new THREE.SphereGeometry(15, 32, 16);\nconsole.log(geometry.attributes.position.array); // Float32Array [-0, 15, 0, -0, 15, 0, -0, 15, 0, -0, …]\n</code></pre>\n<p><strong>WebGL</strong>을 이용한 3D 시각화 라이브러리 <a href=\"https://threejs.org\">Threejs</a>의 코드에서 TypedArray를 사용합니다. 3차원의 입체 도형을 나타내기 위해 Vertex의 위치 정보를 Float32Array에 담아 사용합니다. 3D 이미지 자료이기 때문에 큰 용량의 데이터를 처리할 때 TypedArray를 쓰는 것이 장점이 있을 것으로 보입니다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>이번 글에서는 ArrayBuffer와 TypedArray에 대해서 간단히 살펴봤습니다. 프로그래밍을 하다 보면 성능에 대한 문제를 마주칠 때가 많은데, 그런 경우에 자료구조나 메모리를 다루는 방법이 필요합니다. ArrayBuffer를 통해 자바스크립트에서도 연속적인 메모리 영역에 저장된 데이터를 다룰 수 있다는 것을 살짝 찍먹해보았습니다.</p>\n<p>ArrayBuffer가 추가된 것처럼 자바스크립트는 계속해서 발전하고 있습니다. 약한 타입과 스크립트 기반의 언어로서 단점이 많이 있기도 하지만, 많은 개발자들이 계속해서 고민하면서 한계를 점점 넓혀가고 있습니다. 새로운 것을 배우는 것이 때로는 소소한 즐거움이 되는 것 같습니다.</p>\n","excerpt":" 프로그래밍에 있어 빠질 수 없는 자료구조 중 하나는 바로 &quot;배열&quot;일 것입니다. 자바스크립트에는 &quot;Array&quot;라는 전역 객체로 배열을 사용할 수 있습니다. (&quot;Array&quot;를 번역하면 &quot;배열&quot;이지만) 실제로 자바스크립트의 Array는 일반적으로 컴퓨터과학에서 다루는 &quot;배열&quot","thumbnail":"/javascript/typed-array/img/arraybuffer-typedarray.png","thumbnailUrl":"https://hoontae24.github.io/javascript/typed-array/img/arraybuffer-typedarray.png"},{"href":"20","round":20,"paths":["retrospective","2년차-회고"],"slug":"2년차-회고","title":"참을 수 없는 코드의 가벼움(3년차 개발자 회고)","description":"","date":"2021-10-31","category":"retrospective","tags":["retrospective"],"seriesId":null,"markdown":"\n![book-cover](/retrospective/2년차-회고/img/book-cover.jpg \"참을 수 없는 존재의 가벼움, 밀란 쿤데라\")\n\n> _이 글의 제목인 **참을 수 없는 코드의 가벼움**은 환경과 다른 코드에 영향을 받아 쉽게 흔들리는 불안한 코드를 표현한 것이다._\n\n취업해서 개발자로서 일을 시작한 지 2년이 넘었다. 나에게 코드는 굉장히 흥미로운 도구이지만, 매일 씨름하는 스트레스의 주범이기도 하다. 코드를 작성하는 개발자는 종종 \"**이게 왜 안되지?**\", \"**엥, 왜 돌아가지?**\"라고 생각하곤 한다. 하지만 사실 코드는 아주 정직하게 동작한다. 코드는 앞에서 그렇게 생각한 개발자를 \"**아, 내가 바보네**\"라고 생각을 고쳐먹게 한다. 코드가 제대로 동작하는지는 개발자의 손에 달린 것이다.\n\n애증 덩어리인 코드를 작성하면서 **좋은 코드**에 대해 늘 고민했다. 좋은 코드에 대해 정의하는 많은 책과 아티클이 있고, 또 이것은 개발자 커뮤니티에서도 자주 접할 수 있는 주제다. 이 글에서는 주니어 개발자로 일하면서 좋은 코드에 대해 고민했던 것들을 다시 돌아보려 한다.\n\n## 기능과 도메인에 대한 이해\n\n### 제 코드를 믿으세요...? 저 신입인데요.\n\n처음 개발자로 입사를 하고서는 **제대로 동작하는 코드**를 작성하려고 고민했었다. 회사 개발팀의 문화가 여느 빅 IT 기업처럼 좋은 문화는 아니었다. 테스트 코드도 없었고, 코드 작성 컨벤션도 없었다. 기능만 제대로 동작한다면 내 코드를 아무도 들여다보지 않았다. 모든 것이 기능 위주의 개발이었다. 이렇게 개발을 하고 나면 서비스가 배포된 후에 사용자가 버그를 발견하는 경우가 많았고, 이것에 대해 보완할 수 있는 장치는 없었다. 코드를 작성한 내가 열심히 수동 E2E 테스트를 할 뿐이었다. 사실 가끔은 \"소프트웨어는 완벽할 수 없고, 버그는 고치면 된다\"라는 선임자의 태도가 나를 위로하기도 했다. 하지만 그것으로 내 코드에 대한 불안을 떨쳐낼 순 없었다.\n\n### iPad Safari에서는 안 되는데요?\n\n취업하기 전에 만들었던 토이 프로젝트와 다르게 비즈니스 레벨의 프로젝트에서는 고려해야 할 것들이 더 많다. **웹**에서는 크로스 브라우징 이슈나 웹 표준에 대한 부분을 따져보아야 한다. 또한 모바일과 태블릿에서의 호환성도 챙겨야 하고, 사용자 데이터가 많아짐에 따라 성능 하락이 생기지 않는지 신경 써야 한다. 이런 부분에서 꽤 많은 버그가 발생했었다. 데스크탑 + Windows + Chrome + 넉넉한 CPU와 메모리의 환경에서 잘 동작하던 것이 다른 OS나 브라우저에서는 다르게 동작하거나, 너무 느리거나 하는 버그가 있었다. 같은 기능이라도 환경마다 어떻게 다르게 동작하는지 알아야 하기 때문에 코드 이외에도 신경써야 할 부분들이 꽤 있었다.\n\n### 사용자가 원하는 것이 진짜 좋은 서비스일까?\n\n특히 기억에 남는 이슈가 있다. iPad에서는 웹 페이지 `viewport` 설정을 `user-scalable=no`으로 지정해도 **Pinch to Zoom** 기능을 제한할 수 없다. 애플이 웹 페이지 정책보다 사용자의 UX(_눈이 너무 나쁘거나 시각장애인일 경우_)가 우선된다고 [생각](https://webkit.org/blog/7367/new-interaction-behaviors-in-ios-10/)하기 때문이다. 나는 애플의 정책에 동의하지만, 우리 서비스의 기획자와 사용자는 아니었다. 결국 웹킷 엔진에서는 터치 이벤트를 분석해 Pinch to Zoom을 제한하는 기능을 따로 구현했다.\n\n웹 표준이나 OS 정책, 보편적인 사용성을 지키는 것이 좋지만 늘 그렇지는 않다. 서비스와 도메인에 따라서는 앞서 말했던 것과는 다르게 동작하도록 처리할 부분들이 있다. 어쩌면 특정 팀원의 고집으로 내가 생각하기에 일반적이지 않은 방향으로 개발해야 할 수도 있다. **FACEBOOK의 추천 알고리즘이 정치적 편향을 만든다는 논란**처럼 특정 기능이 미치는 영향에 대해 전부 알기 어렵지만, 좋은 서비스를 만드는 것이 무엇인지 생각해보게 되는 계기가 되었다.\n\n## 기술에 대한 이해\n\n### Mobx를 쓰다 보니 Redux가 보인다.\n\n입사하기 전에 프론트엔드 관련 기술 중 **Vue**를 주로 사용했던 터라 **React**에 대해서 잘 알지 못했다. 입사하면서 React를 사용하게 되었고 팀이 사용하는 상태 관리 도구인 **Mobx**를 사용했다. 1년 정도 리액트 + Mobx로 개발하면서 자연스럽게 더 깊이 알게 되었다. 리액트 상태 관리 도구로 잘 알려진 **Redux**에 대해 많이 들었지만 Mobx와 비교해 보진 않았었다. Mobx를 더 깊이 알아갈수록 Redux에 대한 궁금증이 생겼다. Mobx는 이렇게 동작하는데 Redux는 뭐가 다를까?\n\n이런 종류의 궁금증과 기술에 대한 이해가 커지는 시기는 입사 후 6개월부터 2년 정도까지였던 것 같다. 회사에서 React를 쓰면서 자연스럽게 React와 비교하며 Vue에 대해서도 더 공부하게 되었다. 또 Postgres를 사용하면서 Mysql과는 다른 데이터 타입은 무엇이 있는지, Datetime에 대한 처리는 어떻게 다른지 자연스럽게 알게 되었다. 하나의 기술을 깊이 알수록 이것과 비교하며 같은 목적의 기술을 더 쉽게 이해할 수 있는 것 같다.\n\n### 이렇게 짜면 느릴 것 같은데...\n\n실사용 서비스를 계속해서 개발-배포하는 반복되는 과정에서 코드는 언젠가 복잡해지고 속도의 문제를 마주친다. 개발 초기 단계에서 이미 존재했지만 몰랐던 문제일 수도 있다. SSR에서의 서버 처리 시간이 길어지거나, React 컴포넌트의 비효율적인 렌더링 등과 같은 문제가 이제 보이기 시작하는 것이다. 서비스의 속도가 느려지는 것뿐만 아니라 빌드/배포 시간도 길어진다. 개발자의 사고 방식 중 하나는 \"이게 지금 1개일 때 이 정도인데, 100개/1000개/10000개가 되면 어떨까?\" 하는 식의 무한대를 생각해 보는 것이다. 문제가 생겼을 때 빨리 해결하지 않으면 그것이 **스노우볼**이 되어 돌아올 것을 개발자는 직감한다.\n\n또한 치명적인 성능 이슈가 아니더라도 기술에 대한 이해가 생기면 내가 작성하는 코드가 성능에 어떤 영향을 미치게 될지 어느 정도 예상하게 된다. React의 Memoization을 적용한다거나, Mobx의 Reaction을 활용하는 것처럼 더 좋은 패턴을 사용하여 코드를 작성하는 고민을 하게 되는 것이다. 코드가 믿음직하지 못하더라도 동작하는 것에 만족했던 신입 때와 다르게 내가 작성하는 코드가 섹시하게 동작하는 것을 위해 신경 쓰게 되는 것이다.\n\n## 설계에 대한 이해\n\n> 코드는 언제든지 변경될 수 있다. 내 예상과는 늘 다르게.\n\n### 관심사의 분리\n\n컴포넌트 패턴 중에 Container Presenter 패턴이 있다. 컴포넌트의 비즈니스 처리 로직과 렌더링 뷰 부분을 구분하는 패턴인데, 컴포넌트를 반복적으로 개발하고 사용하다 보면 이러한 관심사의 분리를 위한 연구를 하게 된다. 코드가 동작하는 컨텍스트의 목적에 따라 코드를 분리하는 것이다. 또한 다른 뷰이지만 같은 비즈니스 처리 로직이나 상태를 가지거나, 같은 상태를 가지지만 다른 뷰를 가지는 경우와 같이 코드를 재사용할 때에도 효과적으로 이용할 수 있다.\n\n이것은 컴포넌트에만 적용되는 개념이 아니다. 서비스 레이어의 클래스를 작성하거나 심지어 아주 단순한 함수 하나를 작성하더라도 같은 원리를 적용할 수 있다. 코드 컨텍스트에 여러 목적을 위한 코드가 섞여 있으면 코드를 이해하기도 어렵고, 테스트하기도 어렵다. 작성하는 클래스의 역할이 무엇인지, 함수를 어느 정도 수준으로 쪼갤 것인지 고민하면서 코드가 적절한 자리에 있도록 설계해야 한다.\n\n### 유연한 인터페이스 사용\n\n코드의 변경을 예측하는 것은 쉽지 않다. 물론 도메인에 따라 어떻게 확장될 것인지 예상할 수 있는 부분도 있지만, 요구사항과 기능이 변하면서 코드가 변경되는 일을 미리 알기는 어렵다. 예측하지 못한 변경보다 더 나를 힘들게 하는 것은 하나의 코드를 수정하기 위해서 다른 코드를 수정해야 하는 일이었다. 이러한 문제들을 마주하면 SOLID 원칙, Strategy 패턴, 의존성 역전, 헥사고날 패턴 등 여러 가지 설계 이론들이 얼마나 필요한지 깨닫게 된다. 또한 이것들을 적용하는 것은 매우 즐거운 일이다. 클래스나 함수를 직접 참조하지 않고 인터페이스를 정의하여 사용하는 것이 얼마나 안정감이 있는지 느끼게 된다.\n\n## 마치며\n\n코드를 작성할 줄만 알고 깊이 이해하지 못했던 입사 초기와는 다르게 이제 코드의 가벼움이 주는 영향을 많이 체감한다. 사실 충분한 시간이 없는 경우에는 아직도 가벼운 코드를 급하게 작성하기도 한다. 이것은 정말 참기 힘든 부분이다. 내 스스로 기술 부채를 남기는 경험은 모든 개발자가 질색할 것이다. 빠르게 변화하는 소프트웨어의 생명주기에서 경제적이고 가볍지 않은 코드를 작성하는 것이 이 시대 속 모든 개발자의 숙명이 아닐까.\n\n2년 반이 넘는 시간 동안 코드에 대한 시각이 많이 변했다. 이제는 묵직한 코드를 작성하고 싶다. 검증된 코드를 작성하기 위해서는 아직 많은 경험이 필요할 것이다. 다행히 몇몇 빅 IT 기업들과 개인 개발자들이 양질의 기술 정보를 공유하는 시대에 살고 있다. 많은 개발자들이 지식을 공유해준 덕분에 계속해서 성장할 수 있을 것이다. 이런 문화는 개발자라는 직업의 매력 중 하나인 것 같다. 이제 앞으로 3년 후에는 내가 어떻게 코드를 바라보고 어떤 코드를 작성하고 있을지 기대하며 글을 마친다.\n","html":"<p><img src=\"/retrospective/2%EB%85%84%EC%B0%A8-%ED%9A%8C%EA%B3%A0/img/book-cover.jpg\" alt=\"book-cover\" title=\"참을 수 없는 존재의 가벼움, 밀란 쿤데라\"></p>\n<blockquote>\n<p><em>이 글의 제목인 <strong>참을 수 없는 코드의 가벼움</strong>은 환경과 다른 코드에 영향을 받아 쉽게 흔들리는 불안한 코드를 표현한 것이다.</em></p>\n</blockquote>\n<p>취업해서 개발자로서 일을 시작한 지 2년이 넘었다. 나에게 코드는 굉장히 흥미로운 도구이지만, 매일 씨름하는 스트레스의 주범이기도 하다. 코드를 작성하는 개발자는 종종 &quot;<strong>이게 왜 안되지?</strong>&quot;, &quot;<strong>엥, 왜 돌아가지?</strong>&quot;라고 생각하곤 한다. 하지만 사실 코드는 아주 정직하게 동작한다. 코드는 앞에서 그렇게 생각한 개발자를 &quot;<strong>아, 내가 바보네</strong>&quot;라고 생각을 고쳐먹게 한다. 코드가 제대로 동작하는지는 개발자의 손에 달린 것이다.</p>\n<p>애증 덩어리인 코드를 작성하면서 <strong>좋은 코드</strong>에 대해 늘 고민했다. 좋은 코드에 대해 정의하는 많은 책과 아티클이 있고, 또 이것은 개발자 커뮤니티에서도 자주 접할 수 있는 주제다. 이 글에서는 주니어 개발자로 일하면서 좋은 코드에 대해 고민했던 것들을 다시 돌아보려 한다.</p>\n<h2 id=\"기능과-도메인에-대한-이해\">기능과 도메인에 대한 이해</h2>\n<h3 id=\"제-코드를-믿으세요-저-신입인데요\">제 코드를 믿으세요...? 저 신입인데요.</h3>\n<p>처음 개발자로 입사를 하고서는 <strong>제대로 동작하는 코드</strong>를 작성하려고 고민했었다. 회사 개발팀의 문화가 여느 빅 IT 기업처럼 좋은 문화는 아니었다. 테스트 코드도 없었고, 코드 작성 컨벤션도 없었다. 기능만 제대로 동작한다면 내 코드를 아무도 들여다보지 않았다. 모든 것이 기능 위주의 개발이었다. 이렇게 개발을 하고 나면 서비스가 배포된 후에 사용자가 버그를 발견하는 경우가 많았고, 이것에 대해 보완할 수 있는 장치는 없었다. 코드를 작성한 내가 열심히 수동 E2E 테스트를 할 뿐이었다. 사실 가끔은 &quot;소프트웨어는 완벽할 수 없고, 버그는 고치면 된다&quot;라는 선임자의 태도가 나를 위로하기도 했다. 하지만 그것으로 내 코드에 대한 불안을 떨쳐낼 순 없었다.</p>\n<h3 id=\"ipad-safari에서는-안-되는데요\">iPad Safari에서는 안 되는데요?</h3>\n<p>취업하기 전에 만들었던 토이 프로젝트와 다르게 비즈니스 레벨의 프로젝트에서는 고려해야 할 것들이 더 많다. <strong>웹</strong>에서는 크로스 브라우징 이슈나 웹 표준에 대한 부분을 따져보아야 한다. 또한 모바일과 태블릿에서의 호환성도 챙겨야 하고, 사용자 데이터가 많아짐에 따라 성능 하락이 생기지 않는지 신경 써야 한다. 이런 부분에서 꽤 많은 버그가 발생했었다. 데스크탑 + Windows + Chrome + 넉넉한 CPU와 메모리의 환경에서 잘 동작하던 것이 다른 OS나 브라우저에서는 다르게 동작하거나, 너무 느리거나 하는 버그가 있었다. 같은 기능이라도 환경마다 어떻게 다르게 동작하는지 알아야 하기 때문에 코드 이외에도 신경써야 할 부분들이 꽤 있었다.</p>\n<h3 id=\"사용자가-원하는-것이-진짜-좋은-서비스일까\">사용자가 원하는 것이 진짜 좋은 서비스일까?</h3>\n<p>특히 기억에 남는 이슈가 있다. iPad에서는 웹 페이지 <code>viewport</code> 설정을 <code>user-scalable=no</code>으로 지정해도 <strong>Pinch to Zoom</strong> 기능을 제한할 수 없다. 애플이 웹 페이지 정책보다 사용자의 UX(<em>눈이 너무 나쁘거나 시각장애인일 경우</em>)가 우선된다고 <a href=\"https://webkit.org/blog/7367/new-interaction-behaviors-in-ios-10/\">생각</a>하기 때문이다. 나는 애플의 정책에 동의하지만, 우리 서비스의 기획자와 사용자는 아니었다. 결국 웹킷 엔진에서는 터치 이벤트를 분석해 Pinch to Zoom을 제한하는 기능을 따로 구현했다.</p>\n<p>웹 표준이나 OS 정책, 보편적인 사용성을 지키는 것이 좋지만 늘 그렇지는 않다. 서비스와 도메인에 따라서는 앞서 말했던 것과는 다르게 동작하도록 처리할 부분들이 있다. 어쩌면 특정 팀원의 고집으로 내가 생각하기에 일반적이지 않은 방향으로 개발해야 할 수도 있다. <strong>FACEBOOK의 추천 알고리즘이 정치적 편향을 만든다는 논란</strong>처럼 특정 기능이 미치는 영향에 대해 전부 알기 어렵지만, 좋은 서비스를 만드는 것이 무엇인지 생각해보게 되는 계기가 되었다.</p>\n<h2 id=\"기술에-대한-이해\">기술에 대한 이해</h2>\n<h3 id=\"mobx를-쓰다-보니-redux가-보인다\">Mobx를 쓰다 보니 Redux가 보인다.</h3>\n<p>입사하기 전에 프론트엔드 관련 기술 중 <strong>Vue</strong>를 주로 사용했던 터라 <strong>React</strong>에 대해서 잘 알지 못했다. 입사하면서 React를 사용하게 되었고 팀이 사용하는 상태 관리 도구인 <strong>Mobx</strong>를 사용했다. 1년 정도 리액트 + Mobx로 개발하면서 자연스럽게 더 깊이 알게 되었다. 리액트 상태 관리 도구로 잘 알려진 <strong>Redux</strong>에 대해 많이 들었지만 Mobx와 비교해 보진 않았었다. Mobx를 더 깊이 알아갈수록 Redux에 대한 궁금증이 생겼다. Mobx는 이렇게 동작하는데 Redux는 뭐가 다를까?</p>\n<p>이런 종류의 궁금증과 기술에 대한 이해가 커지는 시기는 입사 후 6개월부터 2년 정도까지였던 것 같다. 회사에서 React를 쓰면서 자연스럽게 React와 비교하며 Vue에 대해서도 더 공부하게 되었다. 또 Postgres를 사용하면서 Mysql과는 다른 데이터 타입은 무엇이 있는지, Datetime에 대한 처리는 어떻게 다른지 자연스럽게 알게 되었다. 하나의 기술을 깊이 알수록 이것과 비교하며 같은 목적의 기술을 더 쉽게 이해할 수 있는 것 같다.</p>\n<h3 id=\"이렇게-짜면-느릴-것-같은데\">이렇게 짜면 느릴 것 같은데...</h3>\n<p>실사용 서비스를 계속해서 개발-배포하는 반복되는 과정에서 코드는 언젠가 복잡해지고 속도의 문제를 마주친다. 개발 초기 단계에서 이미 존재했지만 몰랐던 문제일 수도 있다. SSR에서의 서버 처리 시간이 길어지거나, React 컴포넌트의 비효율적인 렌더링 등과 같은 문제가 이제 보이기 시작하는 것이다. 서비스의 속도가 느려지는 것뿐만 아니라 빌드/배포 시간도 길어진다. 개발자의 사고 방식 중 하나는 &quot;이게 지금 1개일 때 이 정도인데, 100개/1000개/10000개가 되면 어떨까?&quot; 하는 식의 무한대를 생각해 보는 것이다. 문제가 생겼을 때 빨리 해결하지 않으면 그것이 <strong>스노우볼</strong>이 되어 돌아올 것을 개발자는 직감한다.</p>\n<p>또한 치명적인 성능 이슈가 아니더라도 기술에 대한 이해가 생기면 내가 작성하는 코드가 성능에 어떤 영향을 미치게 될지 어느 정도 예상하게 된다. React의 Memoization을 적용한다거나, Mobx의 Reaction을 활용하는 것처럼 더 좋은 패턴을 사용하여 코드를 작성하는 고민을 하게 되는 것이다. 코드가 믿음직하지 못하더라도 동작하는 것에 만족했던 신입 때와 다르게 내가 작성하는 코드가 섹시하게 동작하는 것을 위해 신경 쓰게 되는 것이다.</p>\n<h2 id=\"설계에-대한-이해\">설계에 대한 이해</h2>\n<blockquote>\n<p>코드는 언제든지 변경될 수 있다. 내 예상과는 늘 다르게.</p>\n</blockquote>\n<h3 id=\"관심사의-분리\">관심사의 분리</h3>\n<p>컴포넌트 패턴 중에 Container Presenter 패턴이 있다. 컴포넌트의 비즈니스 처리 로직과 렌더링 뷰 부분을 구분하는 패턴인데, 컴포넌트를 반복적으로 개발하고 사용하다 보면 이러한 관심사의 분리를 위한 연구를 하게 된다. 코드가 동작하는 컨텍스트의 목적에 따라 코드를 분리하는 것이다. 또한 다른 뷰이지만 같은 비즈니스 처리 로직이나 상태를 가지거나, 같은 상태를 가지지만 다른 뷰를 가지는 경우와 같이 코드를 재사용할 때에도 효과적으로 이용할 수 있다.</p>\n<p>이것은 컴포넌트에만 적용되는 개념이 아니다. 서비스 레이어의 클래스를 작성하거나 심지어 아주 단순한 함수 하나를 작성하더라도 같은 원리를 적용할 수 있다. 코드 컨텍스트에 여러 목적을 위한 코드가 섞여 있으면 코드를 이해하기도 어렵고, 테스트하기도 어렵다. 작성하는 클래스의 역할이 무엇인지, 함수를 어느 정도 수준으로 쪼갤 것인지 고민하면서 코드가 적절한 자리에 있도록 설계해야 한다.</p>\n<h3 id=\"유연한-인터페이스-사용\">유연한 인터페이스 사용</h3>\n<p>코드의 변경을 예측하는 것은 쉽지 않다. 물론 도메인에 따라 어떻게 확장될 것인지 예상할 수 있는 부분도 있지만, 요구사항과 기능이 변하면서 코드가 변경되는 일을 미리 알기는 어렵다. 예측하지 못한 변경보다 더 나를 힘들게 하는 것은 하나의 코드를 수정하기 위해서 다른 코드를 수정해야 하는 일이었다. 이러한 문제들을 마주하면 SOLID 원칙, Strategy 패턴, 의존성 역전, 헥사고날 패턴 등 여러 가지 설계 이론들이 얼마나 필요한지 깨닫게 된다. 또한 이것들을 적용하는 것은 매우 즐거운 일이다. 클래스나 함수를 직접 참조하지 않고 인터페이스를 정의하여 사용하는 것이 얼마나 안정감이 있는지 느끼게 된다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>코드를 작성할 줄만 알고 깊이 이해하지 못했던 입사 초기와는 다르게 이제 코드의 가벼움이 주는 영향을 많이 체감한다. 사실 충분한 시간이 없는 경우에는 아직도 가벼운 코드를 급하게 작성하기도 한다. 이것은 정말 참기 힘든 부분이다. 내 스스로 기술 부채를 남기는 경험은 모든 개발자가 질색할 것이다. 빠르게 변화하는 소프트웨어의 생명주기에서 경제적이고 가볍지 않은 코드를 작성하는 것이 이 시대 속 모든 개발자의 숙명이 아닐까.</p>\n<p>2년 반이 넘는 시간 동안 코드에 대한 시각이 많이 변했다. 이제는 묵직한 코드를 작성하고 싶다. 검증된 코드를 작성하기 위해서는 아직 많은 경험이 필요할 것이다. 다행히 몇몇 빅 IT 기업들과 개인 개발자들이 양질의 기술 정보를 공유하는 시대에 살고 있다. 많은 개발자들이 지식을 공유해준 덕분에 계속해서 성장할 수 있을 것이다. 이런 문화는 개발자라는 직업의 매력 중 하나인 것 같다. 이제 앞으로 3년 후에는 내가 어떻게 코드를 바라보고 어떤 코드를 작성하고 있을지 기대하며 글을 마친다.</p>\n","excerpt":" 이 글의 제목인 참을 수 없는 코드의 가벼움은 환경과 다른 코드에 영향을 받아 쉽게 흔들리는 불안한 코드를 표현한 것이다.  취업해서 개발자로서 일을 시작한 지 2년이 넘었다. 나에게 코드는 굉장히 흥미로운 도구이지만, 매일 씨름하는 스트레스의 주범이기도 하다. 코드를 작성하는 개발자는 종종 &quot;이게 왜 안되지?&quot;, &quot;엥, 왜 돌아","thumbnail":"/retrospective/2년차-회고/img/book-cover.jpg","thumbnailUrl":"https://hoontae24.github.io/retrospective/2년차-회고/img/book-cover.jpg"},{"href":"19","round":19,"paths":["react","improved-in-mui-v5"],"slug":"improved-in-mui-v5","title":"MUI v5, 무엇이 바뀌었을까? (feat. why)","description":"","date":"2021-10-22","category":"react","tags":["react","frontend","mui"],"seriesId":null,"markdown":"\n![mui-v5](/react/improved-in-mui-v5/img/mui-v5.png)\n\n> 원문: [Introducing MUI Core v5.0](https://mui.com/blog/mui-core-v5/) \\\n> \\\n> 이 글은 **원문**의 개선점에 대한 내용의 일부를 리뷰한 글이며, 오역이 있을 수도 있습니다.\n\n[MUIv5](https://mui.com)가 릴리즈([2021.09.16](https://github.com/mui-org/material-ui/releases/tag/v5.0.0)) 되었습니다. MUI는 구글의 디자인 철학인 [Material Design](https://material.io)을 구현한 자바스크립트 라이브러리이고, [리액트 UI 라이브러리](https://www.npmtrends.com/@material-ui/core-vs-antd-vs-react-bootstrap-vs-reactstrap-vs-semantic-ui-react) 중에서 가장 점유율이 높은 패키지입니다. 여전히 활발하게 업데이트가 진행 중인 MUI팀의 고민들을 살펴보면서 그들이 프로덕트 품질 향상과 팀 성장을 이루어가는 경험을 살펴보겠습니다.\n\n## 1. 브랜딩 관점에서 본 MUI\n\n> We hope you are going to enjoy the DX improvement of only having to type 3 letters to type to find us on the internet: mui.com and to import us from npm @mui!\n\n이전에는 **Material-UI**였으나 이제 단 **3글자**로 줄였습니다. 이는 **개발자 경험**(**DX**)의 개선을 위해서라고 하는데, 얼마나 DX에 관심이 많은지 알 수 있는 부분입니다. 이번 업데이트에서 패키지 이름이 변경되는 것은 단순히 다른 이름을 `import`하는 [Breaking Changes](https://stackoverflow.com/questions/21703216/what-is-a-breaking-change-in-software)이면서도 브랜딩 관점에서 네이밍을 명확히 하는 변경입니다.\n\n1. Material-UI 조직을 `MUI`라 칭함.\n2. Material-UI MIT 컴포넌트 셋을 `MUI Core`라 칭함.\n3. Material-UI X 고급 컴포넌트 셋을 `MUI X`라 칭함. _(유료 플랜)_\n\n**MUI**와 **MUI Core**로 이름을 구분하는 것은 라이브러리 자체와 개발 그룹을 구분하는 것이 의미있다는 것을 말합니다. UI 라이브러리인 MUI의 관심사는 **사용자의 경험**(**UX**)과 그것을 만들어내는 **개발자의 경험**(**DX**)이라는 것을 알 수 있습니다. 이 두가지는 이렇게 바꾸어 표현할 수도 있을 것 같습니다. 하나는 MUI를 사용하는 개발자들의 경험(UX)이고, 또 하나는 MUI를 커스텀하며 생산하는 개발자들의 Contribute 경험(DX)입니다._(직접 라이브러리에 컨트리뷰터로 참여하지 않더라도 각자의 프로젝트에서 커스텀하여 사용하는 것을 말함)_\n\n> 네이밍을 포함한 MUI의 브랜딩 포인트는 [이 포스트](https://mui.com/blog/material-ui-is-now-mui/)에서 자세히 보실 수 있습니다.\n\n## 2. Improved customizability\n\n### 2.1. JSS에서 Emotion으로\n\nMUI는 지난 7년 동안 여러 스타일링 솔루션을 거치며 변경을 반복했습니다. 지난 버전에서 사용된 [JSS](https://cssinjs.org/)를 이용한 스타일링 방식은 React Hooks와 조합해 사용하기 편했고, 재사용과 오버라이딩하기 좋은 방식입니다. 그리고 이번 업데이트에서 [emotion](https://emotion.sh/)을 이용한 스타일링 방식으로 변경되었습니다. 이에 대해 다음 세 가지의 문제를 고려했습니다.\n\n1. 리액트 커뮤니티에서 `styled()`가 가장 인기 있는 CSS-in-JS API로 자리 잡았습니다.\n\n   styled-components, emotion, goober, stitches, linaria에서 이 방식을 사용합니다. MUI는 여러 스타일 라이브러리와 조합하여 사용할 수 있지만, 개발자들은 여전히 `makeStyles` API와 같은 새로운 것을 알아야 할 필요를 느낍니다. _(v4에서는 대부분의 컴포넌트 [예제](https://v4.mui.com/components/buttons/)가 `makeStyles` API로 작성되어 있습니다.)_\n\n2. React와 JSS의 통합은 우리가 목표하는 커스터마이징 DX의 그 다음 단계를 해결하기엔 너무 느립니다. MUI v4에서의 정적 CSS 생성은 빨랐습니다. 심지어 emotion보다 빨랐습니다. 하지만 동적 스타일 생성은 너무 느려서 재구현할 필요가 있었습니다.\n\n3. 많은 개발자가 styled-components로 마이그레이션할 것을 지지했고, 이는 우리가 유지 보수하는 custom React JSS Wrapper(_`makeStyles`_)를 삭제할 수 있게 해주었습니다. 경험상, 커스텀 스타일링 솔루션을 유지 보수하는 데에는 상당한 시간이 소요됩니다.\n\n`makeStyles` API(createUseStyles의 확장)를 사용해본 경험으로는 크게 불편하다고 느끼지도 못했고, 재사용과 확장성이 좋은 방식이었습니다. 하지만 `2`에서 말하는 동적 스타일을 생성하는 부분은 다른 스타일링 API와 비교히면 성능적인 아쉬움이 있었습니다. 그러한 점에서 많은 개발자가 선호하는 `styled()` API를 고려하는 것은 반가운 소식입니다.\n\n또한 MUI를 사용하는 저도 역시 프로젝트에 맞는 커스텀 설정을 구성하여 사용합니다. MUI팀 역시 React JSS를 래핑하는 커스텀 설정을 유지 보수하는 것이 비용과 경험적인 면에서 얼마나 비효율적인지를 말해주고 있습니다.\n\nMUI팀은 여러 옵션을 조사한 후, 위의 이슈를 해결하는 가장 좋은 해결책이라고 생각하는 것을 결정했습니다.\n\n1. 스타일을 추가하는 가장 저수준의 기본적인 요소인 `styled()`를 만들었습니다. 이 API는 이미 잘 알려져 있습니다.\n\n2. 공통 인터페이스와 구체적인 구현을 정의했습니다.\n\n   - `@mui/styled-engine`: emotion으로 구현 (default)\n   - `@mui/styled-engine-sc`: styled-components로 구현\n   - 다른 스타일 라이브러리를 사용하신다면, 자유롭게 래퍼를 제공하세요.\n\n   개발자는 다른 스타일 엔진 사이에서 변경할 수 있습니다. styled-components를 사용하면 더 이상 emotion과 styled-components를 모두 번들링할 필요가 없습니다. 또한, 각각에 대한 서버 사이드 렌더링 설정을 구성할 필요도 없습니다.\n\n   공통 인터페이스를 정의함으로 인해 MUI 컴포넌트 스타일링에서도 관심사의 분리가 이루어졌습니다. 실제 스타일링 하는 구현부에서는 어떤 엔진을 사용하는지 구현에 대해 직접 의존할 필요가 없고, 스타일 엔진에 대한 추상화가 이루어졌습니다.\n\n3. MUI팀은 emotion에 지난 몇 달 동안 월 $100을 후원했습니다. 이것을 지금은 $1000으로 인상했습니다. emotion 라이브러리가 기술적 수준을 이끌어가면서 한계를 초월하도록 돕는 것이 가장 큰 관심사이기 때문입니다.\n\nemotion으로 변경에 대한 첫 번째 즉각적인 이점은 **성능**입니다. `<Box>` 컴포넌트는 v4와 비교했을 때 v5에서 [5배~10배](https://codesandbox.io/s/zlh5w?file=/src/App.js) 정도 성능이 좋습니다.\n\n### 2.2. `sx` 속성\n\n기존에 있었던 `MUI System`인 `<Box>` 컴포넌트를 통해 해결하려고 했던 문제들이 있습니다.\n\n1. **컨텍스트 스위칭**으로 시간을 낭비합니다. styled API를 사용하면 컴포넌트를 스타링일(선언)하는 부분과 사용하는 부분 사이를 왔다 갔다 해야합니다. 스타일에 대한 코드를 필요한 곳에 바로 작성할 수는 없을까요?\n\n2. **네이밍**(이름짓기)은 어렵습니다. 컴포넌트의 좋은 이름을 짓기 위해 혼자서 분투해본 적이 있을겁니다. 이름을 새로 지을 필요를 제거할 수는 없을까요?\n\n3. UI에 대해 **일관성을 지키기**는 어렵습니다. 팀에서 여러 사람이 함께 개발할 때, 팀 구성원들 간 협의해야할 사항이 있기 때문입니다.\n\nv5에서 새롭게 추가된 `sx` 속성은 기존 `MUI System`을 한 단계 더 발전시켰습니다. 이 속성은 모든 컴포넌트에서 사용할 수 있고, CSS API의 수퍼셋인 일반 CSS 속성, [단축속성](https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties), 미디어 쿼리 헬퍼를 사용할 수 있습니다.\n\n```jsx\n// add margin: 8px 0px;\n// by Box\n<Box m={1}>\n  <Slider />\n</Box>\n\n// by sx prop\n<Slider sx={{ my: 1 }} />\n```\n\n`<Box>` 컴포넌트는 꽤 훌륭한 솔루션이었습니다. 하지만 여전히 아쉬운 점이 있습니다. 위의 문제들을 해결하긴 해도 그것 때문에 `<Box>` 컴포넌트를 추가해야 하는 경우도 있기 때문입니다. `sx` 속성이 더 편리한 솔루션으로 자리잡을지, 작성해야할 하나의 방식만 늘어나는 것은 아닌지 우려되기도 합니다. 어쨌든 새로운 시도는 늘 환영입니다.\n\n> `sx` prop과 함께 개선된 MUI System에 대한 내용은 [이 포스트](https://mui.com/system/basics/#why-use-the-system)에서 자세히 보실 수 있습니다.\n\n### 2.3. 동적 속성(Dynamic props)\n\n리액트 컴포넌트는 조합으로 사용합니다. 개발자가 코어 컴포넌트를 확장하는 방법은 컴포넌트를 임포트하고, 확장(기능 추가)하고, 래핑한 컴포넌트를 다시 익스포트하는 식으로 작성합니다. `label`과 `input`의 조합으로 이루어져 있는 `<TextField>` 컴포넌트가 대표적인 조합 예시라고 할 수 있습니다. v4까지 이런 방법으로 컴포넌트를 작성했지만 다음과 같은 문제가 있습니다.\n\n1. 새 컴포넌트를 만들 때마다, 이것은 팀에게 추가되는 새로운 임포트 옵션입니다. 제대로 사용하고자 하는 컴포넌트를 임포트 했는지 확인해야 합니다.\n\n2. 새로운 `color=\"success\"` 속성을 Button 컴포넌트에 추가하려면 사소하지 않은 CSS 커스텀이 필요합니다.\n\n3. 보일러플레이트가 추가됩니다.\n\n이러한 문제를 해결하기 위해, v5에서는 컴포넌트의 고유한 동작을 확장하기 위한 기능이 제공됩니다. 이것은 Github에서 많은 투표를 받은 이슈 중 하나입니다([#13875](https://github.com/mui-org/material-ui/issues/13875)). 실제로 이 변경은 MUI Core 컴포넌트를 확장 가능한 플레이스홀더로 만듭니다.\n\n이 기능의 첫번째로, 컴포넌트의 기존 스타일 매핑을 사용할 수 있습니다. 예를 들어, 새로운 `neutral` 색상을 컬러 팔레트에 추가하고, 버튼 컴포넌트는 그에 맞는 파생된 색상들을 계산합니다.\n\n```tsx\nimport { createTheme, Button } from \"@mui/material\";\n\n// 1. theme 객체 확장\nconst theme = createTheme({\n  palette: {\n    neutral: {\n      main: \"#d79b4a\",\n    },\n  },\n});\n\n// 2. 팔레트에 새로운 색상에 대한 타입 정의\ndeclare module \"@mui/material/styles\" {\n  interface Palette {\n    neutral: Palette[\"primary\"];\n  }\n  interface PaletteOptions {\n    neutral: PaletteOptions[\"primary\"];\n  }\n}\n\n// 3. Button 컴포넌트에 props로서 추가\ndeclare module \"@mui/material/Button\" {\n  interface ButtonPropsColorOverrides {\n    neutral: true;\n  }\n}\n\n// 4. 사용 이점\n<Button color=\"neutral\" />;\n```\n\n두번째로, 컴포넌트의 특정 `prop` 조합에 대한 CSS를 오버라이딩하는 커스텀 variant를 theme 객체에 추가할 수 있습니다. 아래 코드에서는 variants로 `dashed`가 추가되었고, `dashed`와 `color=\"error\"`의 조합에 대한 CSS를 커스텀으로 정의합니다.\n\n```tsx\nimport { createTheme, Button } from \"@mui/material\";\n\n// 1. theme 객체 확장\nconst theme = createTheme({\n  components: {\n    MuiButton: {\n      variants: [\n        {\n          props: { variant: \"dashed\", color: \"error\" },\n          style: {\n            border: \"1px dashed red\",\n            color: \"red\",\n          },\n        },\n      ],\n    },\n  },\n});\n\n// 2. Button 컴포넌트에 props로서 추가\ndeclare module \"@mui/material/Button\" {\n  interface ButtonPropsVariantOverrides {\n    dashed: true;\n  }\n}\n\n// 3. 사용 이점\n<Button variant=\"dashed\" color=\"error\">\n  dashed\n</Button>;\n```\n\nv4에서도 `theme` 객체를 확장하여 커스텀 색상이나 Mixins 등을 추가할 수 있었습니다. 하지만 MUI Core의 기본 컴포넌트에는 적용할 수 없었습니다(_Button에 새로운 variant를 추가하는 것_). theme 객체에 추가 선언하는 것만으로도 컴포넌트 props로 자동 적용되는 것은 정말 MUI 사용자로서 반가운 업데이트입니다.\n\n### 2.4. Global class names\n\nv4에서 MUI Core 컴포넌트는 글로벌 클래스([Button](https://v4.mui.com/api/button/#css))를 가지고 있습니다. 또 사용자가 생성하는 스타일에도 원하는 규칙에 따라 실제 CSS 클래스를 커스텀할 수 있습니다. v3에서부터 `classes` API를 바르게 사용하는 것에 대한 불만이 있었습니다. 저 역시도 `.MuiButton-root`와 같은 클래스를 직접 접근해서 사용하는 것이 `하드코딩`처럼 느껴져서 지양하는 방식이었습니다.\n\nv5에서는 호스트의 DOM 노드에 항상 글로벌 클래스를 추가하여 이 방법을 확장했습니다. 글로벌 클래스는 복잡한 컴포넌트의 커스텀을 단순하게 할 수 있도록, 자식 컴포넌트의 커스텀을 가능하게 합니다.\n\n예제를 통해 input의 바깥쪽 border 색상을 지정하는 세 가지 방법을 비교해보세요.\n\n```tsx\nimport TextField from \"@mui/material/TextField\";\nimport { outlinedInputClasses } from \"@mui/material/OutlinedInput\";\nimport { styled } from \"@mui/material/styles\";\n\n// Option 1: 글로벌 클래스(string)\nconst CustomizedTextField1 = styled(TextField)({\n  \"& .MuiOutlinedInput-notchedOutline\": {\n    borderColor: \"red\",\n  },\n});\n\n// Option 2: 글로벌 클래스(constant variables)\nconst CustomizedTextField2 = styled(TextField)({\n  [`& .${outlinedInputClasses.notchedOutline}`]: {\n    borderColor: \"red\",\n  },\n});\n\n// Option 3: classes 속성 (예전 방식)\nconst CustomizedTextField3 = styled((props) => (\n  <TextField\n    {...props}\n    variant=\"outlined\"\n    InputProps={{ classes: { notchedOutline: \"foo\" } }}\n  />\n))({\n  \"& .foo\": {\n    borderColor: \"red\",\n  },\n}) as typeof TextField;\n```\n\n### 2.5. Unstyled components (alpha)\n\n개발자가 MUI를 선택하는 주된 이유는 더 빠르게 UI를 만들 수 있기 때문입니다. 많은 컴포넌트가 이미 충분히 완성되어 있고, 쉽게 커스텀할 수 있게 스타일링 시스템이 적용되어 있습니다. 개발자에게는 MUI에 의존하면서 생기는 **tradeoff**가 있습니다. 그들은 **Material Design 컴포넌트 위에 새로운 스타일을 적용하는 것**이 **새 컴포넌트를 처음부터 만들**거나 **다른 라이브러리를 선택하는 것**보다 빠를 것이라고 판단합니다. 또한 충분한 성능을 발휘하고 자유도를 잃지 않을 것이라고 생각합니다.\n\n이 **tradeoff**는 제한된 작은 팀이나 내부적인 툴을 만드는 큰 팀에서는 효과적입니다. 하지만 대규모의 프로젝트를 진행하는 팀은 자유도도 높고 Material Design이 포함되지 않은, 그렇지만 처음부터 만드는 것보다는 더 나은 옵션이 있어야 합니다.\n\n이 문제에 대하여 Material Design 컴포넌트를 **hooks**와 **Unstyled components**로 분리하는 작업을 시작했습니다. 아직 alpha 단계이지만, 첫 번째 빌딩 블럭을 new unstyled 패키지에서 찾아볼 수 있습니다.\n\n```tsx\nconst CustomButton = React.forwardRef(function CustomButton(\n  props: ButtonUnstyledProps,\n  ref: React.ForwardedRef<any>\n) {\n  const { children } = props;\n  const { active, disabled, focusVisible, getRootProps } = useButton({\n    ...props,\n    ref,\n    component: CustomButtonRoot,\n  });\n\n  const classes = {\n    active,\n    disabled,\n    focusVisible,\n  };\n\n  return (\n    <CustomButtonRoot {...getRootProps()} className={clsx(classes)}>\n      {children}\n    </CustomButtonRoot>\n  );\n});\n```\n\n이러한 문제와 해결 방식을 통해, 이미 오래전부터 사용해오며 코드가 굳어진 컴포넌트의 스타일과 로직을 분리하는 것으로 더 세분화된 **관심사의 분리**([SOC](https://ko.wikipedia.org/wiki/관심사_분리))가 이루어졌습니다. 이 코드 분리 예시는 리액트 개발자로서도 좋은 컴포넌트 작성을 위한 팁이 되는 것 같습니다.\n\n## 3. Improved DX\n\n### 3.1. 더 작아진 데모\n\n대부분의 데모는 처음에 컴포넌트를 유지보수하는 작업에 도움이 되도록 고려하여 추가되었습니다. 이제 그 대신, 우선순위를 반대로 하여 개발자들이 사용하는 것을 우선했습니다. ([Inline previews](https://github.com/mui-org/material-ui/issues/22484))\n\n사실 이것은 복잡한 데모를 더 작게 쪼개는 것을 의미하고, 가능한 많은 \"Inline previews\" 가지는 것을 목표로 합니다. 이것은 데모를 확장하고 코드의 어떤 부분이 화면에서 내가 관심 있는 부분인지 찾는 오버헤드를 줄여줍니다.\n\n![inline-preview](/react/improved-in-mui-v5/img/inline-preview.png)\n\n### 3.2. IntelliSense에서의 Props 명세\n\n![inline-preview](/react/improved-in-mui-v5/img/prop-descriptions.png)\n\n모든 Props 명세가 Typescript로 작성되었고, 에디터의 IntelliSense에서 더 많은 컨텍스트를 볼 수 있습니다. 또한 [API pages](https://mui.com/api/autocomplete/#props)를 생성하는 데에도 역시 Typescript Props 명세를 사용했습니다. 그래서 모든 문서는 하나의 원본 소스로 이루어져 있습니다.\n\n### 3.3. Enzyme에서 Testing Library로\n\n**class components**에서 **hooks**로의 마이그레이션([v4 is out](https://medium.com/material-ui/material-ui-v4-is-out-4b7587d1e701))에서 [Enzyme](https://github.com/enzymejs/enzyme/)으로 작성된 많은 테스트가 깨졌습니다. 테스트가 너무 React 내부와 결합되어 있었습니다. 그래서 [Testing Library](https://testing-library.com/)로의 전환을 결정했습니다.\n\n새로운 테스트를 작성할 때, MUI팀의 테스트 코드가 영감이 될 수 있을 것입니다. 마이그레이션을 통해 구현 일부를 다시 생각해보고, 라이브러리와 함께 더 쉽게 테스트할 수 있게 되었습니다.\n\n### 3.4. Typescript migration\n\nMUI Core의 코드 베이스는 아직 완전히 Typescript로 작성되지 않았지만, 먼 길을 왔습니다. v4에서는 모든 데모를 Typescript로 먼저 작성했습니다. v5에서는 Typescript의 적용을 향한 새로운 단계를 만들었습니다.\n\n- Typescript 명세를 이용해 API pages의 원본을 만들었습니다. 이것은 새 릴리즈에 오래된 정의를 포함하는 가능성을 줄여줍니다.\n- Typescript로 작성될 첫 번째 컴포넌트를 마이그레이션했습니다.\n- 대부분의 새로운 코드를 Typescript로 작성하고 있습니다.\n\n### 3.5. Strict Mode 지원\n\n이번 릴리즈에서 `StrictMode`에 대한 호환성을 지원합니다. 이제 테스트와 문서화를 strict mode에서 실행합니다. 이것은 아주 오래되었고, 자주 요청되었던 문제입니다. 이전 버전에서는 대표적인 예시로, `Tooltip`이나 `Modal`과 같이 내부적으로 `findDomNode`를 사용하는 컴포넌트가 있다면 strict mode에서 에러를 발견할 수 있었습니다.\n\n하지만 레거시 방식을 사용하는 `@mui/styles` 패키지는 아직 strict mode와 동시성 기능이 호환되지 않습니다.\n\n## 마치며\n\n사실 이 포스트를 작성하는 시점에도 v5를 실제로 사용해보지는 않았습니다. 진행하는 프로젝트에서 바로 적용하기에는 Breaking Changes가 너무 많고 마이그레이션도 부담스럽기 때문입니다. 또 emotion을 이용한 스타일링 방식에 아직 익숙지 않아서 약간의 러닝커브가 생겨서 약간의 시간이 필요할 것 같습니다.\n\n실습 없이 v5를 분석한 것이 부족한 정보일지도 모르겠습니다. 하지만 이 포스트를 통하여 v5로의 변경에서 MUI팀이 어떤 가치 경험을 추구하는지 살펴보고, UI 라이브러리와 CSS 스타일링에 대한 이해가 넓어지는 데에 도움이 되었기를 바랍니다. 더 자세하고 올바른 정보를 얻기를 원하신다면 [원문](https://mui.com/blog/mui-core-v5/)을 참고하시기 바랍니다.\n","html":"<p><img src=\"/react/improved-in-mui-v5/img/mui-v5.png\" alt=\"mui-v5\"></p>\n<blockquote>\n<p>원문: <a href=\"https://mui.com/blog/mui-core-v5/\">Introducing MUI Core v5.0</a> <br><br>이 글은 <strong>원문</strong>의 개선점에 대한 내용의 일부를 리뷰한 글이며, 오역이 있을 수도 있습니다.</p>\n</blockquote>\n<p><a href=\"https://mui.com\">MUIv5</a>가 릴리즈(<a href=\"https://github.com/mui-org/material-ui/releases/tag/v5.0.0\">2021.09.16</a>) 되었습니다. MUI는 구글의 디자인 철학인 <a href=\"https://material.io\">Material Design</a>을 구현한 자바스크립트 라이브러리이고, <a href=\"https://www.npmtrends.com/@material-ui/core-vs-antd-vs-react-bootstrap-vs-reactstrap-vs-semantic-ui-react\">리액트 UI 라이브러리</a> 중에서 가장 점유율이 높은 패키지입니다. 여전히 활발하게 업데이트가 진행 중인 MUI팀의 고민들을 살펴보면서 그들이 프로덕트 품질 향상과 팀 성장을 이루어가는 경험을 살펴보겠습니다.</p>\n<h2 id=\"1-브랜딩-관점에서-본-mui\">1. 브랜딩 관점에서 본 MUI</h2>\n<blockquote>\n<p>We hope you are going to enjoy the DX improvement of only having to type 3 letters to type to find us on the internet: mui.com and to import us from npm @mui!</p>\n</blockquote>\n<p>이전에는 <strong>Material-UI</strong>였으나 이제 단 <strong>3글자</strong>로 줄였습니다. 이는 <strong>개발자 경험</strong>(<strong>DX</strong>)의 개선을 위해서라고 하는데, 얼마나 DX에 관심이 많은지 알 수 있는 부분입니다. 이번 업데이트에서 패키지 이름이 변경되는 것은 단순히 다른 이름을 <code>import</code>하는 <a href=\"https://stackoverflow.com/questions/21703216/what-is-a-breaking-change-in-software\">Breaking Changes</a>이면서도 브랜딩 관점에서 네이밍을 명확히 하는 변경입니다.</p>\n<ol>\n<li>Material-UI 조직을 <code>MUI</code>라 칭함.</li>\n<li>Material-UI MIT 컴포넌트 셋을 <code>MUI Core</code>라 칭함.</li>\n<li>Material-UI X 고급 컴포넌트 셋을 <code>MUI X</code>라 칭함. <em>(유료 플랜)</em></li>\n</ol>\n<p><strong>MUI</strong>와 <strong>MUI Core</strong>로 이름을 구분하는 것은 라이브러리 자체와 개발 그룹을 구분하는 것이 의미있다는 것을 말합니다. UI 라이브러리인 MUI의 관심사는 <strong>사용자의 경험</strong>(<strong>UX</strong>)과 그것을 만들어내는 <strong>개발자의 경험</strong>(<strong>DX</strong>)이라는 것을 알 수 있습니다. 이 두가지는 이렇게 바꾸어 표현할 수도 있을 것 같습니다. 하나는 MUI를 사용하는 개발자들의 경험(UX)이고, 또 하나는 MUI를 커스텀하며 생산하는 개발자들의 Contribute 경험(DX)입니다.<em>(직접 라이브러리에 컨트리뷰터로 참여하지 않더라도 각자의 프로젝트에서 커스텀하여 사용하는 것을 말함)</em></p>\n<blockquote>\n<p>네이밍을 포함한 MUI의 브랜딩 포인트는 <a href=\"https://mui.com/blog/material-ui-is-now-mui/\">이 포스트</a>에서 자세히 보실 수 있습니다.</p>\n</blockquote>\n<h2 id=\"2-improved-customizability\">2. Improved customizability</h2>\n<h3 id=\"21-jss에서-emotion으로\">2.1. JSS에서 Emotion으로</h3>\n<p>MUI는 지난 7년 동안 여러 스타일링 솔루션을 거치며 변경을 반복했습니다. 지난 버전에서 사용된 <a href=\"https://cssinjs.org/\">JSS</a>를 이용한 스타일링 방식은 React Hooks와 조합해 사용하기 편했고, 재사용과 오버라이딩하기 좋은 방식입니다. 그리고 이번 업데이트에서 <a href=\"https://emotion.sh/\">emotion</a>을 이용한 스타일링 방식으로 변경되었습니다. 이에 대해 다음 세 가지의 문제를 고려했습니다.</p>\n<ol>\n<li><p>리액트 커뮤니티에서 <code>styled()</code>가 가장 인기 있는 CSS-in-JS API로 자리 잡았습니다.</p>\n<p>styled-components, emotion, goober, stitches, linaria에서 이 방식을 사용합니다. MUI는 여러 스타일 라이브러리와 조합하여 사용할 수 있지만, 개발자들은 여전히 <code>makeStyles</code> API와 같은 새로운 것을 알아야 할 필요를 느낍니다. <em>(v4에서는 대부분의 컴포넌트 <a href=\"https://v4.mui.com/components/buttons/\">예제</a>가 <code>makeStyles</code> API로 작성되어 있습니다.)</em></p>\n</li>\n<li><p>React와 JSS의 통합은 우리가 목표하는 커스터마이징 DX의 그 다음 단계를 해결하기엔 너무 느립니다. MUI v4에서의 정적 CSS 생성은 빨랐습니다. 심지어 emotion보다 빨랐습니다. 하지만 동적 스타일 생성은 너무 느려서 재구현할 필요가 있었습니다.</p>\n</li>\n<li><p>많은 개발자가 styled-components로 마이그레이션할 것을 지지했고, 이는 우리가 유지 보수하는 custom React JSS Wrapper(<em><code>makeStyles</code></em>)를 삭제할 수 있게 해주었습니다. 경험상, 커스텀 스타일링 솔루션을 유지 보수하는 데에는 상당한 시간이 소요됩니다.</p>\n</li>\n</ol>\n<p><code>makeStyles</code> API(createUseStyles의 확장)를 사용해본 경험으로는 크게 불편하다고 느끼지도 못했고, 재사용과 확장성이 좋은 방식이었습니다. 하지만 <code>2</code>에서 말하는 동적 스타일을 생성하는 부분은 다른 스타일링 API와 비교히면 성능적인 아쉬움이 있었습니다. 그러한 점에서 많은 개발자가 선호하는 <code>styled()</code> API를 고려하는 것은 반가운 소식입니다.</p>\n<p>또한 MUI를 사용하는 저도 역시 프로젝트에 맞는 커스텀 설정을 구성하여 사용합니다. MUI팀 역시 React JSS를 래핑하는 커스텀 설정을 유지 보수하는 것이 비용과 경험적인 면에서 얼마나 비효율적인지를 말해주고 있습니다.</p>\n<p>MUI팀은 여러 옵션을 조사한 후, 위의 이슈를 해결하는 가장 좋은 해결책이라고 생각하는 것을 결정했습니다.</p>\n<ol>\n<li><p>스타일을 추가하는 가장 저수준의 기본적인 요소인 <code>styled()</code>를 만들었습니다. 이 API는 이미 잘 알려져 있습니다.</p>\n</li>\n<li><p>공통 인터페이스와 구체적인 구현을 정의했습니다.</p>\n<ul>\n<li><code>@mui/styled-engine</code>: emotion으로 구현 (default)</li>\n<li><code>@mui/styled-engine-sc</code>: styled-components로 구현</li>\n<li>다른 스타일 라이브러리를 사용하신다면, 자유롭게 래퍼를 제공하세요.</li>\n</ul>\n<p>개발자는 다른 스타일 엔진 사이에서 변경할 수 있습니다. styled-components를 사용하면 더 이상 emotion과 styled-components를 모두 번들링할 필요가 없습니다. 또한, 각각에 대한 서버 사이드 렌더링 설정을 구성할 필요도 없습니다.</p>\n<p>공통 인터페이스를 정의함으로 인해 MUI 컴포넌트 스타일링에서도 관심사의 분리가 이루어졌습니다. 실제 스타일링 하는 구현부에서는 어떤 엔진을 사용하는지 구현에 대해 직접 의존할 필요가 없고, 스타일 엔진에 대한 추상화가 이루어졌습니다.</p>\n</li>\n<li><p>MUI팀은 emotion에 지난 몇 달 동안 월 $100을 후원했습니다. 이것을 지금은 $1000으로 인상했습니다. emotion 라이브러리가 기술적 수준을 이끌어가면서 한계를 초월하도록 돕는 것이 가장 큰 관심사이기 때문입니다.</p>\n</li>\n</ol>\n<p>emotion으로 변경에 대한 첫 번째 즉각적인 이점은 <strong>성능</strong>입니다. <code>&lt;Box&gt;</code> 컴포넌트는 v4와 비교했을 때 v5에서 <a href=\"https://codesandbox.io/s/zlh5w?file=/src/App.js\">5배~10배</a> 정도 성능이 좋습니다.</p>\n<h3 id=\"22-sx-속성\">2.2. <code>sx</code> 속성</h3>\n<p>기존에 있었던 <code>MUI System</code>인 <code>&lt;Box&gt;</code> 컴포넌트를 통해 해결하려고 했던 문제들이 있습니다.</p>\n<ol>\n<li><p><strong>컨텍스트 스위칭</strong>으로 시간을 낭비합니다. styled API를 사용하면 컴포넌트를 스타링일(선언)하는 부분과 사용하는 부분 사이를 왔다 갔다 해야합니다. 스타일에 대한 코드를 필요한 곳에 바로 작성할 수는 없을까요?</p>\n</li>\n<li><p><strong>네이밍</strong>(이름짓기)은 어렵습니다. 컴포넌트의 좋은 이름을 짓기 위해 혼자서 분투해본 적이 있을겁니다. 이름을 새로 지을 필요를 제거할 수는 없을까요?</p>\n</li>\n<li><p>UI에 대해 <strong>일관성을 지키기</strong>는 어렵습니다. 팀에서 여러 사람이 함께 개발할 때, 팀 구성원들 간 협의해야할 사항이 있기 때문입니다.</p>\n</li>\n</ol>\n<p>v5에서 새롭게 추가된 <code>sx</code> 속성은 기존 <code>MUI System</code>을 한 단계 더 발전시켰습니다. 이 속성은 모든 컴포넌트에서 사용할 수 있고, CSS API의 수퍼셋인 일반 CSS 속성, <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties\">단축속성</a>, 미디어 쿼리 헬퍼를 사용할 수 있습니다.</p>\n<pre><code class=\"language-jsx\">// add margin: 8px 0px;\n// by Box\n&lt;Box m={1}&gt;\n  &lt;Slider /&gt;\n&lt;/Box&gt;\n\n// by sx prop\n&lt;Slider sx={{ my: 1 }} /&gt;\n</code></pre>\n<p><code>&lt;Box&gt;</code> 컴포넌트는 꽤 훌륭한 솔루션이었습니다. 하지만 여전히 아쉬운 점이 있습니다. 위의 문제들을 해결하긴 해도 그것 때문에 <code>&lt;Box&gt;</code> 컴포넌트를 추가해야 하는 경우도 있기 때문입니다. <code>sx</code> 속성이 더 편리한 솔루션으로 자리잡을지, 작성해야할 하나의 방식만 늘어나는 것은 아닌지 우려되기도 합니다. 어쨌든 새로운 시도는 늘 환영입니다.</p>\n<blockquote>\n<p><code>sx</code> prop과 함께 개선된 MUI System에 대한 내용은 <a href=\"https://mui.com/system/basics/#why-use-the-system\">이 포스트</a>에서 자세히 보실 수 있습니다.</p>\n</blockquote>\n<h3 id=\"23-동적-속성dynamic-props\">2.3. 동적 속성(Dynamic props)</h3>\n<p>리액트 컴포넌트는 조합으로 사용합니다. 개발자가 코어 컴포넌트를 확장하는 방법은 컴포넌트를 임포트하고, 확장(기능 추가)하고, 래핑한 컴포넌트를 다시 익스포트하는 식으로 작성합니다. <code>label</code>과 <code>input</code>의 조합으로 이루어져 있는 <code>&lt;TextField&gt;</code> 컴포넌트가 대표적인 조합 예시라고 할 수 있습니다. v4까지 이런 방법으로 컴포넌트를 작성했지만 다음과 같은 문제가 있습니다.</p>\n<ol>\n<li><p>새 컴포넌트를 만들 때마다, 이것은 팀에게 추가되는 새로운 임포트 옵션입니다. 제대로 사용하고자 하는 컴포넌트를 임포트 했는지 확인해야 합니다.</p>\n</li>\n<li><p>새로운 <code>color=&quot;success&quot;</code> 속성을 Button 컴포넌트에 추가하려면 사소하지 않은 CSS 커스텀이 필요합니다.</p>\n</li>\n<li><p>보일러플레이트가 추가됩니다.</p>\n</li>\n</ol>\n<p>이러한 문제를 해결하기 위해, v5에서는 컴포넌트의 고유한 동작을 확장하기 위한 기능이 제공됩니다. 이것은 Github에서 많은 투표를 받은 이슈 중 하나입니다(<a href=\"https://github.com/mui-org/material-ui/issues/13875\">#13875</a>). 실제로 이 변경은 MUI Core 컴포넌트를 확장 가능한 플레이스홀더로 만듭니다.</p>\n<p>이 기능의 첫번째로, 컴포넌트의 기존 스타일 매핑을 사용할 수 있습니다. 예를 들어, 새로운 <code>neutral</code> 색상을 컬러 팔레트에 추가하고, 버튼 컴포넌트는 그에 맞는 파생된 색상들을 계산합니다.</p>\n<pre><code class=\"language-tsx\">import { createTheme, Button } from &quot;@mui/material&quot;;\n\n// 1. theme 객체 확장\nconst theme = createTheme({\n  palette: {\n    neutral: {\n      main: &quot;#d79b4a&quot;,\n    },\n  },\n});\n\n// 2. 팔레트에 새로운 색상에 대한 타입 정의\ndeclare module &quot;@mui/material/styles&quot; {\n  interface Palette {\n    neutral: Palette[&quot;primary&quot;];\n  }\n  interface PaletteOptions {\n    neutral: PaletteOptions[&quot;primary&quot;];\n  }\n}\n\n// 3. Button 컴포넌트에 props로서 추가\ndeclare module &quot;@mui/material/Button&quot; {\n  interface ButtonPropsColorOverrides {\n    neutral: true;\n  }\n}\n\n// 4. 사용 이점\n&lt;Button color=&quot;neutral&quot; /&gt;;\n</code></pre>\n<p>두번째로, 컴포넌트의 특정 <code>prop</code> 조합에 대한 CSS를 오버라이딩하는 커스텀 variant를 theme 객체에 추가할 수 있습니다. 아래 코드에서는 variants로 <code>dashed</code>가 추가되었고, <code>dashed</code>와 <code>color=&quot;error&quot;</code>의 조합에 대한 CSS를 커스텀으로 정의합니다.</p>\n<pre><code class=\"language-tsx\">import { createTheme, Button } from &quot;@mui/material&quot;;\n\n// 1. theme 객체 확장\nconst theme = createTheme({\n  components: {\n    MuiButton: {\n      variants: [\n        {\n          props: { variant: &quot;dashed&quot;, color: &quot;error&quot; },\n          style: {\n            border: &quot;1px dashed red&quot;,\n            color: &quot;red&quot;,\n          },\n        },\n      ],\n    },\n  },\n});\n\n// 2. Button 컴포넌트에 props로서 추가\ndeclare module &quot;@mui/material/Button&quot; {\n  interface ButtonPropsVariantOverrides {\n    dashed: true;\n  }\n}\n\n// 3. 사용 이점\n&lt;Button variant=&quot;dashed&quot; color=&quot;error&quot;&gt;\n  dashed\n&lt;/Button&gt;;\n</code></pre>\n<p>v4에서도 <code>theme</code> 객체를 확장하여 커스텀 색상이나 Mixins 등을 추가할 수 있었습니다. 하지만 MUI Core의 기본 컴포넌트에는 적용할 수 없었습니다(<em>Button에 새로운 variant를 추가하는 것</em>). theme 객체에 추가 선언하는 것만으로도 컴포넌트 props로 자동 적용되는 것은 정말 MUI 사용자로서 반가운 업데이트입니다.</p>\n<h3 id=\"24-global-class-names\">2.4. Global class names</h3>\n<p>v4에서 MUI Core 컴포넌트는 글로벌 클래스(<a href=\"https://v4.mui.com/api/button/#css\">Button</a>)를 가지고 있습니다. 또 사용자가 생성하는 스타일에도 원하는 규칙에 따라 실제 CSS 클래스를 커스텀할 수 있습니다. v3에서부터 <code>classes</code> API를 바르게 사용하는 것에 대한 불만이 있었습니다. 저 역시도 <code>.MuiButton-root</code>와 같은 클래스를 직접 접근해서 사용하는 것이 <code>하드코딩</code>처럼 느껴져서 지양하는 방식이었습니다.</p>\n<p>v5에서는 호스트의 DOM 노드에 항상 글로벌 클래스를 추가하여 이 방법을 확장했습니다. 글로벌 클래스는 복잡한 컴포넌트의 커스텀을 단순하게 할 수 있도록, 자식 컴포넌트의 커스텀을 가능하게 합니다.</p>\n<p>예제를 통해 input의 바깥쪽 border 색상을 지정하는 세 가지 방법을 비교해보세요.</p>\n<pre><code class=\"language-tsx\">import TextField from &quot;@mui/material/TextField&quot;;\nimport { outlinedInputClasses } from &quot;@mui/material/OutlinedInput&quot;;\nimport { styled } from &quot;@mui/material/styles&quot;;\n\n// Option 1: 글로벌 클래스(string)\nconst CustomizedTextField1 = styled(TextField)({\n  &quot;&amp; .MuiOutlinedInput-notchedOutline&quot;: {\n    borderColor: &quot;red&quot;,\n  },\n});\n\n// Option 2: 글로벌 클래스(constant variables)\nconst CustomizedTextField2 = styled(TextField)({\n  [`&amp; .${outlinedInputClasses.notchedOutline}`]: {\n    borderColor: &quot;red&quot;,\n  },\n});\n\n// Option 3: classes 속성 (예전 방식)\nconst CustomizedTextField3 = styled((props) =&gt; (\n  &lt;TextField\n    {...props}\n    variant=&quot;outlined&quot;\n    InputProps={{ classes: { notchedOutline: &quot;foo&quot; } }}\n  /&gt;\n))({\n  &quot;&amp; .foo&quot;: {\n    borderColor: &quot;red&quot;,\n  },\n}) as typeof TextField;\n</code></pre>\n<h3 id=\"25-unstyled-components-alpha\">2.5. Unstyled components (alpha)</h3>\n<p>개발자가 MUI를 선택하는 주된 이유는 더 빠르게 UI를 만들 수 있기 때문입니다. 많은 컴포넌트가 이미 충분히 완성되어 있고, 쉽게 커스텀할 수 있게 스타일링 시스템이 적용되어 있습니다. 개발자에게는 MUI에 의존하면서 생기는 <strong>tradeoff</strong>가 있습니다. 그들은 <strong>Material Design 컴포넌트 위에 새로운 스타일을 적용하는 것</strong>이 <strong>새 컴포넌트를 처음부터 만들</strong>거나 <strong>다른 라이브러리를 선택하는 것</strong>보다 빠를 것이라고 판단합니다. 또한 충분한 성능을 발휘하고 자유도를 잃지 않을 것이라고 생각합니다.</p>\n<p>이 <strong>tradeoff</strong>는 제한된 작은 팀이나 내부적인 툴을 만드는 큰 팀에서는 효과적입니다. 하지만 대규모의 프로젝트를 진행하는 팀은 자유도도 높고 Material Design이 포함되지 않은, 그렇지만 처음부터 만드는 것보다는 더 나은 옵션이 있어야 합니다.</p>\n<p>이 문제에 대하여 Material Design 컴포넌트를 <strong>hooks</strong>와 <strong>Unstyled components</strong>로 분리하는 작업을 시작했습니다. 아직 alpha 단계이지만, 첫 번째 빌딩 블럭을 new unstyled 패키지에서 찾아볼 수 있습니다.</p>\n<pre><code class=\"language-tsx\">const CustomButton = React.forwardRef(function CustomButton(\n  props: ButtonUnstyledProps,\n  ref: React.ForwardedRef&lt;any&gt;\n) {\n  const { children } = props;\n  const { active, disabled, focusVisible, getRootProps } = useButton({\n    ...props,\n    ref,\n    component: CustomButtonRoot,\n  });\n\n  const classes = {\n    active,\n    disabled,\n    focusVisible,\n  };\n\n  return (\n    &lt;CustomButtonRoot {...getRootProps()} className={clsx(classes)}&gt;\n      {children}\n    &lt;/CustomButtonRoot&gt;\n  );\n});\n</code></pre>\n<p>이러한 문제와 해결 방식을 통해, 이미 오래전부터 사용해오며 코드가 굳어진 컴포넌트의 스타일과 로직을 분리하는 것으로 더 세분화된 <strong>관심사의 분리</strong>(<a href=\"https://ko.wikipedia.org/wiki/%EA%B4%80%EC%8B%AC%EC%82%AC_%EB%B6%84%EB%A6%AC\">SOC</a>)가 이루어졌습니다. 이 코드 분리 예시는 리액트 개발자로서도 좋은 컴포넌트 작성을 위한 팁이 되는 것 같습니다.</p>\n<h2 id=\"3-improved-dx\">3. Improved DX</h2>\n<h3 id=\"31-더-작아진-데모\">3.1. 더 작아진 데모</h3>\n<p>대부분의 데모는 처음에 컴포넌트를 유지보수하는 작업에 도움이 되도록 고려하여 추가되었습니다. 이제 그 대신, 우선순위를 반대로 하여 개발자들이 사용하는 것을 우선했습니다. (<a href=\"https://github.com/mui-org/material-ui/issues/22484\">Inline previews</a>)</p>\n<p>사실 이것은 복잡한 데모를 더 작게 쪼개는 것을 의미하고, 가능한 많은 &quot;Inline previews&quot; 가지는 것을 목표로 합니다. 이것은 데모를 확장하고 코드의 어떤 부분이 화면에서 내가 관심 있는 부분인지 찾는 오버헤드를 줄여줍니다.</p>\n<p><img src=\"/react/improved-in-mui-v5/img/inline-preview.png\" alt=\"inline-preview\"></p>\n<h3 id=\"32-intellisense에서의-props-명세\">3.2. IntelliSense에서의 Props 명세</h3>\n<p><img src=\"/react/improved-in-mui-v5/img/prop-descriptions.png\" alt=\"inline-preview\"></p>\n<p>모든 Props 명세가 Typescript로 작성되었고, 에디터의 IntelliSense에서 더 많은 컨텍스트를 볼 수 있습니다. 또한 <a href=\"https://mui.com/api/autocomplete/#props\">API pages</a>를 생성하는 데에도 역시 Typescript Props 명세를 사용했습니다. 그래서 모든 문서는 하나의 원본 소스로 이루어져 있습니다.</p>\n<h3 id=\"33-enzyme에서-testing-library로\">3.3. Enzyme에서 Testing Library로</h3>\n<p><strong>class components</strong>에서 <strong>hooks</strong>로의 마이그레이션(<a href=\"https://medium.com/material-ui/material-ui-v4-is-out-4b7587d1e701\">v4 is out</a>)에서 <a href=\"https://github.com/enzymejs/enzyme/\">Enzyme</a>으로 작성된 많은 테스트가 깨졌습니다. 테스트가 너무 React 내부와 결합되어 있었습니다. 그래서 <a href=\"https://testing-library.com/\">Testing Library</a>로의 전환을 결정했습니다.</p>\n<p>새로운 테스트를 작성할 때, MUI팀의 테스트 코드가 영감이 될 수 있을 것입니다. 마이그레이션을 통해 구현 일부를 다시 생각해보고, 라이브러리와 함께 더 쉽게 테스트할 수 있게 되었습니다.</p>\n<h3 id=\"34-typescript-migration\">3.4. Typescript migration</h3>\n<p>MUI Core의 코드 베이스는 아직 완전히 Typescript로 작성되지 않았지만, 먼 길을 왔습니다. v4에서는 모든 데모를 Typescript로 먼저 작성했습니다. v5에서는 Typescript의 적용을 향한 새로운 단계를 만들었습니다.</p>\n<ul>\n<li>Typescript 명세를 이용해 API pages의 원본을 만들었습니다. 이것은 새 릴리즈에 오래된 정의를 포함하는 가능성을 줄여줍니다.</li>\n<li>Typescript로 작성될 첫 번째 컴포넌트를 마이그레이션했습니다.</li>\n<li>대부분의 새로운 코드를 Typescript로 작성하고 있습니다.</li>\n</ul>\n<h3 id=\"35-strict-mode-지원\">3.5. Strict Mode 지원</h3>\n<p>이번 릴리즈에서 <code>StrictMode</code>에 대한 호환성을 지원합니다. 이제 테스트와 문서화를 strict mode에서 실행합니다. 이것은 아주 오래되었고, 자주 요청되었던 문제입니다. 이전 버전에서는 대표적인 예시로, <code>Tooltip</code>이나 <code>Modal</code>과 같이 내부적으로 <code>findDomNode</code>를 사용하는 컴포넌트가 있다면 strict mode에서 에러를 발견할 수 있었습니다.</p>\n<p>하지만 레거시 방식을 사용하는 <code>@mui/styles</code> 패키지는 아직 strict mode와 동시성 기능이 호환되지 않습니다.</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>사실 이 포스트를 작성하는 시점에도 v5를 실제로 사용해보지는 않았습니다. 진행하는 프로젝트에서 바로 적용하기에는 Breaking Changes가 너무 많고 마이그레이션도 부담스럽기 때문입니다. 또 emotion을 이용한 스타일링 방식에 아직 익숙지 않아서 약간의 러닝커브가 생겨서 약간의 시간이 필요할 것 같습니다.</p>\n<p>실습 없이 v5를 분석한 것이 부족한 정보일지도 모르겠습니다. 하지만 이 포스트를 통하여 v5로의 변경에서 MUI팀이 어떤 가치 경험을 추구하는지 살펴보고, UI 라이브러리와 CSS 스타일링에 대한 이해가 넓어지는 데에 도움이 되었기를 바랍니다. 더 자세하고 올바른 정보를 얻기를 원하신다면 <a href=\"https://mui.com/blog/mui-core-v5/\">원문</a>을 참고하시기 바랍니다.</p>\n","excerpt":" 원문: Introducing MUI Core v5.0 이 글은 원문의 개선점에 대한 내용의 일부를 리뷰한 글이며, 오역이 있을 수도 있습니다.  MUIv5가 릴리즈(2021.09.16) 되었습니다. MUI는 구글의 디자인 철학인 Material Design을 구현한 자바스크립트 라이브러리이고, 리액트 UI 라이브러리 중에서 가장 점유율이 높은 패키지입니다.","thumbnail":"/react/improved-in-mui-v5/img/mui-v5.png","thumbnailUrl":"https://hoontae24.github.io/react/improved-in-mui-v5/img/mui-v5.png"},{"href":"18","round":18,"paths":["docker","easy-database-server-with-docker"],"slug":"easy-database-server-with-docker","title":"Docker를 이용한 세상 쉬운 데이터베이스 서버 띄우기","description":"","date":"2021-10-16","category":"docker","tags":["docker","database"],"seriesId":null,"markdown":"\n![docker](/docker/easy-database-server-with-docker/img/docker.png)\n\n데이터베이스는 로컬 개발환경에서 자주 필요한 것 중 하나일 것입니다. 데이터베이스 서버는 한번 설치하고 서비스로 설정해두면 크게 손이 갈 일이 없긴 하지만, 저는 컴퓨터에 자주 사용하지 않는 프로그램을 설치하는 것이 찝찝하기도 합니다.\n\n이런 데이터베이스 서버를 사용할 때마다 설치 없이 구동하는 방법이 있습니다. 바로 [Docker](https://docker.com)를 이용하여 데이터베이스 서버를 구동하는 것입니다. _(아무것도 설치하지 않는 것은 아닙니다...)_\n\n> TL;DR \\\n> [docker-compose로 데이터베이스 서버 실행하기](https://hub.docker.com/_/postgres)\n\n> 준비: Docker가 설치되어 있어야 합니다. (환경에 따라 docker 명령어 앞에 `sudo`를 붙여야 할 수도 있습니다.)\n\n## 1. Postgres Docker 컨테이너 실행하기\n\nDocker가 준비되어 있다면 아주 간단하게 `postgres` 서버를 시작할 수 있습니다. 먼저 Postgres에서 제공하는 [Docker 이미지](https://hub.docker.com/_/postgres)를 이용하여 컨테이너를 실행하고, 컨테이너를 시작할 때 몇 가지 환경 변수만 지정해주면 됩니다.\n\n```sh\n$ docker run --name postgres -e POSTGRES_PASSWORD=root -p 5432:5432 -d postgres\n```\n\npostgres 컨테이너를 실행하기 위해서는 `POSTGRES_PASSWORD` 환경 변수를 필수적으로 주입해야 합니다. 저는 `root`라는 값으로 지정했습니다. 또한 컨테이너 그룹이 아닌 외부망 또는 호스트에서 접근하기 위해서 포트를 `-p 5432:5432` 옵션으로 지정하였습니다.\n\n위 명령어를 실행하면 컨테이너가 실행됩니다. 만약 `postgres` 도커 이미지가 없다면, 자동으로 다운로드 됩니다. 이렇게 실행한 후에 `docker ps` 명령어로 컨테이너를 확인해봅니다.\n\n![screenshot, 컨테이너 실행 후 결과 확인](/docker/easy-database-server-with-docker/img/docker-ps-after-running-container.png)\n\n데이터베이스 서버에 접속하여 구동을 확인하려면 `psql` 등의 DB 클라이언트가 설치되어 있어야 합니다. 하지만 로컬에 설치하기 싫어서 도커 컨테이너를 이용한 것이기 때문에... 저는 이미 설치된 VSCode의 [SQLTools Extension](https://marketplace.visualstudio.com/items?itemName=mtxr.sqltools)을 이용하여 접속해보겠습니다.\n\n![screenshot, SQLTools를 사용하여 연결 테스트](/docker/easy-database-server-with-docker/img/connection-test.png)\n\n로컬에 설치되어 있는 클라이언트 툴이 있다면 다른 것을 사용하셔도 좋습니다.\n\n## 2. docker-compose 이용하기\n\n`docker-compose`를 이용하면 명령어를 따로 기억하지 않아도 항상 같은 설정으로 컨테이너를 실행할 수 있습니다. [postgres docker image](https://hub.docker.com/_/postgres) 페이지에서는 docker-compose 설정과 함께 `adminer` 설정이 포함되어 있습니다.\n\n먼저 `docker-compose.yml` 파일을 작성하고 컨테이너를 실행합니다.\n\n```yml\nversion: \"3.1\"\n\nservices:\n  postgres:\n    image: postgres\n    container_name: postgres\n    restart: always\n    ports:\n      - 5432:5432\n    environment:\n      POSTGRES_PASSWORD: root\n\n  adminer:\n    image: adminer\n    container_name: adminer\n    restart: always\n    ports:\n      - 8080:8080\n```\n\n```sh\n$ docker-compose -f ./docker-compose.yml up -d\n```\n\n![screenshot, docker-compose를 이용하여 컨테이너 실행](/docker/easy-database-server-with-docker/img/result-after-running-by-docker-compose.png)\n\n![screenshot, docker-compose로 실행한 컨테이너 목록](/docker/easy-database-server-with-docker/img/container-list-after-running-by-docker-compose.png)\n\n두 개의 컨테이너가 실행되었습니다. 이 때, 저는 두 컨테이너를 묶은 `archive_default`라는 `network`가 자동으로 생성되었습니다. `docker-compose.yml` 파일이 `archive` 폴더 내에 위치했기 때문에 `archive`라는 prefix가 붙었는데, `docker-compose -p <project-name>` 옵션으로 직접 지정할 수도 있습니다.\n\n호스트에서는 아까와 같이 접속할 수 있고, `localhost:8080`으로 접속하면 `adminer`를 사용할 수 있습니다. 이때 `adminer`에서는 Postgres 서버 컨테이너 이름을 `host`로 지정해야 접속할 수 있습니다. 도커 컨테이너 간 통신에 대해 더 알아보시려면 [여기](https://docs.docker.com/network/bridge/)를 참고하거나 도커 네트워크 설정을 살펴보시면 됩니다.\n\n### 볼륨을 지정하여 데이터 관리하기\n\n지금은 컨테이너 내부에서만 데이터가 저장되므로 컨테이너가 삭제되면 데이터도 유실됩니다. 컨테이너에 볼륨을 지정하여 데이터베이스에서 저장되는 데이터만 따로 보존할 수 있습니다.\n\n`docker-compose.yml` 파일을 수정하여 `volume` 속성을 추가하겠습니다.\n\n```yml\nversion: \"3.1\"\n\nservices:\n  postgres:\n    image: postgres\n    container_name: postgres\n    restart: always\n    ports:\n      - 5432:5432\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    environment:\n      POSTGRES_PASSWORD: root\n\n  adminer:\n    image: adminer\n    container_name: adminer\n    restart: always\n    ports:\n      - 8080:8080\n\nvolumes:\n  pgdata:\n```\n\n이제 컨테이너를 종료 후 다시 시작하거나 바로 재시작하면 데이터를 볼륨에 저장합니다.\n\n```sh\n$ docker-compose -f ./docker-compose.yml down # 컨테이너 종료(Optional)\n$ docker-compose -f ./docker-compose.yml up -d # 컨테이너 시작\n```\n\n볼륨을 지정하고 컨테이너를 시작하면 처음 시작할 때 자동으로 볼륨을 생성합니다. 아래 명령을 통해 자동 생성된 `archive_pgdata` 볼륨을 확인할 수 있습니다.\n\n```sh\n$ docker volume ls\n```\n\n![screenshot, 볼륨 목록](/docker/easy-database-server-with-docker/img/volume-list.png)\n\n볼륨에 제대로 데이터가 저장되는지 아래 순서로 테스트해보세요:\n\n1. 클라이언트로 접속하여 임의의 데이터베이스를 하나 생성한다.\n2. 컨테이너를 종료 후 다시 시작한다. (`down`, `up` 명령)\n3. 클라이언트로 접속하여 `1`에서 생성한 데이터베이스가 존재하는지 확인한다.\n4. (위 과정을 볼륨을 지정하지 않은 설정으로 반복하여 비교해보세요.)\n\n## 마치며\n\n이번 글에서는 도커를 이용하여 간단히 데이터베이스 서버를 구동하는 법을 알아보았습니다. docker-compose 파일을 정의해두면 재설치나 버전 업그레이드할 때에도 도커 컨테이너만 변경하면 됩니다. 데이터베이스 서버가 구동되는 환경과 데이터를 완벽히 분리하여 관리할 수 있습니다.\n\n예제에서는 Postgres를 사용했지만 [mysql](https://hub.docker.com/_/mysql), [mariadb](https://hub.docker.com/_/mariadb), [mongodb](https://hub.docker.com/_/mongo) 등 다양한 데이터베이스를 간단하게 세팅할 수 있습니다. 데이터베이스 설정에 스트레스받지 않고 간단한 방법으로 개발 경험에 도움이 되었기를 바랍니다.\n","html":"<p><img src=\"/docker/easy-database-server-with-docker/img/docker.png\" alt=\"docker\"></p>\n<p>데이터베이스는 로컬 개발환경에서 자주 필요한 것 중 하나일 것입니다. 데이터베이스 서버는 한번 설치하고 서비스로 설정해두면 크게 손이 갈 일이 없긴 하지만, 저는 컴퓨터에 자주 사용하지 않는 프로그램을 설치하는 것이 찝찝하기도 합니다.</p>\n<p>이런 데이터베이스 서버를 사용할 때마다 설치 없이 구동하는 방법이 있습니다. 바로 <a href=\"https://docker.com\">Docker</a>를 이용하여 데이터베이스 서버를 구동하는 것입니다. <em>(아무것도 설치하지 않는 것은 아닙니다...)</em></p>\n<blockquote>\n<p>TL;DR <br><a href=\"https://hub.docker.com/_/postgres\">docker-compose로 데이터베이스 서버 실행하기</a></p>\n</blockquote>\n<blockquote>\n<p>준비: Docker가 설치되어 있어야 합니다. (환경에 따라 docker 명령어 앞에 <code>sudo</code>를 붙여야 할 수도 있습니다.)</p>\n</blockquote>\n<h2 id=\"1-postgres-docker-컨테이너-실행하기\">1. Postgres Docker 컨테이너 실행하기</h2>\n<p>Docker가 준비되어 있다면 아주 간단하게 <code>postgres</code> 서버를 시작할 수 있습니다. 먼저 Postgres에서 제공하는 <a href=\"https://hub.docker.com/_/postgres\">Docker 이미지</a>를 이용하여 컨테이너를 실행하고, 컨테이너를 시작할 때 몇 가지 환경 변수만 지정해주면 됩니다.</p>\n<pre><code class=\"language-sh\">$ docker run --name postgres -e POSTGRES_PASSWORD=root -p 5432:5432 -d postgres\n</code></pre>\n<p>postgres 컨테이너를 실행하기 위해서는 <code>POSTGRES_PASSWORD</code> 환경 변수를 필수적으로 주입해야 합니다. 저는 <code>root</code>라는 값으로 지정했습니다. 또한 컨테이너 그룹이 아닌 외부망 또는 호스트에서 접근하기 위해서 포트를 <code>-p 5432:5432</code> 옵션으로 지정하였습니다.</p>\n<p>위 명령어를 실행하면 컨테이너가 실행됩니다. 만약 <code>postgres</code> 도커 이미지가 없다면, 자동으로 다운로드 됩니다. 이렇게 실행한 후에 <code>docker ps</code> 명령어로 컨테이너를 확인해봅니다.</p>\n<p><img src=\"/docker/easy-database-server-with-docker/img/docker-ps-after-running-container.png\" alt=\"screenshot, 컨테이너 실행 후 결과 확인\"></p>\n<p>데이터베이스 서버에 접속하여 구동을 확인하려면 <code>psql</code> 등의 DB 클라이언트가 설치되어 있어야 합니다. 하지만 로컬에 설치하기 싫어서 도커 컨테이너를 이용한 것이기 때문에... 저는 이미 설치된 VSCode의 <a href=\"https://marketplace.visualstudio.com/items?itemName=mtxr.sqltools\">SQLTools Extension</a>을 이용하여 접속해보겠습니다.</p>\n<p><img src=\"/docker/easy-database-server-with-docker/img/connection-test.png\" alt=\"screenshot, SQLTools를 사용하여 연결 테스트\"></p>\n<p>로컬에 설치되어 있는 클라이언트 툴이 있다면 다른 것을 사용하셔도 좋습니다.</p>\n<h2 id=\"2-docker-compose-이용하기\">2. docker-compose 이용하기</h2>\n<p><code>docker-compose</code>를 이용하면 명령어를 따로 기억하지 않아도 항상 같은 설정으로 컨테이너를 실행할 수 있습니다. <a href=\"https://hub.docker.com/_/postgres\">postgres docker image</a> 페이지에서는 docker-compose 설정과 함께 <code>adminer</code> 설정이 포함되어 있습니다.</p>\n<p>먼저 <code>docker-compose.yml</code> 파일을 작성하고 컨테이너를 실행합니다.</p>\n<pre><code class=\"language-yml\">version: &quot;3.1&quot;\n\nservices:\n  postgres:\n    image: postgres\n    container_name: postgres\n    restart: always\n    ports:\n      - 5432:5432\n    environment:\n      POSTGRES_PASSWORD: root\n\n  adminer:\n    image: adminer\n    container_name: adminer\n    restart: always\n    ports:\n      - 8080:8080\n</code></pre>\n<pre><code class=\"language-sh\">$ docker-compose -f ./docker-compose.yml up -d\n</code></pre>\n<p><img src=\"/docker/easy-database-server-with-docker/img/result-after-running-by-docker-compose.png\" alt=\"screenshot, docker-compose를 이용하여 컨테이너 실행\"></p>\n<p><img src=\"/docker/easy-database-server-with-docker/img/container-list-after-running-by-docker-compose.png\" alt=\"screenshot, docker-compose로 실행한 컨테이너 목록\"></p>\n<p>두 개의 컨테이너가 실행되었습니다. 이 때, 저는 두 컨테이너를 묶은 <code>archive_default</code>라는 <code>network</code>가 자동으로 생성되었습니다. <code>docker-compose.yml</code> 파일이 <code>archive</code> 폴더 내에 위치했기 때문에 <code>archive</code>라는 prefix가 붙었는데, <code>docker-compose -p &lt;project-name&gt;</code> 옵션으로 직접 지정할 수도 있습니다.</p>\n<p>호스트에서는 아까와 같이 접속할 수 있고, <code>localhost:8080</code>으로 접속하면 <code>adminer</code>를 사용할 수 있습니다. 이때 <code>adminer</code>에서는 Postgres 서버 컨테이너 이름을 <code>host</code>로 지정해야 접속할 수 있습니다. 도커 컨테이너 간 통신에 대해 더 알아보시려면 <a href=\"https://docs.docker.com/network/bridge/\">여기</a>를 참고하거나 도커 네트워크 설정을 살펴보시면 됩니다.</p>\n<h3 id=\"볼륨을-지정하여-데이터-관리하기\">볼륨을 지정하여 데이터 관리하기</h3>\n<p>지금은 컨테이너 내부에서만 데이터가 저장되므로 컨테이너가 삭제되면 데이터도 유실됩니다. 컨테이너에 볼륨을 지정하여 데이터베이스에서 저장되는 데이터만 따로 보존할 수 있습니다.</p>\n<p><code>docker-compose.yml</code> 파일을 수정하여 <code>volume</code> 속성을 추가하겠습니다.</p>\n<pre><code class=\"language-yml\">version: &quot;3.1&quot;\n\nservices:\n  postgres:\n    image: postgres\n    container_name: postgres\n    restart: always\n    ports:\n      - 5432:5432\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    environment:\n      POSTGRES_PASSWORD: root\n\n  adminer:\n    image: adminer\n    container_name: adminer\n    restart: always\n    ports:\n      - 8080:8080\n\nvolumes:\n  pgdata:\n</code></pre>\n<p>이제 컨테이너를 종료 후 다시 시작하거나 바로 재시작하면 데이터를 볼륨에 저장합니다.</p>\n<pre><code class=\"language-sh\">$ docker-compose -f ./docker-compose.yml down # 컨테이너 종료(Optional)\n$ docker-compose -f ./docker-compose.yml up -d # 컨테이너 시작\n</code></pre>\n<p>볼륨을 지정하고 컨테이너를 시작하면 처음 시작할 때 자동으로 볼륨을 생성합니다. 아래 명령을 통해 자동 생성된 <code>archive_pgdata</code> 볼륨을 확인할 수 있습니다.</p>\n<pre><code class=\"language-sh\">$ docker volume ls\n</code></pre>\n<p><img src=\"/docker/easy-database-server-with-docker/img/volume-list.png\" alt=\"screenshot, 볼륨 목록\"></p>\n<p>볼륨에 제대로 데이터가 저장되는지 아래 순서로 테스트해보세요:</p>\n<ol>\n<li>클라이언트로 접속하여 임의의 데이터베이스를 하나 생성한다.</li>\n<li>컨테이너를 종료 후 다시 시작한다. (<code>down</code>, <code>up</code> 명령)</li>\n<li>클라이언트로 접속하여 <code>1</code>에서 생성한 데이터베이스가 존재하는지 확인한다.</li>\n<li>(위 과정을 볼륨을 지정하지 않은 설정으로 반복하여 비교해보세요.)</li>\n</ol>\n<h2 id=\"마치며\">마치며</h2>\n<p>이번 글에서는 도커를 이용하여 간단히 데이터베이스 서버를 구동하는 법을 알아보았습니다. docker-compose 파일을 정의해두면 재설치나 버전 업그레이드할 때에도 도커 컨테이너만 변경하면 됩니다. 데이터베이스 서버가 구동되는 환경과 데이터를 완벽히 분리하여 관리할 수 있습니다.</p>\n<p>예제에서는 Postgres를 사용했지만 <a href=\"https://hub.docker.com/_/mysql\">mysql</a>, <a href=\"https://hub.docker.com/_/mariadb\">mariadb</a>, <a href=\"https://hub.docker.com/_/mongo\">mongodb</a> 등 다양한 데이터베이스를 간단하게 세팅할 수 있습니다. 데이터베이스 설정에 스트레스받지 않고 간단한 방법으로 개발 경험에 도움이 되었기를 바랍니다.</p>\n","excerpt":" 데이터베이스는 로컬 개발환경에서 자주 필요한 것 중 하나일 것입니다. 데이터베이스 서버는 한번 설치하고 서비스로 설정해두면 크게 손이 갈 일이 없긴 하지만, 저는 컴퓨터에 자주 사용하지 않는 프로그램을 설치하는 것이 찝찝하기도 합니다. 이런 데이터베이스 서버를 사용할 때마다 설치 없이 구동하는 방법이 있습니다. 바로 Docker를 이용하여 데이터베이스 서버","thumbnail":"/docker/easy-database-server-with-docker/img/docker.png","thumbnailUrl":"https://hoontae24.github.io/docker/easy-database-server-with-docker/img/docker.png"},{"href":"17","round":17,"paths":["node","sequelize-cli-with-typescript"],"slug":"sequelize-cli-with-typescript","title":"sequelize-cli를 typescript와 함께 사용하기","description":"sequelize-cli를 typescript와 함께 사용할 수 있도록 세팅해보겠습니다.","date":"2021-10-02","category":"node","tags":["node","orm","sequelize"],"seriesId":null,"markdown":"\n![sequelize-cli typescript](/node/sequelize-cli-with-typescript/img/sequelize-and-typescript.png)\n\nNodeJS 환경에서 `Sequelize`를 사용할 때 `sequelize-cli`를 사용하면 `Model 생성`, `Migration 관리`, `시드 구성` 등의 기능을 CLI에서 사용할 수 있습니다. 하지만 `sequelize-cli`는 자바스크립트 기반으로 동작하고, 관련 파일을 `JS`파일로 작성해야 합니다. `sequelize-cli`를 사용할 때 `typescript`를 적용해서 사용할 수 있는 방법을 소개합니다.\n\n`sequelize`, `seqeuzlie-cli` 패키지를 미리 설치하겠습니다.\n\n```sh\nnpm i sequelize sequelize-cli\n```\n\n## 핵심 원리\n\n`sequelize-cli`를 사용하면서 `config.json` 파일이나 `migrations` 폴더를 커스터마이징하고 싶을 때 [.sequelizerc](https://sequelize.org/master/manual/migrations.html#the--code--sequelizerc--code--file) 파일을 작성하면 됩니다. `sequelize-cli`가 명령을 실행할 때 `.sequelizerc`파일을 읽고 작성된 설정대로 동작하는 것입니다.\n\n`sequelize-cli`가 `.sequelizerc`파일을 읽을 때, `babel`을 이용하여 `typescript`를 사용할 수 있도록 설정할 수 있습니다. 기본적으로 작성하는 `config.json`, `migrations` 등의 파일을 `typescript`로 작성할 수 있고, 다른 `ts`파일을 모듈로 `import`할 수 있습니다.\n\n간단한 실습으로 확인해보겠습니다.\n\n## BABEL 설정\n\n`babel` 및 `typescript` 관련 패키지를 먼저 설치합니다.\n\n```sh\nnpm i @babel/core @babel/register @babel/preset-env @babel/preset-typescript @babel/runtime @babel/plugin-transform-runtime typescript\n```\n\n`sequelize-cli`에서 `babel`을 이용할 수 있도록 하는 핵심 패키지는 `@babel/register`입니다.\n\n`.babelrc` 또는 `babel.config.json` 파일에 다음와 같이 `typescript` 설정을 추가합니다.\n\n```json\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-typescript\"],\n  \"plugins\": [\"@babel/plugin-transform-runtime\"]\n}\n```\n\n이제 `babel`이 `@babel/preset-typescript` 설정으로 인해 `typescript`를 읽을 준비가 되었습니다. `.sequelizerc`파일에서 `@babel/register`를 불러와 런타임에서 `babel`이 동작하도록 설정합니다.\n\n```js\n// .sequelizerc\n// runtime에서 babel을 사용(이 포스트의 핵심 코드)\nrequire(\"@babel/register\")({\n  configFile: \"./.babelrc\",\n  extensions: [\".js\", \".ts\"],\n});\n\nconst path = require(\"path\");\n\nmodule.exports = {\n  config: path.resolve(\"db\", \"config.ts\"),\n  \"models-path\": path.resolve(\"db\", \"models\"),\n  \"seeders-path\": path.resolve(\"db\", \"seeders\"),\n  \"migrations-path\": path.resolve(\"db\", \"migrations\"),\n};\n```\n\n이제 `sequelize-cli`가 동작할 때 `.babelrc`에서 작성된 설정대로 동작합니다.\n\n## sequelize-cli\n\n순수 `sequelize-cli`를 사용할 때는 `js`, `json` 파일로 생성됩니다. 현재 `babel`을 이용한 설정은 `sequelize-cli`가 관련 파일을 읽는 것을 도와주는 역할입니다. 그래서 `sequelize-cli`를 이용하여 생성되는 파일은 여전히 `js` 파일로 생성됩니다. 그래서 파일이 생성된 후에 `ts` 파일로 변경하고 코드를 재작성해야 합니다.\n\n### 초기화\n\n```sh\nnpx sequelize-cli init\n```\n\n초기화를 실행하면 `.sequelizerc`에서 작성한 대로 파일이 생성됩니다. 위에서 작성한 대로 진행하면 `db`폴더가 생성되고 그 아래에 `config.ts`파일이 있습니다. 기본 코드가 `json`으로 작성되었기 때문에 `ts` 코드로 재작성해줍니다.\n\n```ts\n// db/config.ts\nimport { Options } from \"sequelize/types\";\n\nexport const development: Options = {\n  username: \"development\",\n  password: \"development\",\n  database: \"development\",\n  host: \"localhost\",\n  port: 5432,\n  dialect: \"postgres\",\n};\n```\n\n이렇게 하면 타입 지원을 받을 수 있고, 외부 모듈에서 값을 불러올 수도 있습니다. 예로, `dotenv`에서 선언된 값을 사용할 수도 있겠네요.\n\n### 마이그레이션 생성\n\n제가 `sequelize-cli`를 `typescript`로 사용하려는 가장 큰 이유가 바로 마이그레이션 작성 때문입니다. 마이그레이션 코드를 작성할 때, 다른 모듈을 `import`하여 작성할 경우도 있고 기존 프로젝트 코드와의 일관성을 위해 타입을 지원받고 싶습니다.\n\n```sh\nnpx sequelize-cli migration:generate --name initialize\n```\n\n위 명령어로 마이그레이션을 생성하면 `db/migrations` 폴더 아래에 새로운 마이그레이션 파일이 생성됩니다. 해당 파일은 `js` 파일로 생성되기 때문에 `ts` 파일로 재작성 해야 합니다. 재작성하는 것이 귀찮을 수도 있지만 기존 프로젝트 모듈과 타입을 그대로 적용할 수 있는 것이 훨씬 개발 경험에 유리하다고 생각됩니다.\n\n생성된 마이그레이션의 코드를 다음과 같이 새롭게 작성합니다.\n\n```ts\nimport { QueryInterface, DataTypes } from \"sequelize\";\n\ntype T = typeof DataTypes;\n\nexport const up = async (queryInterface: QueryInterface, DataTypes: T) => {\n  await queryInterface.createTable(\"User\", {\n    id: {\n      type: DataTypes.INTEGER,\n      primaryKey: true,\n      allowNull: false,\n      autoIncrement: true,\n    },\n    name: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n  });\n};\nexport const down = async (queryInterface: QueryInterface, DataTypes: T) => {\n  await queryInterface.dropTable(\"User\");\n};\n```\n\n작성된 마이그레이션을 실행해보겠습니다.\n\n```sh\nnpx sequelize-cli db:migrate\n```\n\n![screenshot](/node/sequelize-cli-with-typescript/img/run-migration-result.png)\n\n작성한 마이그레이션 내용처럼 테이블이 생성되었습니다. 성공입니다!\n\n## 마무리\n\n위에서 언급한 것처럼 `sequelize-cli`에서 `typescript`를 사용할 수 없다는 것은 크게 두가지 불편함이 있습니다.\n\n- Sequelize DB Config, 모델, 시드, 마이그레이션 코드에서 타입 지원을 받을 수 없다.\n- 타입스크립트 기반 프로젝트의 모듈을 불러올 수 없고, 코드 일관성이 떨어진다.\n\n이 불편을 해결하기 위해서는 자체적으로 마이그레이션 등의 코드를 `ts`로 작성하여 사용할 수도 있습니다. 하지만 그렇게 하면 `sequelize-cli`가 관리하는 기능을 온전히 사용하지 못합니다.\n\n사실 이 포스트의 주제는 **`sequelize-cli`에 `babel` 적용하기**가 더 적당할 것 같지만, 타입스크립트를 적용하는 것에 큰 의미가 있고 이것으로 제가 겪은 문제를 해결하였기 때문에 `typescript` 적용에 초점을 맞추어 보았습니다.\n\n> 예제 코드는 [Github](https://github.com/hoontae24/blog-examples/tree/main/node/sequelize-cli-with-typescript)에서 확인할 수 있습니다.\n","html":"<p><img src=\"/node/sequelize-cli-with-typescript/img/sequelize-and-typescript.png\" alt=\"sequelize-cli typescript\"></p>\n<p>NodeJS 환경에서 <code>Sequelize</code>를 사용할 때 <code>sequelize-cli</code>를 사용하면 <code>Model 생성</code>, <code>Migration 관리</code>, <code>시드 구성</code> 등의 기능을 CLI에서 사용할 수 있습니다. 하지만 <code>sequelize-cli</code>는 자바스크립트 기반으로 동작하고, 관련 파일을 <code>JS</code>파일로 작성해야 합니다. <code>sequelize-cli</code>를 사용할 때 <code>typescript</code>를 적용해서 사용할 수 있는 방법을 소개합니다.</p>\n<p><code>sequelize</code>, <code>seqeuzlie-cli</code> 패키지를 미리 설치하겠습니다.</p>\n<pre><code class=\"language-sh\">npm i sequelize sequelize-cli\n</code></pre>\n<h2 id=\"핵심-원리\">핵심 원리</h2>\n<p><code>sequelize-cli</code>를 사용하면서 <code>config.json</code> 파일이나 <code>migrations</code> 폴더를 커스터마이징하고 싶을 때 <a href=\"https://sequelize.org/master/manual/migrations.html#the--code--sequelizerc--code--file\">.sequelizerc</a> 파일을 작성하면 됩니다. <code>sequelize-cli</code>가 명령을 실행할 때 <code>.sequelizerc</code>파일을 읽고 작성된 설정대로 동작하는 것입니다.</p>\n<p><code>sequelize-cli</code>가 <code>.sequelizerc</code>파일을 읽을 때, <code>babel</code>을 이용하여 <code>typescript</code>를 사용할 수 있도록 설정할 수 있습니다. 기본적으로 작성하는 <code>config.json</code>, <code>migrations</code> 등의 파일을 <code>typescript</code>로 작성할 수 있고, 다른 <code>ts</code>파일을 모듈로 <code>import</code>할 수 있습니다.</p>\n<p>간단한 실습으로 확인해보겠습니다.</p>\n<h2 id=\"babel-설정\">BABEL 설정</h2>\n<p><code>babel</code> 및 <code>typescript</code> 관련 패키지를 먼저 설치합니다.</p>\n<pre><code class=\"language-sh\">npm i @babel/core @babel/register @babel/preset-env @babel/preset-typescript @babel/runtime @babel/plugin-transform-runtime typescript\n</code></pre>\n<p><code>sequelize-cli</code>에서 <code>babel</code>을 이용할 수 있도록 하는 핵심 패키지는 <code>@babel/register</code>입니다.</p>\n<p><code>.babelrc</code> 또는 <code>babel.config.json</code> 파일에 다음와 같이 <code>typescript</code> 설정을 추가합니다.</p>\n<pre><code class=\"language-json\">{\n  &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-typescript&quot;],\n  &quot;plugins&quot;: [&quot;@babel/plugin-transform-runtime&quot;]\n}\n</code></pre>\n<p>이제 <code>babel</code>이 <code>@babel/preset-typescript</code> 설정으로 인해 <code>typescript</code>를 읽을 준비가 되었습니다. <code>.sequelizerc</code>파일에서 <code>@babel/register</code>를 불러와 런타임에서 <code>babel</code>이 동작하도록 설정합니다.</p>\n<pre><code class=\"language-js\">// .sequelizerc\n// runtime에서 babel을 사용(이 포스트의 핵심 코드)\nrequire(&quot;@babel/register&quot;)({\n  configFile: &quot;./.babelrc&quot;,\n  extensions: [&quot;.js&quot;, &quot;.ts&quot;],\n});\n\nconst path = require(&quot;path&quot;);\n\nmodule.exports = {\n  config: path.resolve(&quot;db&quot;, &quot;config.ts&quot;),\n  &quot;models-path&quot;: path.resolve(&quot;db&quot;, &quot;models&quot;),\n  &quot;seeders-path&quot;: path.resolve(&quot;db&quot;, &quot;seeders&quot;),\n  &quot;migrations-path&quot;: path.resolve(&quot;db&quot;, &quot;migrations&quot;),\n};\n</code></pre>\n<p>이제 <code>sequelize-cli</code>가 동작할 때 <code>.babelrc</code>에서 작성된 설정대로 동작합니다.</p>\n<h2 id=\"sequelize-cli\">sequelize-cli</h2>\n<p>순수 <code>sequelize-cli</code>를 사용할 때는 <code>js</code>, <code>json</code> 파일로 생성됩니다. 현재 <code>babel</code>을 이용한 설정은 <code>sequelize-cli</code>가 관련 파일을 읽는 것을 도와주는 역할입니다. 그래서 <code>sequelize-cli</code>를 이용하여 생성되는 파일은 여전히 <code>js</code> 파일로 생성됩니다. 그래서 파일이 생성된 후에 <code>ts</code> 파일로 변경하고 코드를 재작성해야 합니다.</p>\n<h3 id=\"초기화\">초기화</h3>\n<pre><code class=\"language-sh\">npx sequelize-cli init\n</code></pre>\n<p>초기화를 실행하면 <code>.sequelizerc</code>에서 작성한 대로 파일이 생성됩니다. 위에서 작성한 대로 진행하면 <code>db</code>폴더가 생성되고 그 아래에 <code>config.ts</code>파일이 있습니다. 기본 코드가 <code>json</code>으로 작성되었기 때문에 <code>ts</code> 코드로 재작성해줍니다.</p>\n<pre><code class=\"language-ts\">// db/config.ts\nimport { Options } from &quot;sequelize/types&quot;;\n\nexport const development: Options = {\n  username: &quot;development&quot;,\n  password: &quot;development&quot;,\n  database: &quot;development&quot;,\n  host: &quot;localhost&quot;,\n  port: 5432,\n  dialect: &quot;postgres&quot;,\n};\n</code></pre>\n<p>이렇게 하면 타입 지원을 받을 수 있고, 외부 모듈에서 값을 불러올 수도 있습니다. 예로, <code>dotenv</code>에서 선언된 값을 사용할 수도 있겠네요.</p>\n<h3 id=\"마이그레이션-생성\">마이그레이션 생성</h3>\n<p>제가 <code>sequelize-cli</code>를 <code>typescript</code>로 사용하려는 가장 큰 이유가 바로 마이그레이션 작성 때문입니다. 마이그레이션 코드를 작성할 때, 다른 모듈을 <code>import</code>하여 작성할 경우도 있고 기존 프로젝트 코드와의 일관성을 위해 타입을 지원받고 싶습니다.</p>\n<pre><code class=\"language-sh\">npx sequelize-cli migration:generate --name initialize\n</code></pre>\n<p>위 명령어로 마이그레이션을 생성하면 <code>db/migrations</code> 폴더 아래에 새로운 마이그레이션 파일이 생성됩니다. 해당 파일은 <code>js</code> 파일로 생성되기 때문에 <code>ts</code> 파일로 재작성 해야 합니다. 재작성하는 것이 귀찮을 수도 있지만 기존 프로젝트 모듈과 타입을 그대로 적용할 수 있는 것이 훨씬 개발 경험에 유리하다고 생각됩니다.</p>\n<p>생성된 마이그레이션의 코드를 다음과 같이 새롭게 작성합니다.</p>\n<pre><code class=\"language-ts\">import { QueryInterface, DataTypes } from &quot;sequelize&quot;;\n\ntype T = typeof DataTypes;\n\nexport const up = async (queryInterface: QueryInterface, DataTypes: T) =&gt; {\n  await queryInterface.createTable(&quot;User&quot;, {\n    id: {\n      type: DataTypes.INTEGER,\n      primaryKey: true,\n      allowNull: false,\n      autoIncrement: true,\n    },\n    name: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n  });\n};\nexport const down = async (queryInterface: QueryInterface, DataTypes: T) =&gt; {\n  await queryInterface.dropTable(&quot;User&quot;);\n};\n</code></pre>\n<p>작성된 마이그레이션을 실행해보겠습니다.</p>\n<pre><code class=\"language-sh\">npx sequelize-cli db:migrate\n</code></pre>\n<p><img src=\"/node/sequelize-cli-with-typescript/img/run-migration-result.png\" alt=\"screenshot\"></p>\n<p>작성한 마이그레이션 내용처럼 테이블이 생성되었습니다. 성공입니다!</p>\n<h2 id=\"마무리\">마무리</h2>\n<p>위에서 언급한 것처럼 <code>sequelize-cli</code>에서 <code>typescript</code>를 사용할 수 없다는 것은 크게 두가지 불편함이 있습니다.</p>\n<ul>\n<li>Sequelize DB Config, 모델, 시드, 마이그레이션 코드에서 타입 지원을 받을 수 없다.</li>\n<li>타입스크립트 기반 프로젝트의 모듈을 불러올 수 없고, 코드 일관성이 떨어진다.</li>\n</ul>\n<p>이 불편을 해결하기 위해서는 자체적으로 마이그레이션 등의 코드를 <code>ts</code>로 작성하여 사용할 수도 있습니다. 하지만 그렇게 하면 <code>sequelize-cli</code>가 관리하는 기능을 온전히 사용하지 못합니다.</p>\n<p>사실 이 포스트의 주제는 <strong><code>sequelize-cli</code>에 <code>babel</code> 적용하기</strong>가 더 적당할 것 같지만, 타입스크립트를 적용하는 것에 큰 의미가 있고 이것으로 제가 겪은 문제를 해결하였기 때문에 <code>typescript</code> 적용에 초점을 맞추어 보았습니다.</p>\n<blockquote>\n<p>예제 코드는 <a href=\"https://github.com/hoontae24/blog-examples/tree/main/node/sequelize-cli-with-typescript\">Github</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n","excerpt":"sequelize-cli를 typescript와 함께 사용할 수 있도록 세팅해보겠습니다. NodeJS 환경에서 Sequelize를 사용할 때 sequelize-cli를 사용하면 Model 생성, Migration 관리, 시드 구성 등의 기능을 CLI에서 사용할 수 있습니다. 하지만 sequelize-cli는 자바스크립트 기반으로 동작하고, 관련 파일을 JS파일로 작성해야 합니다. sequelize-cli를 사용할 때 typescript를 적용해","thumbnail":"/node/sequelize-cli-with-typescript/img/sequelize-and-typescript.png","thumbnailUrl":"https://hoontae24.github.io/node/sequelize-cli-with-typescript/img/sequelize-and-typescript.png"},{"href":"16","round":16,"paths":["css","how-does-css-in-js-work"],"slug":"how-does-css-in-js-work","title":"JS로 다루는 CSS, CSS-in-JS (feat. CSSOM)","description":"자바스크립트를 이용하여 스타일을 적용할 수 있는 CSS-in-JS가 어떻게 동작하는지 알아보겠습니다. 또 CSS-in-JS를 구현한 라이브러리마다 어떤 차이가 있는지 비교해보겠습니다.","date":"2021-09-26","category":"css","tags":["css","css-in-js","react"],"seriesId":null,"markdown":"\n![css-in-js](/css/how-does-css-in-js-work/img/css-in-js.png)\n\n[팀 버너스리](https://namu.wiki/w/팀%20버너스리)가 고안한 [웹](https://namu.wiki/w/월드%20와이드%20웹?from=웹)이 등장한 이래로 많은 웹 기술들이 생기고 사라졌습니다. 하지만 여전히 [HTML](https://namu.wiki/w/HTML)은 우리에게 중요한 기술로 남아 있습니다. 또한 CSS 역시 웹 문서의 스타일을 꾸미기 위해 사용하는 강력한 기술입니다. 웹 개발자라면 HTML과 CSS로 이루어진 웹 문서에 대한 이해가 필수적일 것입니다. React, Vue 등 많은 프론트엔드 기술이 있지만 이것들 역시 더 효과적으로 웹 문서(또는 웹 페이지)를 만들기 위한 도구일 뿐이며 HTML, CSS를 대체할 수는 없습니다.\n\n저 역시 프론트엔드 개발에서 React를 주로 사용하지만 HTML과 CSS, Javascript를 이용한 가장 기본적인 부분을 알아야 할 필요를 많이 느낍니다. React를 사용하더라도 CSS를 적용하는 방법은 다양합니다. 그중 저는 [MUI](https://mui.com), [Styled-components](https://styled-components.com) 등의 라이브러리를 사용하면서 CSS-in-JS를 주로 다루었습니다. 자바스크립트를 통해 동적인 CSS를 생성할 수 있는 **CSS-in-JS**는 개발자 경험(DX)을 만족스럽게 하면서도 여전히 흥미로운 기술입니다.\n\n## 1. CSS-in-JS\n\n> Cascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML. ([MDN](https://developer.mozilla.org/en-US/docs/Web/CSS))\n\nCSS는 스타일 시트 언어입니다. 순수 CSS만을 이용하여 웹 페이지의 모든 스타일을 적용하고 관리하기란 꽤 귀찮은 일이 아닐 수 없습니다. 그런 CSS를 보완하기 위해 여러 기술이 생겨났습니다. Sass, Less, Stylus 등의 CSS 전처리기 방식과 JSS, styled-components, emotion 등의 CSS-in-JS 방식 등이 있습니다.\n\nCSS-in-JS는 2014년 페이스북 개발자인 Christopher Chedeau aka Vjeux가 처음 [소개](http://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.html)하였습니다. Vjeux는 CSS를 작성하는 어려움을 다음과 같이 설명하였으며 CSS-in-JS로 이들 이슈를 모두 해결할 수 있다고 강조했습니다.\n\n> - Global namespace: 글로벌 공간에 선언된 이름의 명명 규칙 필요\n> - Dependencies: CSS 간의 의존 관계를 관리\n> - Dead Code Elimination: 미사용 코드 검출\n> - Minification: 클래스 이름의 최소화\n> - Sharing Constants: JS와 CSS의 상태 공유\n> - Non-deterministic Resolution: CSS 로드 우선순위 이슈\n> - Isolation: CSS와 JS의 상속에 따른 격리 필요 이슈\n\nCSS-in-JS는 말 그대로 자바스크립트로 작성한 CSS입니다. JS를 통해 생성되기 때문에 runtime에서 시트가 생성, 관리되며 프로그래밍 언어의 동적 특징을 이용할 수 있습니다. 사실 시트가 렌더링 되는 방식도 각 라이브러리마다 다릅니다. 여기서는 간단한 예제를 통해 CSS-in-JS 라이브러리가 어떤 식으로 CSS를 다루는 지 정도만 알아보겠습니다.\n\n## 2. CSSOM, CSSStyleSheet\n\n![CSS-in-JS on REACT](/css/how-does-css-in-js-work/img/npmtrends.png)\n\n> 예제 코드는 `React`에서 동작하는 `CSS-in-JS`를 살펴봅니다. 하지만 핵심 원리가 `React`에 의존하지는 않습니다.\n\n인기 있는 CSS-in-JS 라이브러리 중 `react-jss`, `styled-components`, `@emotion/css`을 이용해 코드를 작성해보고 CSS가 어떻게 생성되는지 직접 알아보겠습니다. 저는 `CRA`를 이용하여 리액트 환경을 구성하고 간단한 Task 관리 앱을 만들었습니다. 화면 결과는 따로 보여드리지 않고 생성된 `html` 태그와 `CSSOM` 객체에 정의된 스타일 시트를 확인하여 CSS가 어떻게 적용되는지 확인해보겠습니다.\n\n```jsx\n// src/App.jsx\nimport { useState } from \"react\";\n\nimport Task from \"./Task\";\n\nfunction App() {\n  const [tasks, setTasks] = useState([\n    { id: 1, title: \"대청소\", done: false },\n    { id: 2, title: \"설거지\", done: false },\n    { id: 3, title: \"빨래\", done: false },\n    { id: 4, title: \"가출\", done: false },\n  ]);\n\n  const handleDoneChange = (task) => () => {\n    task.done = !task.done;\n    setTasks([...tasks]);\n  };\n\n  console.log(document.styleSheets); // CSSOM 객체에 정의된 cssRule 확인\n  return (\n    <div>\n      <h1>TASKER</h1>\n      <hr />\n      <ul>\n        {tasks.map((task) => (\n          <Task\n            key={task.id}\n            title={task.title}\n            done={task.done}\n            onDoneChange={handleDoneChange(task)}\n          />\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n위에서 언급한 라이브러리를 이용하여 `Task` 컴포넌트를 작성하겠습니다. 먼저 `react-jss`의 `createUseStyles`를 이용합니다.\n\n```jsx\n// src/Task.jsx\nimport { createUseStyles } from \"react-jss\";\n\nconst useStyles = createUseStyles(() => ({\n  root: {\n    width: 500,\n    display: \"inline-block\",\n  },\n  rootChecked: {\n    color: \"grey\",\n    textDecoration: \"line-through\",\n  },\n}));\n\nconst Task = (props) => {\n  const cls = useStyles(props);\n  const { title, done, onDoneChange } = props;\n  return (\n    // 완료 여부에 따라 조건부 클래스 적용\n    <li className={[cls.root, done ? cls.rootChecked : \"\"].join(\" \")}>\n      <input type=\"checkbox\" checked={done} onChange={onDoneChange} />\n      {title}\n    </li>\n  );\n};\n\nexport default Task;\n```\n\n`createUseStyles`를 이용하면 객체 형식으로 CSS를 작성합니다. 객체 속성 하나가 하나의 선택자로 매핑됩니다. 브라우저 개발자도구에서 `html`을 열어보면 `head` 태그 안에 `style` 태그가 생성된 것을 확인할 수 있습니다.\n\n![screenshot](/css/how-does-css-in-js-work/img/react-jss-html.png)\n\n`console.log(document.styleSheets)` 코드에서 출력된 객체를 살펴보면 `1`개의 `CSSStyleSheet`가 생성되어 있습니다. `cssRules` 속성을 살펴보면 아래와 같이 `2`개의 `CSSStyleRule`이 생성되었습니다. 위 `style` 태그에서 생성된 각각의 선택자에 대한 스타일 룰이 이렇게 생성되어 있는 것입니다.\n\n![screenshot](/css/how-does-css-in-js-work/img/react-jss-cssom.png)\n\n여기에서 `Task`의 체크박스를 클릭하여 조건부 스타일이 적용되도록 해보겠습니다.\n\n![screenshot](/css/how-does-css-in-js-work/img/react-jss-condition-1-html.png)\n\n변경된 결과를 보면 이미 스타일은 생성되어 있고, `Element`에 `class`만 추가되어서 스타일이 적용되는 방식입니다. 이 과정에서 `style` 태그의 내용이나 `CSSStyleSheet`의 변경은 없었습니다.\n\n## 3. Props 기반 스타일 적용(react-jss)\n\n위의 예제에서는 `done`의 값을 통해 클래스명을 추가하여서 스타일을 적용하는 방식을 이용했습니다. 이 방식은 미리 **스타일 시트**를 작성해두고, 조건적으로 적용할 것에 대해서만 결정할 수 있습니다.\n\n이번에는 이와 다르게 `CSS-in-JS`의 대부분 라이브러리가 제공하는 `props`를 기반으로 스타일을 생성하는 방식으로 구현해보겠습니다. 위의 예제에서 `useStyles` 함수의 구현을 수정합니다.\n\n```jsx\nconst useStyles = createUseStyles(() => ({\n  root: (props) => ({\n    width: 500,\n    display: \"inline-block\",\n    color: props.done ? \"gray\" : \"inherit\",\n    textDecoration: props.done ? \"line-through\" : \"inherit\",\n  }),\n}));\n\nconst Task = (props) => {\n  const cls = useStyles(props);\n  const { title, done, onDoneChange } = props;\n  return (\n    <li className={cls.root}>\n      <input type=\"checkbox\" checked={done} onChange={onDoneChange} />\n      {title}\n    </li>\n  );\n};\n```\n\n`useStyles`의 인자로 넘겨준 `props`를 스타일 시트 객체에서 함수의 파라미터로 가져와 참조할 수 있습니다. 이 방식으로 변경하면 `html` 태그와 `CSSStyleSheet`는 어떻게 다를까요?\n\n![screenshot](/css/how-does-css-in-js-work/img/react-jss-props-html.png)\n\n이전과는 다르게 `style` 태그에 `css`는 작성되어 있지 않습니다. 그리고 `Task` 컴포넌트에서 각 항목의 클래스를 다르게 주입하는 것을 볼 수 있습니다. 지금 예제에서는 `root-0-2-1`과 `root-d?-0-2-?`처럼 두 개씩 주입되어 있고 그중 하나는 각각 다른 클래스가 입력되어 있습니다.\n\n![screenshot](/css/how-does-css-in-js-work/img/react-jss-props-cssom.png)\n\n`CSSStyleSheet`를 확인해보면 각 항목마다 다르게 주입된 클래스별로 `CSSStyleRule`이 생성된 것을 확인할 수 있습니다.\n\n이 상태에서 체크박스를 클릭하여 `props`를 이용한 조건부 스타일을 적용해보겠습니다.\n\n![screenshot](/css/how-does-css-in-js-work/img/react-jss-props-condition-cssom.png)\n\n`li`태그의 클래스는 변경된 것이 없고, `props.done`으로 지정된 컴포넌트는 `CSSStyleRule`이 변경되었습니다.\n\n위 예제를 통해 확인할 수 있는 것은 `react-jss`의 경우 `props`에 의한 동적 스타일링을 할 때, 각 항목마다 다른 `class`와 `CSSStyleRule`를 생성하여 적용한다는 것입니다.\n\n## styled-components\n\n이번에는 `styled-components`를 사용하여 같은 예제를 만들어 봅시다. `styled-components`는 `html` 태그에 `css`를 결합하여 리액트 컴포넌트로 만들어 사용합니다. `css`를 작성하기 위해서 [Tagged templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates) 문법을 사용할 수 있습니다. 만들어진 리액트 컴포넌트의 `props`를 이용해 동적인 스타일을 적용할 수 있습니다.\n\n`Task` 컴포넌트를 아래와 같이 수정하겠습니다.\n\n```jsx\nimport styled from \"styled-components\";\n\nconst ListItem = styled.li`\n  width: 500px;\n  display: inline-block;\n  color: ${({ done }) => (done ? \"gray\" : \"inherit\")};\n  text-decoration: ${({ done }) => (done ? \"line-through\" : \"inherit\")};\n`;\n\nconst Task = (props) => {\n  const { title, done, onDoneChange } = props;\n  return (\n    <ListItem done={done}>\n      <input type=\"checkbox\" checked={done} onChange={onDoneChange} />\n      {title}\n    </ListItem>\n  );\n};\n\nexport default Task;\n```\n\n`html` 태그와 `CSSStyleSheet`를 살펴보겠습니다.\n\n![screenshot](/css/how-does-css-in-js-work/img/sc-html.png)\n\n![screenshot](/css/how-does-css-in-js-work/img/sc-cssom.png)\n\n`react-jss`에서의 첫 결과와 비슷하게, 하나의 `CSSStyleRule`이 생성되고 그것이 각 `li` 태그에 같게 적용되어 있습니다. 이제 체크박스를 클릭해 조건부 스타일을 적용해보겠습니다.\n\n![screenshot](/css/how-does-css-in-js-work/img/sc-condition-html.png)\n\n![screenshot](/css/how-does-css-in-js-work/img/sc-condition-cssom.png)\n\n`html`에서의 변경은 `css`가 생성되고 `li` 태그의 클래스가 변경되었습니다. `CSSStyleSheet`의 변경은 `CSSStyleRule`이 추가로 생성되었습니다.\n\n이 예제를 통해 확인할 수 있는 것은 `styled-components`는 필요한 `css`를 생성해서 사용하고, `props`에 의한 동적인 스타일에서는 런타임에서 `css`(`CSSStyleRule`)을 생성하여 사용한다는 것을 알 수 있습니다. `props.done` 값 하나만 사용할 때는 `2`개의 `CSSStyleRule`이 생성되었지만, 만약 다른 `props`를 이용한다면 더 많은 `CSSStyleRule`이 생성될 것입니다.\n\n## @emotion/css\n\n이번에는 `@emotion/css`를 이용하여 같은 실험을 해보겠습니다. `Task` 컴포넌트를 아래와 같이 수정합니다.\n\n```jsx\nimport { css } from \"@emotion/css\";\n\nconst Task = (props) => {\n  const { title, done, onDoneChange } = props;\n  return (\n    <div\n      className={css`\n        width: 500px;\n        display: inline-block;\n        color: ${done ? \"gray\" : \"inherit\"};\n        text-decoration: ${done ? \"line-through\" : \"inherit\"};\n      `}\n    >\n      <input type=\"checkbox\" checked={done} onChange={onDoneChange} />\n      {title}\n    </div>\n  );\n};\n\nexport default Task;\n```\n\n`html`과 `CSSStyleSheet`를 봅시다.\n\n![screenshot](/css/how-does-css-in-js-work/img/emotion-html.png)\n\n![screenshot](/css/how-does-css-in-js-work/img/emotion-cssom.png)\n\n이전 라이브러리와 다르지 않은 결과입니다. 바로 체크박스를 클릭해 동적인 스타일을 적용해보겠습니다.\n\n![screenshot](/css/how-does-css-in-js-work/img/emotion-props-html.png)\n\n![screenshot](/css/how-does-css-in-js-work/img/emotion-props-cssom.png)\n\n`html`의 결과를 살펴보면 다른 라이브러리와는 다르게 `style`태그가 `2`개가 되었습니다. 또한 `CSSStyleRule`이 추가된 것이 아닌 `CSSStyleSheet`가 추가된 것을 볼 수 있습니다.\n\n## 마무리\n\nCSS-in-JS의 여러 라이브러리를 직접 사용해보면서 어떤 방식으로 `css`를 적용하는지 살펴보았습니다. 라이브러리들의 내부적인 상세한 구현은 모르지만 `cssom`을 조작하여 스타일을 적용한다는 것을 예제를 통해 확인할 수 있었습니다. 또한 흥미로웠던 것은 라이브러리마다 `cssom`을 조작하는 방식이 다르다는 것입니다. `CSSStyleRule`을 **생성**하는 방식과 **변경**하는 방식 중에서 상황에 따라 적합한 방식을 선택하는 것도 생각해볼 만한 구현 디테일인 것 같습니다.\n\n최근 [MUIv5](https://mui.com)가 발표되면서 `CSS-in-JS` 엔진에 대한 이야기([Migration from JSS to emotion](https://mui.com/blog/mui-core-v5/#migration-from-jss-to-emotion))를 개인적으로는 인상 깊게 읽었었는데, 디테일한 전략과 구현에 대해 살펴보아도 재밌을 것 같습니다.\n\n> 예제 코드는 [Github](https://github.com/hoontae24/blog-examples/tree/main/react/how-does-css-in-js-work)에서 확인할 수 있습니다.\n\n> 이 글을 작성하면서 아래의 글에 도움을 받았습니다.\n>\n> - [웹 컴포넌트 스타일링 관리: CSS-in-JS vs CSS-in-CSS](https://www.samsungsds.com/kr/insights/web_component.html)\n> - [CSS-in-JS, 무엇이 다른가요?](https://so-so.dev/web/css-in-js-whats-the-defference/)\n> - [[번역] CSS-in-JS에 관해 알아야 할 모든 것](https://d0gf00t.tistory.com/22)\n> - [What actually is CSS-in-JS?](https://medium.com/dailyjs/what-is-actually-css-in-js-f2f529a2757)\n","html":"<p><img src=\"/css/how-does-css-in-js-work/img/css-in-js.png\" alt=\"css-in-js\"></p>\n<p><a href=\"https://namu.wiki/w/%ED%8C%80%20%EB%B2%84%EB%84%88%EC%8A%A4%EB%A6%AC\">팀 버너스리</a>가 고안한 <a href=\"https://namu.wiki/w/%EC%9B%94%EB%93%9C%20%EC%99%80%EC%9D%B4%EB%93%9C%20%EC%9B%B9?from=%EC%9B%B9\">웹</a>이 등장한 이래로 많은 웹 기술들이 생기고 사라졌습니다. 하지만 여전히 <a href=\"https://namu.wiki/w/HTML\">HTML</a>은 우리에게 중요한 기술로 남아 있습니다. 또한 CSS 역시 웹 문서의 스타일을 꾸미기 위해 사용하는 강력한 기술입니다. 웹 개발자라면 HTML과 CSS로 이루어진 웹 문서에 대한 이해가 필수적일 것입니다. React, Vue 등 많은 프론트엔드 기술이 있지만 이것들 역시 더 효과적으로 웹 문서(또는 웹 페이지)를 만들기 위한 도구일 뿐이며 HTML, CSS를 대체할 수는 없습니다.</p>\n<p>저 역시 프론트엔드 개발에서 React를 주로 사용하지만 HTML과 CSS, Javascript를 이용한 가장 기본적인 부분을 알아야 할 필요를 많이 느낍니다. React를 사용하더라도 CSS를 적용하는 방법은 다양합니다. 그중 저는 <a href=\"https://mui.com\">MUI</a>, <a href=\"https://styled-components.com\">Styled-components</a> 등의 라이브러리를 사용하면서 CSS-in-JS를 주로 다루었습니다. 자바스크립트를 통해 동적인 CSS를 생성할 수 있는 <strong>CSS-in-JS</strong>는 개발자 경험(DX)을 만족스럽게 하면서도 여전히 흥미로운 기술입니다.</p>\n<h2 id=\"1-css-in-js\">1. CSS-in-JS</h2>\n<blockquote>\n<p>Cascading Style Sheets (CSS) is a stylesheet language used to describe the presentation of a document written in HTML or XML. (<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS\">MDN</a>)</p>\n</blockquote>\n<p>CSS는 스타일 시트 언어입니다. 순수 CSS만을 이용하여 웹 페이지의 모든 스타일을 적용하고 관리하기란 꽤 귀찮은 일이 아닐 수 없습니다. 그런 CSS를 보완하기 위해 여러 기술이 생겨났습니다. Sass, Less, Stylus 등의 CSS 전처리기 방식과 JSS, styled-components, emotion 등의 CSS-in-JS 방식 등이 있습니다.</p>\n<p>CSS-in-JS는 2014년 페이스북 개발자인 Christopher Chedeau aka Vjeux가 처음 <a href=\"http://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.html\">소개</a>하였습니다. Vjeux는 CSS를 작성하는 어려움을 다음과 같이 설명하였으며 CSS-in-JS로 이들 이슈를 모두 해결할 수 있다고 강조했습니다.</p>\n<blockquote>\n<ul>\n<li>Global namespace: 글로벌 공간에 선언된 이름의 명명 규칙 필요</li>\n<li>Dependencies: CSS 간의 의존 관계를 관리</li>\n<li>Dead Code Elimination: 미사용 코드 검출</li>\n<li>Minification: 클래스 이름의 최소화</li>\n<li>Sharing Constants: JS와 CSS의 상태 공유</li>\n<li>Non-deterministic Resolution: CSS 로드 우선순위 이슈</li>\n<li>Isolation: CSS와 JS의 상속에 따른 격리 필요 이슈</li>\n</ul>\n</blockquote>\n<p>CSS-in-JS는 말 그대로 자바스크립트로 작성한 CSS입니다. JS를 통해 생성되기 때문에 runtime에서 시트가 생성, 관리되며 프로그래밍 언어의 동적 특징을 이용할 수 있습니다. 사실 시트가 렌더링 되는 방식도 각 라이브러리마다 다릅니다. 여기서는 간단한 예제를 통해 CSS-in-JS 라이브러리가 어떤 식으로 CSS를 다루는 지 정도만 알아보겠습니다.</p>\n<h2 id=\"2-cssom-cssstylesheet\">2. CSSOM, CSSStyleSheet</h2>\n<p><img src=\"/css/how-does-css-in-js-work/img/npmtrends.png\" alt=\"CSS-in-JS on REACT\"></p>\n<blockquote>\n<p>예제 코드는 <code>React</code>에서 동작하는 <code>CSS-in-JS</code>를 살펴봅니다. 하지만 핵심 원리가 <code>React</code>에 의존하지는 않습니다.</p>\n</blockquote>\n<p>인기 있는 CSS-in-JS 라이브러리 중 <code>react-jss</code>, <code>styled-components</code>, <code>@emotion/css</code>을 이용해 코드를 작성해보고 CSS가 어떻게 생성되는지 직접 알아보겠습니다. 저는 <code>CRA</code>를 이용하여 리액트 환경을 구성하고 간단한 Task 관리 앱을 만들었습니다. 화면 결과는 따로 보여드리지 않고 생성된 <code>html</code> 태그와 <code>CSSOM</code> 객체에 정의된 스타일 시트를 확인하여 CSS가 어떻게 적용되는지 확인해보겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/App.jsx\nimport { useState } from &quot;react&quot;;\n\nimport Task from &quot;./Task&quot;;\n\nfunction App() {\n  const [tasks, setTasks] = useState([\n    { id: 1, title: &quot;대청소&quot;, done: false },\n    { id: 2, title: &quot;설거지&quot;, done: false },\n    { id: 3, title: &quot;빨래&quot;, done: false },\n    { id: 4, title: &quot;가출&quot;, done: false },\n  ]);\n\n  const handleDoneChange = (task) =&gt; () =&gt; {\n    task.done = !task.done;\n    setTasks([...tasks]);\n  };\n\n  console.log(document.styleSheets); // CSSOM 객체에 정의된 cssRule 확인\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;TASKER&lt;/h1&gt;\n      &lt;hr /&gt;\n      &lt;ul&gt;\n        {tasks.map((task) =&gt; (\n          &lt;Task\n            key={task.id}\n            title={task.title}\n            done={task.done}\n            onDoneChange={handleDoneChange(task)}\n          /&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre>\n<p>위에서 언급한 라이브러리를 이용하여 <code>Task</code> 컴포넌트를 작성하겠습니다. 먼저 <code>react-jss</code>의 <code>createUseStyles</code>를 이용합니다.</p>\n<pre><code class=\"language-jsx\">// src/Task.jsx\nimport { createUseStyles } from &quot;react-jss&quot;;\n\nconst useStyles = createUseStyles(() =&gt; ({\n  root: {\n    width: 500,\n    display: &quot;inline-block&quot;,\n  },\n  rootChecked: {\n    color: &quot;grey&quot;,\n    textDecoration: &quot;line-through&quot;,\n  },\n}));\n\nconst Task = (props) =&gt; {\n  const cls = useStyles(props);\n  const { title, done, onDoneChange } = props;\n  return (\n    // 완료 여부에 따라 조건부 클래스 적용\n    &lt;li className={[cls.root, done ? cls.rootChecked : &quot;&quot;].join(&quot; &quot;)}&gt;\n      &lt;input type=&quot;checkbox&quot; checked={done} onChange={onDoneChange} /&gt;\n      {title}\n    &lt;/li&gt;\n  );\n};\n\nexport default Task;\n</code></pre>\n<p><code>createUseStyles</code>를 이용하면 객체 형식으로 CSS를 작성합니다. 객체 속성 하나가 하나의 선택자로 매핑됩니다. 브라우저 개발자도구에서 <code>html</code>을 열어보면 <code>head</code> 태그 안에 <code>style</code> 태그가 생성된 것을 확인할 수 있습니다.</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/react-jss-html.png\" alt=\"screenshot\"></p>\n<p><code>console.log(document.styleSheets)</code> 코드에서 출력된 객체를 살펴보면 <code>1</code>개의 <code>CSSStyleSheet</code>가 생성되어 있습니다. <code>cssRules</code> 속성을 살펴보면 아래와 같이 <code>2</code>개의 <code>CSSStyleRule</code>이 생성되었습니다. 위 <code>style</code> 태그에서 생성된 각각의 선택자에 대한 스타일 룰이 이렇게 생성되어 있는 것입니다.</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/react-jss-cssom.png\" alt=\"screenshot\"></p>\n<p>여기에서 <code>Task</code>의 체크박스를 클릭하여 조건부 스타일이 적용되도록 해보겠습니다.</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/react-jss-condition-1-html.png\" alt=\"screenshot\"></p>\n<p>변경된 결과를 보면 이미 스타일은 생성되어 있고, <code>Element</code>에 <code>class</code>만 추가되어서 스타일이 적용되는 방식입니다. 이 과정에서 <code>style</code> 태그의 내용이나 <code>CSSStyleSheet</code>의 변경은 없었습니다.</p>\n<h2 id=\"3-props-기반-스타일-적용react-jss\">3. Props 기반 스타일 적용(react-jss)</h2>\n<p>위의 예제에서는 <code>done</code>의 값을 통해 클래스명을 추가하여서 스타일을 적용하는 방식을 이용했습니다. 이 방식은 미리 <strong>스타일 시트</strong>를 작성해두고, 조건적으로 적용할 것에 대해서만 결정할 수 있습니다.</p>\n<p>이번에는 이와 다르게 <code>CSS-in-JS</code>의 대부분 라이브러리가 제공하는 <code>props</code>를 기반으로 스타일을 생성하는 방식으로 구현해보겠습니다. 위의 예제에서 <code>useStyles</code> 함수의 구현을 수정합니다.</p>\n<pre><code class=\"language-jsx\">const useStyles = createUseStyles(() =&gt; ({\n  root: (props) =&gt; ({\n    width: 500,\n    display: &quot;inline-block&quot;,\n    color: props.done ? &quot;gray&quot; : &quot;inherit&quot;,\n    textDecoration: props.done ? &quot;line-through&quot; : &quot;inherit&quot;,\n  }),\n}));\n\nconst Task = (props) =&gt; {\n  const cls = useStyles(props);\n  const { title, done, onDoneChange } = props;\n  return (\n    &lt;li className={cls.root}&gt;\n      &lt;input type=&quot;checkbox&quot; checked={done} onChange={onDoneChange} /&gt;\n      {title}\n    &lt;/li&gt;\n  );\n};\n</code></pre>\n<p><code>useStyles</code>의 인자로 넘겨준 <code>props</code>를 스타일 시트 객체에서 함수의 파라미터로 가져와 참조할 수 있습니다. 이 방식으로 변경하면 <code>html</code> 태그와 <code>CSSStyleSheet</code>는 어떻게 다를까요?</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/react-jss-props-html.png\" alt=\"screenshot\"></p>\n<p>이전과는 다르게 <code>style</code> 태그에 <code>css</code>는 작성되어 있지 않습니다. 그리고 <code>Task</code> 컴포넌트에서 각 항목의 클래스를 다르게 주입하는 것을 볼 수 있습니다. 지금 예제에서는 <code>root-0-2-1</code>과 <code>root-d?-0-2-?</code>처럼 두 개씩 주입되어 있고 그중 하나는 각각 다른 클래스가 입력되어 있습니다.</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/react-jss-props-cssom.png\" alt=\"screenshot\"></p>\n<p><code>CSSStyleSheet</code>를 확인해보면 각 항목마다 다르게 주입된 클래스별로 <code>CSSStyleRule</code>이 생성된 것을 확인할 수 있습니다.</p>\n<p>이 상태에서 체크박스를 클릭하여 <code>props</code>를 이용한 조건부 스타일을 적용해보겠습니다.</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/react-jss-props-condition-cssom.png\" alt=\"screenshot\"></p>\n<p><code>li</code>태그의 클래스는 변경된 것이 없고, <code>props.done</code>으로 지정된 컴포넌트는 <code>CSSStyleRule</code>이 변경되었습니다.</p>\n<p>위 예제를 통해 확인할 수 있는 것은 <code>react-jss</code>의 경우 <code>props</code>에 의한 동적 스타일링을 할 때, 각 항목마다 다른 <code>class</code>와 <code>CSSStyleRule</code>를 생성하여 적용한다는 것입니다.</p>\n<h2 id=\"styled-components\">styled-components</h2>\n<p>이번에는 <code>styled-components</code>를 사용하여 같은 예제를 만들어 봅시다. <code>styled-components</code>는 <code>html</code> 태그에 <code>css</code>를 결합하여 리액트 컴포넌트로 만들어 사용합니다. <code>css</code>를 작성하기 위해서 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates\">Tagged templates</a> 문법을 사용할 수 있습니다. 만들어진 리액트 컴포넌트의 <code>props</code>를 이용해 동적인 스타일을 적용할 수 있습니다.</p>\n<p><code>Task</code> 컴포넌트를 아래와 같이 수정하겠습니다.</p>\n<pre><code class=\"language-jsx\">import styled from &quot;styled-components&quot;;\n\nconst ListItem = styled.li`\n  width: 500px;\n  display: inline-block;\n  color: ${({ done }) =&gt; (done ? &quot;gray&quot; : &quot;inherit&quot;)};\n  text-decoration: ${({ done }) =&gt; (done ? &quot;line-through&quot; : &quot;inherit&quot;)};\n`;\n\nconst Task = (props) =&gt; {\n  const { title, done, onDoneChange } = props;\n  return (\n    &lt;ListItem done={done}&gt;\n      &lt;input type=&quot;checkbox&quot; checked={done} onChange={onDoneChange} /&gt;\n      {title}\n    &lt;/ListItem&gt;\n  );\n};\n\nexport default Task;\n</code></pre>\n<p><code>html</code> 태그와 <code>CSSStyleSheet</code>를 살펴보겠습니다.</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/sc-html.png\" alt=\"screenshot\"></p>\n<p><img src=\"/css/how-does-css-in-js-work/img/sc-cssom.png\" alt=\"screenshot\"></p>\n<p><code>react-jss</code>에서의 첫 결과와 비슷하게, 하나의 <code>CSSStyleRule</code>이 생성되고 그것이 각 <code>li</code> 태그에 같게 적용되어 있습니다. 이제 체크박스를 클릭해 조건부 스타일을 적용해보겠습니다.</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/sc-condition-html.png\" alt=\"screenshot\"></p>\n<p><img src=\"/css/how-does-css-in-js-work/img/sc-condition-cssom.png\" alt=\"screenshot\"></p>\n<p><code>html</code>에서의 변경은 <code>css</code>가 생성되고 <code>li</code> 태그의 클래스가 변경되었습니다. <code>CSSStyleSheet</code>의 변경은 <code>CSSStyleRule</code>이 추가로 생성되었습니다.</p>\n<p>이 예제를 통해 확인할 수 있는 것은 <code>styled-components</code>는 필요한 <code>css</code>를 생성해서 사용하고, <code>props</code>에 의한 동적인 스타일에서는 런타임에서 <code>css</code>(<code>CSSStyleRule</code>)을 생성하여 사용한다는 것을 알 수 있습니다. <code>props.done</code> 값 하나만 사용할 때는 <code>2</code>개의 <code>CSSStyleRule</code>이 생성되었지만, 만약 다른 <code>props</code>를 이용한다면 더 많은 <code>CSSStyleRule</code>이 생성될 것입니다.</p>\n<h2 id=\"emotioncss\">@emotion/css</h2>\n<p>이번에는 <code>@emotion/css</code>를 이용하여 같은 실험을 해보겠습니다. <code>Task</code> 컴포넌트를 아래와 같이 수정합니다.</p>\n<pre><code class=\"language-jsx\">import { css } from &quot;@emotion/css&quot;;\n\nconst Task = (props) =&gt; {\n  const { title, done, onDoneChange } = props;\n  return (\n    &lt;div\n      className={css`\n        width: 500px;\n        display: inline-block;\n        color: ${done ? &quot;gray&quot; : &quot;inherit&quot;};\n        text-decoration: ${done ? &quot;line-through&quot; : &quot;inherit&quot;};\n      `}\n    &gt;\n      &lt;input type=&quot;checkbox&quot; checked={done} onChange={onDoneChange} /&gt;\n      {title}\n    &lt;/div&gt;\n  );\n};\n\nexport default Task;\n</code></pre>\n<p><code>html</code>과 <code>CSSStyleSheet</code>를 봅시다.</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/emotion-html.png\" alt=\"screenshot\"></p>\n<p><img src=\"/css/how-does-css-in-js-work/img/emotion-cssom.png\" alt=\"screenshot\"></p>\n<p>이전 라이브러리와 다르지 않은 결과입니다. 바로 체크박스를 클릭해 동적인 스타일을 적용해보겠습니다.</p>\n<p><img src=\"/css/how-does-css-in-js-work/img/emotion-props-html.png\" alt=\"screenshot\"></p>\n<p><img src=\"/css/how-does-css-in-js-work/img/emotion-props-cssom.png\" alt=\"screenshot\"></p>\n<p><code>html</code>의 결과를 살펴보면 다른 라이브러리와는 다르게 <code>style</code>태그가 <code>2</code>개가 되었습니다. 또한 <code>CSSStyleRule</code>이 추가된 것이 아닌 <code>CSSStyleSheet</code>가 추가된 것을 볼 수 있습니다.</p>\n<h2 id=\"마무리\">마무리</h2>\n<p>CSS-in-JS의 여러 라이브러리를 직접 사용해보면서 어떤 방식으로 <code>css</code>를 적용하는지 살펴보았습니다. 라이브러리들의 내부적인 상세한 구현은 모르지만 <code>cssom</code>을 조작하여 스타일을 적용한다는 것을 예제를 통해 확인할 수 있었습니다. 또한 흥미로웠던 것은 라이브러리마다 <code>cssom</code>을 조작하는 방식이 다르다는 것입니다. <code>CSSStyleRule</code>을 <strong>생성</strong>하는 방식과 <strong>변경</strong>하는 방식 중에서 상황에 따라 적합한 방식을 선택하는 것도 생각해볼 만한 구현 디테일인 것 같습니다.</p>\n<p>최근 <a href=\"https://mui.com\">MUIv5</a>가 발표되면서 <code>CSS-in-JS</code> 엔진에 대한 이야기(<a href=\"https://mui.com/blog/mui-core-v5/#migration-from-jss-to-emotion\">Migration from JSS to emotion</a>)를 개인적으로는 인상 깊게 읽었었는데, 디테일한 전략과 구현에 대해 살펴보아도 재밌을 것 같습니다.</p>\n<blockquote>\n<p>예제 코드는 <a href=\"https://github.com/hoontae24/blog-examples/tree/main/react/how-does-css-in-js-work\">Github</a>에서 확인할 수 있습니다.</p>\n</blockquote>\n<blockquote>\n<p>이 글을 작성하면서 아래의 글에 도움을 받았습니다.</p>\n<ul>\n<li><a href=\"https://www.samsungsds.com/kr/insights/web_component.html\">웹 컴포넌트 스타일링 관리: CSS-in-JS vs CSS-in-CSS</a></li>\n<li><a href=\"https://so-so.dev/web/css-in-js-whats-the-defference/\">CSS-in-JS, 무엇이 다른가요?</a></li>\n<li><a href=\"https://d0gf00t.tistory.com/22\">[번역] CSS-in-JS에 관해 알아야 할 모든 것</a></li>\n<li><a href=\"https://medium.com/dailyjs/what-is-actually-css-in-js-f2f529a2757\">What actually is CSS-in-JS?</a></li>\n</ul>\n</blockquote>\n","excerpt":"자바스크립트를 이용하여 스타일을 적용할 수 있는 CSS-in-JS가 어떻게 동작하는지 알아보겠습니다. 또 CSS-in-JS를 구현한 라이브러리마다 어떤 차이가 있는지 비교해보겠습니다. 팀 버너스리가 고안한 웹이 등장한 이래로 많은 웹 기술들이 생기고 사라졌습니다. 하지만 여전히 HTML은 우리에게 중요한 기술로 남아 있습니다. 또한 CSS 역시 웹 문서의 스타일을 꾸미기 위해 사용하는 강력한 기술입니다. 웹 개발자라면 HTML과 CSS로 이루어진 웹 문서에 대한 이해가 필수적일 것입니다. React, Vue 등 많은 프론트엔드 기술이 있","thumbnail":"/css/how-does-css-in-js-work/img/css-in-js.png","thumbnailUrl":"https://hoontae24.github.io/css/how-does-css-in-js-work/img/css-in-js.png"},{"href":"15","round":15,"paths":["test","why-test-codes"],"slug":"why-test-codes","title":"실전에서 느낀 테스트 코드가 필요한 이유","description":"","date":"2021-09-10","category":"test","tags":["test"],"seriesId":null,"markdown":"\n소프트웨어 개발 과정에서는 많은 변화가 있습니다. 특히 프로젝트 초반에는 기획과 설계, 데이터 구조가 변경되는 일이 잦기 때문에 유연한 코드를 작성하는 것이 중요합니다. 또한 좋은 코드를 작성하는 것에 관해서 이야기할 때, 테스트 코드는 개발자들 사이에서 빠지지 않고 거론되며 거의 필수적이라고 여겨지는 것 같습니다. 하지만 아쉽게도 현시점의 제가 일하는 팀에서는 프로젝트 수준에서의 테스트 코드를 작성하지는 않고 있습니다.\n\n최근에 새로운 **테스트 코드 없는 프로젝트**를 시작하게 되었는데, 그 과정에서 초기 개발 이후 기능과 데이터 구조를 수정하는 일을 진행하면서 테스트 코드가 왜 필요한지 직접 느낀 것들을 이야기해보겠습니다.\n\n## 1. 코드가 제대로 동작하는지 확인하고 싶다\n\n처음 기능을 개발할 때에는 코드가 동작하는지 직접 확인하는 것이 크게 피로하지 않습니다. 그런데 수정사항이 생겨서 코드를 수정하고 나면 같은 기능을 테스트하는 것이 매우 귀찮은 일이 됩니다. 특히 이것이 단순히 버튼 하나, 인풋 하나가 아니라 연계된 기능이 많다면 더 복잡할 것입니다. 또한, 코드를 작성하고 몇 주, 몇 달이 지나면 코드에 대한 기억이 거의 사라지고 없기 때문에 어떤 부분을 테스트해야 할지도 어려워집니다.\n\n특정 기능을 구현한 코드에 대한 명세 문서가 있고, 그 문서가 잘 최신화되어 관리된다면 조금 수월하겠지만 그것 또한 매우 피로한 일입니다. 테스트 코드는 기능 코드의 가장 가까운 곳에서 가장 비슷한 언어로 쓰인 코드의 명세입니다. 테스트 코드만 잘 작성했다면 작성한 함수, 클래스, 인터페이스 등의 코드가 어떤 역할과 기능을 하는지 파악하기는 아주 쉬워집니다.\n\n## 2. 기획 변경에 대해서 어떤 코드를 수정해야 할 지 모르겠다\n\n앞에서 말한 것처럼 테스트 코드의 역할 중 하나는 기능 코드 맥락을 표현해주는 것입니다. 테스트 코드를 보면 변경될 기획에 대해서 어떤 코드를 고쳐야 할 지 쉽게 알 수 있습니다. 특히 이 부분은 테스트 케이스에 대한 리포트 시각화 도구가 있다면 더욱더 쉬울 것입니다. 테스트 케이스를 통해 코드가 어떤 동작을 하는지, 기능을 고치고 싶으면 어떤 부분을 고치면 될 지를 한눈에 볼 수 있기 때문입니다.\n\n## 3. 코드에 대한 의존성을 분리하고 싶다\n\n기능 코드는 여러 코드와 복합적으로 동작할 때가 많습니다. 그래서 의존성을 잘 다루는 것도 개발자가 해야 할 일 중 하나일 것입니다. 테스트 코드를 작성하면 기능 코드의 의존성을 쉽게 파악하고 분리할 수 있습니다. 테스트 케이스 환경에서는 같은 입력에 대해서는 같은 결과가 나와야 의미 있는 테스트입니다. 그렇게 하려면 기능 코드의 의존성을 제거하고 외부에서 주입하는 형태로 코드를 작성할 수 밖에 없습니다. 테스트 케이스 환경에서 그러한 의존성을 주입하여서 기능 코드의 의존성을 제어하는 것입니다.\n\n신뢰할만한 테스트 코드를 작성하려면 기능 코드의 의존성을 파악하고, 테스트 환경에서 의존성을 주입하거나 적어도 제어할 수 있는 방식으로 기능 코드를 작성하게 될 것입니다.\n\n## 4. 이런 일들을 자동화하고 싶다\n\n개발자들이 가장 싫어하는 것 중 하나가 바로 중복이겠죠? 위에서 언급한 것들을 코드가 변경될 때마다, 또는 시간이 지나서 코드를 다시 살펴볼 때마다 생각하려면 너무 피곤한 일이 되어버립니다. 그래서 테스트 코드를 작성하고 테스트 케이스를 관리하여 이미 작성된 코드가 여전히 잘 동작하는지를 언제든지 확인할 수 있습니다. 테스트 케이스는 마치 **문서의 목차**나 **제품의 설명서**처럼 코드가 여전히 살아있는지 알 수 있는 도구입니다.\n\n개발자의 일 중 하나가 바로 자동화와 추상화 - 전등을 켜기 위해 전기선을 연결하는 일을 스위치로 대신하는 것, 시간마다 울려야 할 종을 자동으로 제시간에 울리게 하는 것 등 - 입니다. 저는 개발이 즐거운 이유가 이것들 때문이라고 생각하는데요, 제가 작성한 코드를 더욱더 즐겁게 하려면 테스트 코드가 필수이지 않을까요?\n\n## 마치며\n\n여러 개발 문화 중에서 테스트 코드, TDD에 대한 필요성이 뜨겁게 대두되고 있는 요즘이지만 아직 시도하지 못하고 있었는데요. 이번 프로젝트를 진행하면서 느낀 것은 불필요한 반복적인 일을 하지 않고 즐겁게 코드를 작성하고 싶다는 것입니다. 테스트 코드를 작성하는 트렌디하고 능력 있는 개발자가 되기 위해서라는 멋진 생각은 아니지만 단순히 남들 다 하기 때문에 하는게 아니라 정말 개발자와 팀을 위한 코드를 작성하기 위해 테스트 코드가 필요하다는 것을 절실히 느껴버렸습니다.\n","html":"<p>소프트웨어 개발 과정에서는 많은 변화가 있습니다. 특히 프로젝트 초반에는 기획과 설계, 데이터 구조가 변경되는 일이 잦기 때문에 유연한 코드를 작성하는 것이 중요합니다. 또한 좋은 코드를 작성하는 것에 관해서 이야기할 때, 테스트 코드는 개발자들 사이에서 빠지지 않고 거론되며 거의 필수적이라고 여겨지는 것 같습니다. 하지만 아쉽게도 현시점의 제가 일하는 팀에서는 프로젝트 수준에서의 테스트 코드를 작성하지는 않고 있습니다.</p>\n<p>최근에 새로운 <strong>테스트 코드 없는 프로젝트</strong>를 시작하게 되었는데, 그 과정에서 초기 개발 이후 기능과 데이터 구조를 수정하는 일을 진행하면서 테스트 코드가 왜 필요한지 직접 느낀 것들을 이야기해보겠습니다.</p>\n<h2 id=\"1-코드가-제대로-동작하는지-확인하고-싶다\">1. 코드가 제대로 동작하는지 확인하고 싶다</h2>\n<p>처음 기능을 개발할 때에는 코드가 동작하는지 직접 확인하는 것이 크게 피로하지 않습니다. 그런데 수정사항이 생겨서 코드를 수정하고 나면 같은 기능을 테스트하는 것이 매우 귀찮은 일이 됩니다. 특히 이것이 단순히 버튼 하나, 인풋 하나가 아니라 연계된 기능이 많다면 더 복잡할 것입니다. 또한, 코드를 작성하고 몇 주, 몇 달이 지나면 코드에 대한 기억이 거의 사라지고 없기 때문에 어떤 부분을 테스트해야 할지도 어려워집니다.</p>\n<p>특정 기능을 구현한 코드에 대한 명세 문서가 있고, 그 문서가 잘 최신화되어 관리된다면 조금 수월하겠지만 그것 또한 매우 피로한 일입니다. 테스트 코드는 기능 코드의 가장 가까운 곳에서 가장 비슷한 언어로 쓰인 코드의 명세입니다. 테스트 코드만 잘 작성했다면 작성한 함수, 클래스, 인터페이스 등의 코드가 어떤 역할과 기능을 하는지 파악하기는 아주 쉬워집니다.</p>\n<h2 id=\"2-기획-변경에-대해서-어떤-코드를-수정해야-할-지-모르겠다\">2. 기획 변경에 대해서 어떤 코드를 수정해야 할 지 모르겠다</h2>\n<p>앞에서 말한 것처럼 테스트 코드의 역할 중 하나는 기능 코드 맥락을 표현해주는 것입니다. 테스트 코드를 보면 변경될 기획에 대해서 어떤 코드를 고쳐야 할 지 쉽게 알 수 있습니다. 특히 이 부분은 테스트 케이스에 대한 리포트 시각화 도구가 있다면 더욱더 쉬울 것입니다. 테스트 케이스를 통해 코드가 어떤 동작을 하는지, 기능을 고치고 싶으면 어떤 부분을 고치면 될 지를 한눈에 볼 수 있기 때문입니다.</p>\n<h2 id=\"3-코드에-대한-의존성을-분리하고-싶다\">3. 코드에 대한 의존성을 분리하고 싶다</h2>\n<p>기능 코드는 여러 코드와 복합적으로 동작할 때가 많습니다. 그래서 의존성을 잘 다루는 것도 개발자가 해야 할 일 중 하나일 것입니다. 테스트 코드를 작성하면 기능 코드의 의존성을 쉽게 파악하고 분리할 수 있습니다. 테스트 케이스 환경에서는 같은 입력에 대해서는 같은 결과가 나와야 의미 있는 테스트입니다. 그렇게 하려면 기능 코드의 의존성을 제거하고 외부에서 주입하는 형태로 코드를 작성할 수 밖에 없습니다. 테스트 케이스 환경에서 그러한 의존성을 주입하여서 기능 코드의 의존성을 제어하는 것입니다.</p>\n<p>신뢰할만한 테스트 코드를 작성하려면 기능 코드의 의존성을 파악하고, 테스트 환경에서 의존성을 주입하거나 적어도 제어할 수 있는 방식으로 기능 코드를 작성하게 될 것입니다.</p>\n<h2 id=\"4-이런-일들을-자동화하고-싶다\">4. 이런 일들을 자동화하고 싶다</h2>\n<p>개발자들이 가장 싫어하는 것 중 하나가 바로 중복이겠죠? 위에서 언급한 것들을 코드가 변경될 때마다, 또는 시간이 지나서 코드를 다시 살펴볼 때마다 생각하려면 너무 피곤한 일이 되어버립니다. 그래서 테스트 코드를 작성하고 테스트 케이스를 관리하여 이미 작성된 코드가 여전히 잘 동작하는지를 언제든지 확인할 수 있습니다. 테스트 케이스는 마치 <strong>문서의 목차</strong>나 <strong>제품의 설명서</strong>처럼 코드가 여전히 살아있는지 알 수 있는 도구입니다.</p>\n<p>개발자의 일 중 하나가 바로 자동화와 추상화 - 전등을 켜기 위해 전기선을 연결하는 일을 스위치로 대신하는 것, 시간마다 울려야 할 종을 자동으로 제시간에 울리게 하는 것 등 - 입니다. 저는 개발이 즐거운 이유가 이것들 때문이라고 생각하는데요, 제가 작성한 코드를 더욱더 즐겁게 하려면 테스트 코드가 필수이지 않을까요?</p>\n<h2 id=\"마치며\">마치며</h2>\n<p>여러 개발 문화 중에서 테스트 코드, TDD에 대한 필요성이 뜨겁게 대두되고 있는 요즘이지만 아직 시도하지 못하고 있었는데요. 이번 프로젝트를 진행하면서 느낀 것은 불필요한 반복적인 일을 하지 않고 즐겁게 코드를 작성하고 싶다는 것입니다. 테스트 코드를 작성하는 트렌디하고 능력 있는 개발자가 되기 위해서라는 멋진 생각은 아니지만 단순히 남들 다 하기 때문에 하는게 아니라 정말 개발자와 팀을 위한 코드를 작성하기 위해 테스트 코드가 필요하다는 것을 절실히 느껴버렸습니다.</p>\n","excerpt":" 소프트웨어 개발 과정에서는 많은 변화가 있습니다. 특히 프로젝트 초반에는 기획과 설계, 데이터 구조가 변경되는 일이 잦기 때문에 유연한 코드를 작성하는 것이 중요합니다. 또한 좋은 코드를 작성하는 것에 관해서 이야기할 때, 테스트 코드는 개발자들 사이에서 빠지지 않고 거론되며 거의 필수적이라고 여겨지는 것 같습니다. 하지만 아쉽게도 현시점의 제가 일하는 팀","thumbnail":"","thumbnailUrl":"https://hoontae24.github.io"},{"href":"14","round":14,"paths":["react","react-ref-props"],"slug":"react-ref-props","title":"React 컴포넌트에 ref props 전달하기 (feat. forwardRef, useImperativeHandle)","description":"","date":"2021-08-18","category":"react","tags":["react","frontend"],"seriesId":null,"markdown":"\n![react ref props](/react/react-ref-props/img/react-ref-props.png)\n\nReact에서 `ref` 속성(props)이 가장 많이 사용하는 용도는 `DOM` 엘리먼트를 참조하는 경우일 것입니다. HTML 엘리먼트에 대해 `ref`를 `props`로 넘겨주어 `DOM` 엘리먼트를 담거나, 콜백 함수를 넘겨주어 `DOM` 엘리먼트를 매개변수로 접근할 수 있습니다. 하지만 `ref`의 기능은 그것뿐만이 아닙니다.\n\n> Refs provide a way to access DOM nodes or React elements created in the render method.\\\n> [공식문서(en)](https://reactjs.org/docs/refs-and-the-dom.html) [공식문서(ko)](https://ko.reactjs.org/docs/refs-and-the-dom.html)\n\n리액트 공식문서에서는 ref를 통해 DOM 노드뿐만 아니라 React 엘리먼트(DOM 노드 포함)에 접근할 수 있다고 말합니다. 이번 포스트에서는 React 엘리먼트를 다루는 `ref` 속성에 대해 알아보겠습니다.\n\n---\n\n## DOM 조작을 위한 ref 전달\n\n```jsx\nimport { useEffect, useRef } from \"react\"\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(inputRef) // { current: <input type=\"text\"> }\n  })\n\n  return (\n    <div>\n      <input ref={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n기본적으로 `jsx`로 DOM 엘리먼트를 작성할 때 `useRef`로 호출된 값을 `ref` 속성으로 넘겨주면 해당 `ref` 객체에 DOM 엘리먼트가 할당됩니다. 만약 `input`을 구현하는 컴포넌트 내부의 DOM 엘리먼트에 접근하려면 어떻게 해야 할까요? 다음 코드처럼 컴포넌트를 작성합니다.\n\n```jsx\nimport { useEffect, useRef } from \"react\"\n\nfunction MyInput(props) {\n  const { ref } = props\n\n  useEffect(() => {\n    console.log(\"ref:\", ref) // ref: undefined\n  })\n\n  return <input ref={ref} />\n}\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(\"inputRef:\", inputRef) // inputRef: { current: undefined }\n  })\n\n  return (\n    <div>\n      <MyInput ref={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n직접 작성한 `MyInput` 컴포넌트에 `ref` 속성으로 ref 객체를 전달했음에도 `MyInput` 컴포넌트 내부에서는 `ref`라는 이름으로 전달된 `props`가 `undefined`로 전달되는 것을 확인할 수 있습니다. 공식문서에서 말하는 것처럼 `ref` 속성은 `DOM 엘리먼트`나 `React 엘리먼트`를 참조하기 위한 속성이기 때문입니다.([Special Props Warning](https://reactjs.org/warnings/special-props.html))\n\n컴포넌트 내부의 엘리먼트를 참조하기 위해서는 어떻게 해야 할까요?\n\n### 1. `ref`가 아닌 `inputRef` 속성으로 전달\n\n`ref`는 컴포넌트 `props` 중에서 일종의 예약어이기 때문에 사용할 수 없습니다. 그래서 다른 이름의 `props`로 전달하면 됩니다.\n\n```jsx\nimport { useEffect, useRef } from \"react\"\n\nfunction MyInput(props) {\n  const { myInputRef } = props\n\n  useEffect(() => {\n    console.log(\"myInputRef:\", myInputRef) // myInputRef: {current: <input type=\"text\">}\n  })\n\n  return <input ref={myInputRef} />\n}\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(\"inputRef:\", inputRef) // inputRef: {current: <input type=\"text\">}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    <div>\n      <MyInput myInputRef={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n컴포넌트에 전달하는 `props`의 이름만 바꾸는 것으로 `ref` 객체를 전달하여 컴포넌트 내부의 엘리먼트에 접근할 수 있습니다. 하지만 이렇게 컴포넌트를 작성하게 되면 `input` 엘리먼트와 거의 비슷한 역할을 `MyInput` 컴포넌트가 수행함에도 약간의 다른 사용법을 제공하는 꼴이 됩니다. 이것은 일관적이지 않게 보일 수 있습니다. (`input` 엘리먼트에 접근하기 위해서 `ref`가 아닌 `inputRef` `props`를 전달해야 함.)\n\n### 2. forwardRef 사용하기\n\nReact에서는 `ref`를 그대로 전달하는 컴포넌트를 작성할 수 있게 도움을 줍니다. 컴포넌트를 `forwardRef`로 감싸주면 됩니다.\n\n```jsx\nimport { forwardRef, useEffect, useRef } from \"react\"\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  useEffect(() => {\n    console.log(\"forwardedRef:\", forwardedRef) // forwardedRef: {current: <input type=\"text\">}\n  })\n\n  return <input ref={forwardedRef} />\n})\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(\"inputRef:\", inputRef) // inputRef: {current: <input type=\"text\">}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    <div>\n      <MyInput ref={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n`forwardRef`함수에 함수형 컴포넌트 형태의 함수를 매개변수로 넣습니다. 이때, 두 번째 인자로 부모에게서 `ref` 속성으로 전달된 ref 객체가 전달됩니다.\n\n만약 `MyInput` 컴포넌트가 클래스 컴포넌트로 작성되었다면, 두 방식을 조합하여 `ref`를 전달할 수 있습니다.\n\n```jsx\nimport { Component, forwardRef, useEffect, useRef } from \"react\"\n\nclass MyInputWithInputRef extends Component {\n  componentDidMount() {\n    console.log(\"myInputRef:\", this.props.myInputRef) // myInputRef: {current: <input type=\"text\">}\n  }\n\n  render() {\n    const { myInputRef } = this.props\n    return <input ref={myInputRef} />\n  }\n}\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  useEffect(() => {\n    console.log(\"forwardedRef:\", forwardedRef) // forwardedRef: {current: <input type=\"text\">}\n  })\n\n  return <MyInputWithInputRef myInputRef={forwardedRef} />\n})\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() => {\n    console.log(\"inputRef:\", inputRef) // inputRef: {current: <input type=\"text\">}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    <div>\n      <MyInput ref={inputRef} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n코드가 길어졌지만 `MyInput`을 사용하는 부분(`App` 컴포넌트)에서는 `MyInput` 컴포넌트가 어떤식으로 구현되어 있는지 알 필요가 없습니다. `<MyInput>`을 `<input>`으로 교체하더라도 아무 문제가 없을 것입니다. 이것은 **Input**의 역할을 하는 컴포넌트에 대한 일관성과 신뢰성을 부여하게 됩니다.\n\n---\n\n이제 속성(props)으로서의 `ref`에 대해 알아봅시다.\n\n## React 컴포넌트를 조작하기 위한 ref 전달\n\n`ref` 속성은 React Element를 참조하기 위한 접근 방법입니다. 이번에는 컴포넌트 수준의 React Element에 접근하는 `ref`를 다루어 보겠습니다.\n\n### 클래스 컴포넌트에 `ref` 전달하기\n\n```jsx\nimport { Component, createRef, useEffect, useRef } from \"react\"\n\nclass MyInput extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { value: \"\" }\n    this.inputRef = createRef()\n    this.focus = () => {\n      this.inputRef.current.focus()\n    }\n    this.reset = () => {\n      this.setState({ value: \"\" })\n    }\n  }\n\n  render() {\n    return (\n      <input\n        ref={this.inputRef}\n        value={this.state.value}\n        onChange={(e) => this.setState({ value: e.target.value })}\n      />\n    )\n  }\n}\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () => {\n    ref.current.reset() // MyInput 컴포넌트 내부의 state를 조작함\n  }\n\n  const handleFocus = () => {\n    ref.current.focus() // MyInput 컴포넌트 내부의 input 엘리먼트에 포커스 됨\n  }\n\n  useEffect(() => {\n    console.log(\"ref:\", ref) // ref: {current: MyInput}\n    handleFocus()\n  })\n\n  return (\n    <div>\n      <button onClick={handleReset}>reset</button>\n      <button onClick={handleFocus}>focus</button>\n      <br />\n      <MyInput ref={ref} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n클래스로 작성된 컴포넌트에 `ref` 속성을 전달하면 해당 클래스로부터 생성된 React 엘리먼트에 접근할 수 있습니다. 클래스의 속성이나 메서드에도 접근할 수 있고, state나 context에도 접근할 수 있습니다.(심지어 render 메소드까지)\\\n위의 예시 코드와 같이 하위 컴포넌트의 메서드를 통해 부모 컴포넌트가 자식 컴포넌트를 컨트롤할 수 있습니다.(하지만 이런 데이터, 이벤트 흐름을 리액트에서 권장하지는 않습니다.)\n\n### 함수 컴포넌트에 `ref` 전달하기\n\n```jsx\nimport { forwardRef, useEffect, useRef, useState } from \"react\"\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  const ref = useRef()\n  const [value, setValue] = useState(\"\")\n\n  useEffect(() => {\n    // 수동으로 ref 객체에 내부 메서드를 할당\n    forwardedRef.current = {\n      focus: () => {\n        ref.current.focus()\n      },\n      reset: () => {\n        setValue(\"\")\n      },\n    }\n  }, [forwardedRef])\n\n  return (\n    <input ref={ref} value={value} onChange={(e) => setValue(e.target.value)} />\n  )\n})\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () => {\n    if (ref.current) {\n      ref.current.reset()\n    }\n  }\n\n  const handleFocus = () => {\n    if (ref.current) {\n      ref.current.focus()\n    }\n  }\n\n  useEffect(() => {\n    console.log(\"ref:\", ref) // ref: {current: {focus: fn, reset: fn}}\n    handleFocus()\n  })\n\n  return (\n    <div>\n      <button onClick={handleReset}>reset</button>\n      <button onClick={handleFocus}>focus</button>\n      <br />\n      <MyInput ref={ref} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n함수 컴포넌트는 `ref` 속성으로 엘리먼트에 접근할 수 없기 때문에, `forwardRef`를 이용하여 `MyInput` 컴포넌트 내부로 ref 객체를 전달한 후에 수동으로 내부 동작을 할당해 줄 수 있습니다.\n\nReact Hooks 에서는 이와 같은 기능을 제공하는 `useImperativeHandle` 함수가 있습니다.\n\n```jsx\nimport {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\"\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  const ref = useRef()\n  const [value, setValue] = useState(\"\")\n\n  // hooks를 이용하여 ref 객체에 내부 메서드를 할당\n  useImperativeHandle(forwardedRef, () => ({\n    focus: () => ref.current.focus(),\n    reset: () => setValue(\"\"),\n  }))\n\n  return (\n    <input ref={ref} value={value} onChange={(e) => setValue(e.target.value)} />\n  )\n})\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () => {\n    if (ref.current) {\n      ref.current.reset()\n    }\n  }\n\n  const handleFocus = () => {\n    if (ref.current) {\n      ref.current.focus()\n    }\n  }\n\n  useEffect(() => {\n    console.log(\"ref:\", ref) // ref: {current: {focus: fn, reset: fn}}\n    handleFocus()\n  })\n\n  return (\n    <div>\n      <button onClick={handleReset}>reset</button>\n      <button onClick={handleFocus}>focus</button>\n      <br />\n      <MyInput ref={ref} />\n    </div>\n  )\n}\n\nexport default App\n```\n\n앞선 예시 코드에서 수동으로 ref 객체에 할당해주던 작업을 `useImperativeHandle` 함수로 대체하였습니다. `useImperativeHandle` 함수의 코드를 따라가보면 이렇게 구현되어 있습니다.\n\n```jsx\nfunction imperativeHandleEffect<T>(\n  create: () => T,\n  ref: {| current: T | null |} | ((inst: T | null) => mixed) | null | void\n) {\n  if (typeof ref === \"function\") {\n    const refCallback = ref\n    const inst = create()\n    refCallback(inst)\n    return () => {\n      refCallback(null)\n    }\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty(\"current\")) {\n        console.error(\n          \"Expected useImperativeHandle() first argument to either be a \" +\n            \"ref callback or React.createRef() object. Instead received: %s.\",\n          \"an object with keys {\" + Object.keys(refObject).join(\", \") + \"}\"\n        )\n      }\n    }\n    const inst = create()\n    refObject.current = inst\n    return () => {\n      refObject.current = null\n    }\n  }\n}\n```\n\n[Github React 저장소](https://github.com/facebook/react/blob/aa25824f3ebbdbbea01be48417f2f99251be1a12/packages/react-reconciler/src/ReactFiberHooks.old.js#L1512)\n\n실제 구현은 조금 더 복잡하지만, 핵심적인 부분은 앞서 수동으로 할당해주던 것과 꽤 비슷하네요.\n\n## 마무리\n\nDOM 엘리먼트를 참조하기 위해서 주로 `ref`를 이용합니다. 이번 글에서는 `ref` 객체가 아닌 React 엘리먼트의 **`ref` 속성**이 어떤 동작을 하는지 살펴봤습니다. 리액트를 사용하여 컴포넌트 단위로 UI를 구성하고 코드를 재사용하는 등등 프론트엔드 개발에서 편리한 점이 많은데요. 단순히 사용하는 것을 넘어 리액트가 어떻게 동작하는지 이해하면 더 잘 활용할 수 있을 것 같습니다. 이 글이 리액트의 동작을 이해하는데 도움이 되었기를 바랍니다.\n","html":"<p><img src=\"/react/react-ref-props/img/react-ref-props.png\" alt=\"react ref props\"></p>\n<p>React에서 <code>ref</code> 속성(props)이 가장 많이 사용하는 용도는 <code>DOM</code> 엘리먼트를 참조하는 경우일 것입니다. HTML 엘리먼트에 대해 <code>ref</code>를 <code>props</code>로 넘겨주어 <code>DOM</code> 엘리먼트를 담거나, 콜백 함수를 넘겨주어 <code>DOM</code> 엘리먼트를 매개변수로 접근할 수 있습니다. 하지만 <code>ref</code>의 기능은 그것뿐만이 아닙니다.</p>\n<blockquote>\n<p>Refs provide a way to access DOM nodes or React elements created in the render method.<br><a href=\"https://reactjs.org/docs/refs-and-the-dom.html\">공식문서(en)</a> <a href=\"https://ko.reactjs.org/docs/refs-and-the-dom.html\">공식문서(ko)</a></p>\n</blockquote>\n<p>리액트 공식문서에서는 ref를 통해 DOM 노드뿐만 아니라 React 엘리먼트(DOM 노드 포함)에 접근할 수 있다고 말합니다. 이번 포스트에서는 React 엘리먼트를 다루는 <code>ref</code> 속성에 대해 알아보겠습니다.</p>\n<hr>\n<h2 id=\"dom-조작을-위한-ref-전달\">DOM 조작을 위한 ref 전달</h2>\n<pre><code class=\"language-jsx\">import { useEffect, useRef } from &quot;react&quot;\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(inputRef) // { current: &lt;input type=&quot;text&quot;&gt; }\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;input ref={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>기본적으로 <code>jsx</code>로 DOM 엘리먼트를 작성할 때 <code>useRef</code>로 호출된 값을 <code>ref</code> 속성으로 넘겨주면 해당 <code>ref</code> 객체에 DOM 엘리먼트가 할당됩니다. 만약 <code>input</code>을 구현하는 컴포넌트 내부의 DOM 엘리먼트에 접근하려면 어떻게 해야 할까요? 다음 코드처럼 컴포넌트를 작성합니다.</p>\n<pre><code class=\"language-jsx\">import { useEffect, useRef } from &quot;react&quot;\n\nfunction MyInput(props) {\n  const { ref } = props\n\n  useEffect(() =&gt; {\n    console.log(&quot;ref:&quot;, ref) // ref: undefined\n  })\n\n  return &lt;input ref={ref} /&gt;\n}\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(&quot;inputRef:&quot;, inputRef) // inputRef: { current: undefined }\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;MyInput ref={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>직접 작성한 <code>MyInput</code> 컴포넌트에 <code>ref</code> 속성으로 ref 객체를 전달했음에도 <code>MyInput</code> 컴포넌트 내부에서는 <code>ref</code>라는 이름으로 전달된 <code>props</code>가 <code>undefined</code>로 전달되는 것을 확인할 수 있습니다. 공식문서에서 말하는 것처럼 <code>ref</code> 속성은 <code>DOM 엘리먼트</code>나 <code>React 엘리먼트</code>를 참조하기 위한 속성이기 때문입니다.(<a href=\"https://reactjs.org/warnings/special-props.html\">Special Props Warning</a>)</p>\n<p>컴포넌트 내부의 엘리먼트를 참조하기 위해서는 어떻게 해야 할까요?</p>\n<h3 id=\"1-ref가-아닌-inputref-속성으로-전달\">1. <code>ref</code>가 아닌 <code>inputRef</code> 속성으로 전달</h3>\n<p><code>ref</code>는 컴포넌트 <code>props</code> 중에서 일종의 예약어이기 때문에 사용할 수 없습니다. 그래서 다른 이름의 <code>props</code>로 전달하면 됩니다.</p>\n<pre><code class=\"language-jsx\">import { useEffect, useRef } from &quot;react&quot;\n\nfunction MyInput(props) {\n  const { myInputRef } = props\n\n  useEffect(() =&gt; {\n    console.log(&quot;myInputRef:&quot;, myInputRef) // myInputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n  })\n\n  return &lt;input ref={myInputRef} /&gt;\n}\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(&quot;inputRef:&quot;, inputRef) // inputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;MyInput myInputRef={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>컴포넌트에 전달하는 <code>props</code>의 이름만 바꾸는 것으로 <code>ref</code> 객체를 전달하여 컴포넌트 내부의 엘리먼트에 접근할 수 있습니다. 하지만 이렇게 컴포넌트를 작성하게 되면 <code>input</code> 엘리먼트와 거의 비슷한 역할을 <code>MyInput</code> 컴포넌트가 수행함에도 약간의 다른 사용법을 제공하는 꼴이 됩니다. 이것은 일관적이지 않게 보일 수 있습니다. (<code>input</code> 엘리먼트에 접근하기 위해서 <code>ref</code>가 아닌 <code>inputRef</code> <code>props</code>를 전달해야 함.)</p>\n<h3 id=\"2-forwardref-사용하기\">2. forwardRef 사용하기</h3>\n<p>React에서는 <code>ref</code>를 그대로 전달하는 컴포넌트를 작성할 수 있게 도움을 줍니다. 컴포넌트를 <code>forwardRef</code>로 감싸주면 됩니다.</p>\n<pre><code class=\"language-jsx\">import { forwardRef, useEffect, useRef } from &quot;react&quot;\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  useEffect(() =&gt; {\n    console.log(&quot;forwardedRef:&quot;, forwardedRef) // forwardedRef: {current: &lt;input type=&quot;text&quot;&gt;}\n  })\n\n  return &lt;input ref={forwardedRef} /&gt;\n})\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(&quot;inputRef:&quot;, inputRef) // inputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;MyInput ref={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p><code>forwardRef</code>함수에 함수형 컴포넌트 형태의 함수를 매개변수로 넣습니다. 이때, 두 번째 인자로 부모에게서 <code>ref</code> 속성으로 전달된 ref 객체가 전달됩니다.</p>\n<p>만약 <code>MyInput</code> 컴포넌트가 클래스 컴포넌트로 작성되었다면, 두 방식을 조합하여 <code>ref</code>를 전달할 수 있습니다.</p>\n<pre><code class=\"language-jsx\">import { Component, forwardRef, useEffect, useRef } from &quot;react&quot;\n\nclass MyInputWithInputRef extends Component {\n  componentDidMount() {\n    console.log(&quot;myInputRef:&quot;, this.props.myInputRef) // myInputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n  }\n\n  render() {\n    const { myInputRef } = this.props\n    return &lt;input ref={myInputRef} /&gt;\n  }\n}\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  useEffect(() =&gt; {\n    console.log(&quot;forwardedRef:&quot;, forwardedRef) // forwardedRef: {current: &lt;input type=&quot;text&quot;&gt;}\n  })\n\n  return &lt;MyInputWithInputRef myInputRef={forwardedRef} /&gt;\n})\n\nfunction App() {\n  const inputRef = useRef()\n\n  useEffect(() =&gt; {\n    console.log(&quot;inputRef:&quot;, inputRef) // inputRef: {current: &lt;input type=&quot;text&quot;&gt;}\n    inputRef.current.focus() // MyInput 컴포넌트의 input 엘리먼트에 focus 됨\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;MyInput ref={inputRef} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>코드가 길어졌지만 <code>MyInput</code>을 사용하는 부분(<code>App</code> 컴포넌트)에서는 <code>MyInput</code> 컴포넌트가 어떤식으로 구현되어 있는지 알 필요가 없습니다. <code>&lt;MyInput&gt;</code>을 <code>&lt;input&gt;</code>으로 교체하더라도 아무 문제가 없을 것입니다. 이것은 <strong>Input</strong>의 역할을 하는 컴포넌트에 대한 일관성과 신뢰성을 부여하게 됩니다.</p>\n<hr>\n<p>이제 속성(props)으로서의 <code>ref</code>에 대해 알아봅시다.</p>\n<h2 id=\"react-컴포넌트를-조작하기-위한-ref-전달\">React 컴포넌트를 조작하기 위한 ref 전달</h2>\n<p><code>ref</code> 속성은 React Element를 참조하기 위한 접근 방법입니다. 이번에는 컴포넌트 수준의 React Element에 접근하는 <code>ref</code>를 다루어 보겠습니다.</p>\n<h3 id=\"클래스-컴포넌트에-ref-전달하기\">클래스 컴포넌트에 <code>ref</code> 전달하기</h3>\n<pre><code class=\"language-jsx\">import { Component, createRef, useEffect, useRef } from &quot;react&quot;\n\nclass MyInput extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { value: &quot;&quot; }\n    this.inputRef = createRef()\n    this.focus = () =&gt; {\n      this.inputRef.current.focus()\n    }\n    this.reset = () =&gt; {\n      this.setState({ value: &quot;&quot; })\n    }\n  }\n\n  render() {\n    return (\n      &lt;input\n        ref={this.inputRef}\n        value={this.state.value}\n        onChange={(e) =&gt; this.setState({ value: e.target.value })}\n      /&gt;\n    )\n  }\n}\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () =&gt; {\n    ref.current.reset() // MyInput 컴포넌트 내부의 state를 조작함\n  }\n\n  const handleFocus = () =&gt; {\n    ref.current.focus() // MyInput 컴포넌트 내부의 input 엘리먼트에 포커스 됨\n  }\n\n  useEffect(() =&gt; {\n    console.log(&quot;ref:&quot;, ref) // ref: {current: MyInput}\n    handleFocus()\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={handleReset}&gt;reset&lt;/button&gt;\n      &lt;button onClick={handleFocus}&gt;focus&lt;/button&gt;\n      &lt;br /&gt;\n      &lt;MyInput ref={ref} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>클래스로 작성된 컴포넌트에 <code>ref</code> 속성을 전달하면 해당 클래스로부터 생성된 React 엘리먼트에 접근할 수 있습니다. 클래스의 속성이나 메서드에도 접근할 수 있고, state나 context에도 접근할 수 있습니다.(심지어 render 메소드까지)<br>위의 예시 코드와 같이 하위 컴포넌트의 메서드를 통해 부모 컴포넌트가 자식 컴포넌트를 컨트롤할 수 있습니다.(하지만 이런 데이터, 이벤트 흐름을 리액트에서 권장하지는 않습니다.)</p>\n<h3 id=\"함수-컴포넌트에-ref-전달하기\">함수 컴포넌트에 <code>ref</code> 전달하기</h3>\n<pre><code class=\"language-jsx\">import { forwardRef, useEffect, useRef, useState } from &quot;react&quot;\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  const ref = useRef()\n  const [value, setValue] = useState(&quot;&quot;)\n\n  useEffect(() =&gt; {\n    // 수동으로 ref 객체에 내부 메서드를 할당\n    forwardedRef.current = {\n      focus: () =&gt; {\n        ref.current.focus()\n      },\n      reset: () =&gt; {\n        setValue(&quot;&quot;)\n      },\n    }\n  }, [forwardedRef])\n\n  return (\n    &lt;input ref={ref} value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt;\n  )\n})\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () =&gt; {\n    if (ref.current) {\n      ref.current.reset()\n    }\n  }\n\n  const handleFocus = () =&gt; {\n    if (ref.current) {\n      ref.current.focus()\n    }\n  }\n\n  useEffect(() =&gt; {\n    console.log(&quot;ref:&quot;, ref) // ref: {current: {focus: fn, reset: fn}}\n    handleFocus()\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={handleReset}&gt;reset&lt;/button&gt;\n      &lt;button onClick={handleFocus}&gt;focus&lt;/button&gt;\n      &lt;br /&gt;\n      &lt;MyInput ref={ref} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>함수 컴포넌트는 <code>ref</code> 속성으로 엘리먼트에 접근할 수 없기 때문에, <code>forwardRef</code>를 이용하여 <code>MyInput</code> 컴포넌트 내부로 ref 객체를 전달한 후에 수동으로 내부 동작을 할당해 줄 수 있습니다.</p>\n<p>React Hooks 에서는 이와 같은 기능을 제공하는 <code>useImperativeHandle</code> 함수가 있습니다.</p>\n<pre><code class=\"language-jsx\">import {\n  forwardRef,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from &quot;react&quot;\n\nconst MyInput = forwardRef(function MyInput(props, forwardedRef) {\n  const ref = useRef()\n  const [value, setValue] = useState(&quot;&quot;)\n\n  // hooks를 이용하여 ref 객체에 내부 메서드를 할당\n  useImperativeHandle(forwardedRef, () =&gt; ({\n    focus: () =&gt; ref.current.focus(),\n    reset: () =&gt; setValue(&quot;&quot;),\n  }))\n\n  return (\n    &lt;input ref={ref} value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt;\n  )\n})\n\nfunction App() {\n  const ref = useRef()\n\n  const handleReset = () =&gt; {\n    if (ref.current) {\n      ref.current.reset()\n    }\n  }\n\n  const handleFocus = () =&gt; {\n    if (ref.current) {\n      ref.current.focus()\n    }\n  }\n\n  useEffect(() =&gt; {\n    console.log(&quot;ref:&quot;, ref) // ref: {current: {focus: fn, reset: fn}}\n    handleFocus()\n  })\n\n  return (\n    &lt;div&gt;\n      &lt;button onClick={handleReset}&gt;reset&lt;/button&gt;\n      &lt;button onClick={handleFocus}&gt;focus&lt;/button&gt;\n      &lt;br /&gt;\n      &lt;MyInput ref={ref} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nexport default App\n</code></pre>\n<p>앞선 예시 코드에서 수동으로 ref 객체에 할당해주던 작업을 <code>useImperativeHandle</code> 함수로 대체하였습니다. <code>useImperativeHandle</code> 함수의 코드를 따라가보면 이렇게 구현되어 있습니다.</p>\n<pre><code class=\"language-jsx\">function imperativeHandleEffect&lt;T&gt;(\n  create: () =&gt; T,\n  ref: {| current: T | null |} | ((inst: T | null) =&gt; mixed) | null | void\n) {\n  if (typeof ref === &quot;function&quot;) {\n    const refCallback = ref\n    const inst = create()\n    refCallback(inst)\n    return () =&gt; {\n      refCallback(null)\n    }\n  } else if (ref !== null &amp;&amp; ref !== undefined) {\n    const refObject = ref\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty(&quot;current&quot;)) {\n        console.error(\n          &quot;Expected useImperativeHandle() first argument to either be a &quot; +\n            &quot;ref callback or React.createRef() object. Instead received: %s.&quot;,\n          &quot;an object with keys {&quot; + Object.keys(refObject).join(&quot;, &quot;) + &quot;}&quot;\n        )\n      }\n    }\n    const inst = create()\n    refObject.current = inst\n    return () =&gt; {\n      refObject.current = null\n    }\n  }\n}\n</code></pre>\n<p><a href=\"https://github.com/facebook/react/blob/aa25824f3ebbdbbea01be48417f2f99251be1a12/packages/react-reconciler/src/ReactFiberHooks.old.js#L1512\">Github React 저장소</a></p>\n<p>실제 구현은 조금 더 복잡하지만, 핵심적인 부분은 앞서 수동으로 할당해주던 것과 꽤 비슷하네요.</p>\n<h2 id=\"마무리\">마무리</h2>\n<p>DOM 엘리먼트를 참조하기 위해서 주로 <code>ref</code>를 이용합니다. 이번 글에서는 <code>ref</code> 객체가 아닌 React 엘리먼트의 <strong><code>ref</code> 속성</strong>이 어떤 동작을 하는지 살펴봤습니다. 리액트를 사용하여 컴포넌트 단위로 UI를 구성하고 코드를 재사용하는 등등 프론트엔드 개발에서 편리한 점이 많은데요. 단순히 사용하는 것을 넘어 리액트가 어떻게 동작하는지 이해하면 더 잘 활용할 수 있을 것 같습니다. 이 글이 리액트의 동작을 이해하는데 도움이 되었기를 바랍니다.</p>\n","excerpt":" React에서 ref 속성(props)이 가장 많이 사용하는 용도는 DOM 엘리먼트를 참조하는 경우일 것입니다. HTML 엘리먼트에 대해 ref를 props로 넘겨주어 DOM 엘리먼트를 담거나, 콜백 함수를 넘겨주어 DOM 엘리먼트를 매개변수로 접근할 수 있습니다. 하지만 ref의 기능은 그것뿐만이 아닙니다.  Refs provide a way to acc","thumbnail":"/react/react-ref-props/img/react-ref-props.png","thumbnailUrl":"https://hoontae24.github.io/react/react-ref-props/img/react-ref-props.png"},{"href":"13","round":13,"paths":["javascript","javascript-performance-to-generate-dictionary"],"slug":"javascript-performance-to-generate-dictionary","title":"자바스크립트, 딕셔너리를 만드는 가장 빠른 방법은?","description":"","date":"2020-04-12","category":"javascript","tags":["javascript","data structure"],"seriesId":null,"markdown":"\n![js dictionary](/javascript/javascript-performance-to-generate-dictionary/img/js_dictionary.png)\n\n자바스크립트 개발을 하면서 여러가지 자료구조를 사용하게 됩니다. 가장 많이 쓰이는 것은 역시 `Array(배열)`이겠죠? 그리고 데이터에 맞게 `Object(객체)`를 만들어 사용하기도 합니다. `Prototype`을 이용하거나, `ES6`의 `Class` 문법을 통해 객체 생성자를 만들어 사용하기도 합니다.\n\n오늘 포스트에서 살펴볼 자료구조는 바로 `Dictionary`입니다. `Dictionary`는 자바스크립트에는 없는 자료형 이름인데, `Object(객체)`와 동일합니다. `key`, `value` 쌍으로 이루어진 객체를 통해 데이터를 취급하는 자료구조입니다. `파이썬`에서는 `Dictionary`라고 부르기도 하죠. 제가 `Dictionary`라고 부르는 이유는 바로 사용 목적에 있습니다. `key`를 이용하여 데이터를 취급하는 객체라는 것을 명시적으로 나타내기 위해 `Dictionary`라고 명명하도록 하겠습니다.\n\n---\n\n### 언제 사용할까?\n\n`Dictionary`는 언제 사용할까요? 여러가지 상황에서 사용할 수 있지만 오늘은 배열에 있는 항목을 `index`가 아닌 다른 값으로 접근하고자 할 때, `Dictionary`를 만들어 사용해 보도록 하겠습니다.\n\n먼저 다음과 같은 배열이 있다고 합시다.\n\n```js\nconst items = [\n  { id: 1, name: \"banana\" },\n  { id: 2, name: \"apple\" },\n  { id: 3, name: \"orange\" },\n  // ...\n];\n```\n\n`items`배열의 항목은 `index`를 이용하여 바로 접근할 수 있지만, `index`를 알지 못하고 `id`를 통해 접근해야 한다면 어떻게 할까요? 만약 배열이 크지 않거나, 자주 하는 작업이 아니라면 다음과 같이 할 수도 있을겁니다.\n\n```js\nconst itemId = 1;\nconst item = items.find((item) => item.id === itemId);\n```\n\n하지만 위 작업은 실행할 때 마다 `O(n)`의 시간복잡도를 가지게 됩니다. 이 작업이 반복된다면 꽤 부담스러울 수도 있습니다. 그래서 `id`를 `key`로 하는 딕셔너리를 만들어서 사용합니다. `items`를 딕셔너리로 만들면 다음과 같습니다.\n\n```js\n// item의 id를 key로 가지는 딕셔너리\nconst itemDict = {\n  1: { id: 1, name: \"banana\" },\n  2: { id: 2, name: \"apple\" },\n  3: { id: 3, name: \"orange\" },\n};\n```\n\n---\n\n### 딕셔너리 만들기\n\n딕셔너리를 만드는 방법은 아주 간단합니다. 객체를 만들고 `id`를 `key`로 하는 값을 할당해주면 됩니다.\n\n```js\nconst itemDict = {};\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n  itemDict[item.id] = item;\n}\n```\n\n간단한 반복 작업이기 때문에 `for`문이 아닌 다른 방법을 이용할 수도 있습니다. `items`의 항목이 많거나 각 항목이 복잡한 구조라면 딕셔너리를 만드는 것도 부담이 될 수 있습니다. 그래서 어떤 방법으로 딕셔너리를 만드는 것이 빠르고 적은 부담인지 알아보도록 하겠습니다.\n\n---\n\n### 여러가지 방법 비교해보기\n\n##### JSBen.ch 이용하기\n\n![JSBen.ch](/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch.png)\n\n[JSBen.ch](https://jsben.ch/)는 여러가지 케이스를 생성하여 비교해볼 수 있는 자바스크립트 벤치마킹 서비스입니다. **BROWSE** 탭을 열어보면 다른 벤치마크 테스트들을 볼 수 있습니다. 가장 views가 많은 **check object key**의 결과를 다음과 같이 한 눈에 볼 수 있습니다.\n\n![JSBen.ch](/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch_check_object_key.png)\n\n#### Setup Block 작성하기\n\n벤치마크에 사용될 기본적인 초기값을 설정해줍니다. 벤치마크 테스트에는 포함되지 않습니다. 딕셔너리로 만들 `items` 배열을 초기화해줍니다.\n\n```js\nconst itemCount = 100000;\nconst items = new Array(itemCount).fill(true).map((_, i) => {\n  return { id: i + 1, value: Math.random() };\n});\n```\n\n#### 테스트 케이스\n\n딕셔너리를 만드는 테스트 케이스를 각 코드블럭에 작성하겠습니다.\n\n##### 1. for\n\n```js\nconst result = {};\nfor (let i = 0; i < itemCount; i++) {\n  result[items[i].id] = items[i];\n}\n```\n\n##### 2. for in\n\n```js\nconst result = {};\nlet i;\nfor (i in items) {\n  result[items[i].id] = items[i];\n}\n```\n\n##### 3. for of\n\n```js\nconst result = {};\nlet item;\nfor (item of items) {\n  result[item.id] = item;\n}\n```\n\n##### 4. forEach\n\n```js\nconst result = {};\nitems.forEach((item) => (result[item.id] = item));\n```\n\n##### 5. reduce\n\n```js\nconst result = items.reduce((res, item) => {\n  res[item.id] = item;\n  return res;\n}, {});\n```\n\n##### 6. lodash keyBy / key-name\n\n```js\nconst result = _.keyBy(items, \"id\");\n```\n\n##### 7. lodash keyBy / key-callback\n\n```js\nconst result = _.keyBy(items, (item) => item.id);\n```\n\n#### 벤치마크 테스트하기\n\n이제 테스트 케이스가 작성했으니, 테스트를 실행해 보겠습니다. 다음과 같은 결과가 나왔습니다.\n\n![JSBen.ch](/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch_result_1.png)\n\n가장 단순한 `for`문이 가장 빠른 결과를 보여줍니다. `for in`문은 상대적으로 많이 느린 동작을 보여줍니다. `Array`의 메소드인 `forEach`와 `reduce`는 비슷한 속도를 가지고 있고, `lodash.keyBy`도 방식은 달라도 비슷한 속도를 보여줍니다.\n\n---\n\n### 마무리\n\n`Dictionary` 만들기라는 주제로 자바스크립트 반복문의 성능에 대해 간단히 알아보았습니다. 실제 개발을 할 때는 `for`문 보다 `reduce`나 `map`같이 `Array`메소드를 많이 활용하는데, 상황에 따라 필요한 것을 사용해야 할 것 같습니다. 간단한 작업이라면 성능을 많이 요구하지 않을테니 아무거나 사용해도 괜찮겠지만요.\n\n여기까지 구문에 따라 다른 성능을 보여주는 여러가지 반복문에 대해 알아보았습니다. 다음에 기회가 된다면 각 구문에 왜 다른 성능을 보여주는지, 어떤 상황에서 어떤 방법이 유리한 지 분석해보는 시간도 가져보겠습니다.\n","html":"<p><img src=\"/javascript/javascript-performance-to-generate-dictionary/img/js_dictionary.png\" alt=\"js dictionary\"></p>\n<p>자바스크립트 개발을 하면서 여러가지 자료구조를 사용하게 됩니다. 가장 많이 쓰이는 것은 역시 <code>Array(배열)</code>이겠죠? 그리고 데이터에 맞게 <code>Object(객체)</code>를 만들어 사용하기도 합니다. <code>Prototype</code>을 이용하거나, <code>ES6</code>의 <code>Class</code> 문법을 통해 객체 생성자를 만들어 사용하기도 합니다.</p>\n<p>오늘 포스트에서 살펴볼 자료구조는 바로 <code>Dictionary</code>입니다. <code>Dictionary</code>는 자바스크립트에는 없는 자료형 이름인데, <code>Object(객체)</code>와 동일합니다. <code>key</code>, <code>value</code> 쌍으로 이루어진 객체를 통해 데이터를 취급하는 자료구조입니다. <code>파이썬</code>에서는 <code>Dictionary</code>라고 부르기도 하죠. 제가 <code>Dictionary</code>라고 부르는 이유는 바로 사용 목적에 있습니다. <code>key</code>를 이용하여 데이터를 취급하는 객체라는 것을 명시적으로 나타내기 위해 <code>Dictionary</code>라고 명명하도록 하겠습니다.</p>\n<hr>\n<h3 id=\"언제-사용할까\">언제 사용할까?</h3>\n<p><code>Dictionary</code>는 언제 사용할까요? 여러가지 상황에서 사용할 수 있지만 오늘은 배열에 있는 항목을 <code>index</code>가 아닌 다른 값으로 접근하고자 할 때, <code>Dictionary</code>를 만들어 사용해 보도록 하겠습니다.</p>\n<p>먼저 다음과 같은 배열이 있다고 합시다.</p>\n<pre><code class=\"language-js\">const items = [\n  { id: 1, name: &quot;banana&quot; },\n  { id: 2, name: &quot;apple&quot; },\n  { id: 3, name: &quot;orange&quot; },\n  // ...\n];\n</code></pre>\n<p><code>items</code>배열의 항목은 <code>index</code>를 이용하여 바로 접근할 수 있지만, <code>index</code>를 알지 못하고 <code>id</code>를 통해 접근해야 한다면 어떻게 할까요? 만약 배열이 크지 않거나, 자주 하는 작업이 아니라면 다음과 같이 할 수도 있을겁니다.</p>\n<pre><code class=\"language-js\">const itemId = 1;\nconst item = items.find((item) =&gt; item.id === itemId);\n</code></pre>\n<p>하지만 위 작업은 실행할 때 마다 <code>O(n)</code>의 시간복잡도를 가지게 됩니다. 이 작업이 반복된다면 꽤 부담스러울 수도 있습니다. 그래서 <code>id</code>를 <code>key</code>로 하는 딕셔너리를 만들어서 사용합니다. <code>items</code>를 딕셔너리로 만들면 다음과 같습니다.</p>\n<pre><code class=\"language-js\">// item의 id를 key로 가지는 딕셔너리\nconst itemDict = {\n  1: { id: 1, name: &quot;banana&quot; },\n  2: { id: 2, name: &quot;apple&quot; },\n  3: { id: 3, name: &quot;orange&quot; },\n};\n</code></pre>\n<hr>\n<h3 id=\"딕셔너리-만들기\">딕셔너리 만들기</h3>\n<p>딕셔너리를 만드는 방법은 아주 간단합니다. 객체를 만들고 <code>id</code>를 <code>key</code>로 하는 값을 할당해주면 됩니다.</p>\n<pre><code class=\"language-js\">const itemDict = {};\nfor (let i = 0; i &lt; items.length; i++) {\n  const item = items[i];\n  itemDict[item.id] = item;\n}\n</code></pre>\n<p>간단한 반복 작업이기 때문에 <code>for</code>문이 아닌 다른 방법을 이용할 수도 있습니다. <code>items</code>의 항목이 많거나 각 항목이 복잡한 구조라면 딕셔너리를 만드는 것도 부담이 될 수 있습니다. 그래서 어떤 방법으로 딕셔너리를 만드는 것이 빠르고 적은 부담인지 알아보도록 하겠습니다.</p>\n<hr>\n<h3 id=\"여러가지-방법-비교해보기\">여러가지 방법 비교해보기</h3>\n<h5 id=\"jsbench-이용하기\">JSBen.ch 이용하기</h5>\n<p><img src=\"/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch.png\" alt=\"JSBen.ch\"></p>\n<p><a href=\"https://jsben.ch/\">JSBen.ch</a>는 여러가지 케이스를 생성하여 비교해볼 수 있는 자바스크립트 벤치마킹 서비스입니다. <strong>BROWSE</strong> 탭을 열어보면 다른 벤치마크 테스트들을 볼 수 있습니다. 가장 views가 많은 <strong>check object key</strong>의 결과를 다음과 같이 한 눈에 볼 수 있습니다.</p>\n<p><img src=\"/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch_check_object_key.png\" alt=\"JSBen.ch\"></p>\n<h4 id=\"setup-block-작성하기\">Setup Block 작성하기</h4>\n<p>벤치마크에 사용될 기본적인 초기값을 설정해줍니다. 벤치마크 테스트에는 포함되지 않습니다. 딕셔너리로 만들 <code>items</code> 배열을 초기화해줍니다.</p>\n<pre><code class=\"language-js\">const itemCount = 100000;\nconst items = new Array(itemCount).fill(true).map((_, i) =&gt; {\n  return { id: i + 1, value: Math.random() };\n});\n</code></pre>\n<h4 id=\"테스트-케이스\">테스트 케이스</h4>\n<p>딕셔너리를 만드는 테스트 케이스를 각 코드블럭에 작성하겠습니다.</p>\n<h5 id=\"1-for\">1. for</h5>\n<pre><code class=\"language-js\">const result = {};\nfor (let i = 0; i &lt; itemCount; i++) {\n  result[items[i].id] = items[i];\n}\n</code></pre>\n<h5 id=\"2-for-in\">2. for in</h5>\n<pre><code class=\"language-js\">const result = {};\nlet i;\nfor (i in items) {\n  result[items[i].id] = items[i];\n}\n</code></pre>\n<h5 id=\"3-for-of\">3. for of</h5>\n<pre><code class=\"language-js\">const result = {};\nlet item;\nfor (item of items) {\n  result[item.id] = item;\n}\n</code></pre>\n<h5 id=\"4-foreach\">4. forEach</h5>\n<pre><code class=\"language-js\">const result = {};\nitems.forEach((item) =&gt; (result[item.id] = item));\n</code></pre>\n<h5 id=\"5-reduce\">5. reduce</h5>\n<pre><code class=\"language-js\">const result = items.reduce((res, item) =&gt; {\n  res[item.id] = item;\n  return res;\n}, {});\n</code></pre>\n<h5 id=\"6-lodash-keyby--key-name\">6. lodash keyBy / key-name</h5>\n<pre><code class=\"language-js\">const result = _.keyBy(items, &quot;id&quot;);\n</code></pre>\n<h5 id=\"7-lodash-keyby--key-callback\">7. lodash keyBy / key-callback</h5>\n<pre><code class=\"language-js\">const result = _.keyBy(items, (item) =&gt; item.id);\n</code></pre>\n<h4 id=\"벤치마크-테스트하기\">벤치마크 테스트하기</h4>\n<p>이제 테스트 케이스가 작성했으니, 테스트를 실행해 보겠습니다. 다음과 같은 결과가 나왔습니다.</p>\n<p><img src=\"/javascript/javascript-performance-to-generate-dictionary/img/js_jsben.ch_result_1.png\" alt=\"JSBen.ch\"></p>\n<p>가장 단순한 <code>for</code>문이 가장 빠른 결과를 보여줍니다. <code>for in</code>문은 상대적으로 많이 느린 동작을 보여줍니다. <code>Array</code>의 메소드인 <code>forEach</code>와 <code>reduce</code>는 비슷한 속도를 가지고 있고, <code>lodash.keyBy</code>도 방식은 달라도 비슷한 속도를 보여줍니다.</p>\n<hr>\n<h3 id=\"마무리\">마무리</h3>\n<p><code>Dictionary</code> 만들기라는 주제로 자바스크립트 반복문의 성능에 대해 간단히 알아보았습니다. 실제 개발을 할 때는 <code>for</code>문 보다 <code>reduce</code>나 <code>map</code>같이 <code>Array</code>메소드를 많이 활용하는데, 상황에 따라 필요한 것을 사용해야 할 것 같습니다. 간단한 작업이라면 성능을 많이 요구하지 않을테니 아무거나 사용해도 괜찮겠지만요.</p>\n<p>여기까지 구문에 따라 다른 성능을 보여주는 여러가지 반복문에 대해 알아보았습니다. 다음에 기회가 된다면 각 구문에 왜 다른 성능을 보여주는지, 어떤 상황에서 어떤 방법이 유리한 지 분석해보는 시간도 가져보겠습니다.</p>\n","excerpt":" 자바스크립트 개발을 하면서 여러가지 자료구조를 사용하게 됩니다. 가장 많이 쓰이는 것은 역시 Array(배열)이겠죠? 그리고 데이터에 맞게 Object(객체)를 만들어 사용하기도 합니다. Prototype을 이용하거나, ES6의 Class 문법을 통해 객체 생성자를 만들어 사용하기도 합니다. 오늘 포스트에서 살펴볼 자료구조는 바로 Dictionary입니다.","thumbnail":"/javascript/javascript-performance-to-generate-dictionary/img/js_dictionary.png","thumbnailUrl":"https://hoontae24.github.io/javascript/javascript-performance-to-generate-dictionary/img/js_dictionary.png"},{"href":"12","round":12,"paths":["react","react-component-rerendering"],"slug":"react-component-rerendering","title":"리액트 컴포넌트 Rerendering 파헤치기","description":"","date":"2020-03-15","category":"react","tags":["react","frontend"],"seriesId":null,"markdown":"\n![react render props](/react/react-component-rerendering/img/react_render_props.png)\n\nReact는 웹 프론트엔드 라이브러리로 많이 사용되어지고 있습니다. 저 역시 리액트를 처음 접하고 업무 프로젝트로 사용한 지 1년 정도가 되었습니다. 라이브러리를 이용하여 개발을 하면 더 편하지만 알아야 할 것도 많이 생깁니다.\n\n리액트로 개발을 할 때, 컴포넌트의 **Rerendering**에 대해 고민하게 될 때가 있는데요. React는 화면의 변경 사항에 대해서 ReactDOM을 이용하여 변경된 부분에 대해서만 Rerendering(또는 Update)합니다. React의 [Lifecycle](https://ko.reactjs.org/docs/react-component.html#the-component-lifecycle)을 이해하면 Rerendering을 잘 고려해서 개발할 수 있습니다.\n\n오늘은 간단한 Phonebook을 구현하면서, ReactDOM의 업데이트를 관찰하고, 컴포넌트의 Rerendering에 대해서 살펴보겠습니다. 특히 불필요한 업데이트를 줄이는 방법에 대해 중점적으로 보려고 합니다.\n\n---\n\n### 0. 개발 환경 구성하기\n\n오늘 실습 개발 환경을 위해서 다음 두 가지가 필요합니다.\n\n1. [CRA(create-react-app)](https://github.com/facebook/create-react-app)\n2. [chrome 확장프로그램 React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n\n먼저 CRA를 이용하여 간단한 React App을 만듭니다. 그리고 실습에 사용될 몇가지 패키지를 설치하겠습니다.\n\n```bash\n$ npx create-react-app react-rerendering-test\n$ cd react-rerendering-test\n$ npm i lodash random-name @material-ui/core\n```\n\n`lodash`와 `random-name`은 샘플 데이터를 다루기 위해서 설치합니다. `@material-ui`는 `input`태그를 대신하여 사용할 `TextField`를 위해 설치합니다. 또한 실제 업무에서도 html 태그가 아닌 UI 라이브러리의 컴포넌트를 사용하는 경우가 많으니 실습에 더 도움이 될 것이라 생각합니다.\n\n`App.js`에 템플릿으로 작성되어있는 내용을 모두 지우고 다음과 같이 작성하겠습니다.\n\n```jsx\n// src/App.js\nimport React from \"react\";\nimport PhoneBook from \"./components/phone-book\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div\n        style={ {\n          backgroundColor: \"steelblue\",\n          color: \"white\",\n          marginBottom: 16,\n        } }\n      >\n        <h1\n          style={ {\n            margin: \"auto\",\n            width: \"fit-content\",\n            height: 100,\n            display: \"flex\",\n            alignItems: \"center\",\n          } }\n        >\n          HELLO REACT RENDER\n        </h1>\n      </div>\n      <PhoneBook />\n    </div>\n  );\n}\n```\n\n그리고 `src`폴더 아래에 `components`폴더를 만들고 `phone-book.js`파일을 다음과 같이 작성합니다.\n\n```jsx\n// src/components/phone-book.js\nimport React from \"react\";\nimport lodash from \"lodash\";\nimport randomName from \"random-name\";\nimport { withStyles, Grid, TextField } from \"@material-ui/core\";\n\nconst randomNumber = () => String(Math.floor((Math.random() * 100) % 10));\nconst randomPhone = () => `010-xxxx-xxxx`.replace(/x/g, () => randomNumber());\n\nconst memberCount = 10;\nconst members = lodash\n  .range(memberCount)\n  .map(i => ({ id: i, name: randomName(), phone: randomPhone() }));\n\nclass PhoneBook extends React.Component {\n  state = { members };\n\n  handleChange = e => {\n    const {\n      dataset: { id },\n      name: field,\n      value,\n    } = e.target;\n\n    const members = [...this.state.members];\n    const index = members.findIndex(member => member.id === Number(id));\n    members[index] = { ...members[index], [field]: value };\n\n    this.setState({ members: [...members] });\n  };\n\n  render() {\n    const { classes } = this.props;\n    const { members } = this.state;\n    return (\n      <div className={classes.root}>\n        <h2>PhoneBook</h2>\n        {members.map(member => (\n          <Grid\n            key={member.id}\n            container\n            spacing={2}\n            className={classes.row}\n            alignItems=\"center\"\n          >\n            <Grid item xs={2}>\n              {member.id}\n            </Grid>\n            <Grid item xs={5}>\n              <TextField\n                inputProps={ { \"data-id\": member.id } }\n                label=\"name\"\n                name=\"name\"\n                value={member.name}\n                onChange={this.handleChange}\n              />\n            </Grid>\n            <Grid item xs={5}>\n              <TextField\n                inputProps={ { \"data-id\": member.id } }\n                label=\"phone\"\n                name=\"phone\"\n                value={member.phone}\n                onChange={this.handleChange}\n              />\n            </Grid>\n          </Grid>\n        ))}\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  root: {\n    margin: \"0 200px\",\n  },\n  row: {\n    margin: 16,\n  },\n};\n\nexport default withStyles(styles)(PhoneBook);\n\n```\n\n이제 개발 서버를 실행해보겠습니다. 콘솔에서 `npm run start`로 시작해주세요. 다음과 같은 화면이 표시됩니다. `input`의 값도 잘 변경 됩니다.\n\n![screenshot](/react/react-component-rerendering/img/react-rerendering-test_1.png)\n\n이제 컴포넌트의 변경(Rerendering)을 관찰할 수 있도록 React Developer Tools를 설치하겠습니다.\n\n![react developer tools](/react/react-component-rerendering/img/react-developer-tools.png)\n\n이제 크롬의 개발자 도구를 열고, `Profiler`탭에서 `톱니바퀴 모양(view settings)`을 누르고 `Highlight updates when components render`옵션을 켜줍니다.\n\n![screenshot](/react/react-component-rerendering/img/react-rerendering-test_2.gif)\n\n컴포넌트가 새로 그려질 때 마다 브라우저에 표시됩니다.\n\n---\n\n### 1. 컴포넌트 Rerendering 살펴보기\n\n`PhoneBook` 컴포넌트를 살펴보겠습니다. `members` 배열을 `map`을 통해서 바로 렌더링하고 있습니다. 하나의 `TextField`에서 값을 변경하면 모든 `TextField`가 리렌더링 되는 것을 볼 수 있습니다. 그리고 타이핑을 할 때마다 모든 `TextField`가 리렌더링하느라 버벅임이 발생합니다. `setState`에서 `members`의 값을 변경하면 `PhoneBook` 컴포넌트가 업데이트 되기 때문에 자식 컴포넌트도 업데이트 되는 것입니다. 현재는 10개의 `member`가 있지만 늘어날 수록 더욱 느려질 것입니다.\n\n---\n\n### 2. 자식 컴포넌트 분리하기\n\n하나의 `TextField`가 업데이트 될 때, 다른 컴포넌트는 업데이트 될 필요가 없습니다. 자식 컴포넌트로 분리해서 따로 동작하도록 만들어 보겠습니다.\n\n각 Member 단위로 컴포넌트로 구현하겠습니다. `src/components`폴더에 `form.js`파일을 만들고 다음과 같이 작성하겠습니다.\n\n```jsx\n// src/components/form.js\nimport React from \"react\";\nimport { withStyles, TextField, Grid } from \"@material-ui/core\";\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: \"1px solid lightgray\",\n  },\n};\n\nclass Form extends React.PureComponent {\n  render() {\n    const { classes, member, onChange } = this.props;\n    return (\n      <Grid container spacing={2} className={classes.form}>\n        <Grid item xs={2}>\n          {member.id}\n        </Grid>\n        <Grid item xs={5}>\n          <TextField\n            inputProps={ { \"data-id\": member.id } }\n            name=\"name\"\n            value={member.name}\n            onChange={onChange}\n          />\n        </Grid>\n        <Grid item xs={5}>\n          <TextField\n            inputProps={ { \"data-id\": member.id } }\n            name=\"phone\"\n            value={member.phone}\n            onChange={onChange}\n          />\n        </Grid>\n      </Grid>\n    );\n  }\n}\n\nexport default withStyles(styles)(Form);\n```\n\n이제 `phone-book.js`파일을 수정해줍니다.\n\n```jsx\n// src/components/phone-book.js\nimport React from \"react\";\nimport lodash from \"lodash\";\nimport randomName from \"random-name\";\nimport { withStyles, Grid, TextField } from \"@material-ui/core\";\nimport Form from \"./form\";\n\nconst randomNumber = () => String(Math.floor((Math.random() * 100) % 10));\nconst randomPhone = () => `010-xxxx-xxxx`.replace(/x/g, () => randomNumber());\n\nconst memberCount = 10;\nconst members = lodash\n  .range(memberCount)\n  .map(i => ({ id: i, name: randomName(), phone: randomPhone() }));\n\nclass PhoneBook extends React.Component {\n  state = { members };\n\n  handleChange = e => {\n    const {\n      dataset: { id },\n      name: field,\n      value,\n    } = e.target;\n\n    const members = [...this.state.members];\n    const index = members.findIndex(member => member.id === Number(id));\n    members[index] = { ...members[index], [field]: value };\n\n    this.setState({ members: [...members] });\n  };\n\n  render() {\n    const { classes } = this.props;\n    const { members } = this.state;\n    return (\n      <div className={classes.root}>\n        <h2>PhoneBook</h2>\n        {members.map(member => (\n          <Form key={member.id} member={member} onChange={this.handleChange} />\n        ))}\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  root: {\n    margin: \"0 200px\",\n  },\n  row: {\n    margin: 16,\n  },\n};\n\nexport default withStyles(styles)(PhoneBook);\n```\n\n각 Member를 그리는 부분을 컴포넌트로 분리했습니다. 그리고 자식 컴포넌트로 사용되는 `Form`컴포넌트는 `PureComponent`를 상속받은 컴포넌트입니다. 한번 실행해보겠습니다.\n\n![screenshot](/react/react-component-rerendering/img/react-rerendering-test_3.gif)\n\n`TextField`에 입력을 하면 `PhoneBook`컴포넌트가 업데이트 됩니다. 하지만 자식 컴포넌트인 `Form`컴포넌트는 `props`가 변하는 컴포넌트만 리렌더링이 발생합니다. 버벅임도 사라졌습니다.\n\n---\n\n### 3. React.memo 사용하기\n\n`Form`컴포넌트를 `PureComponent`를 사용하지 않는다면 어떻게 할 수 있을까요? `Form`컴포넌트를 함수형 컴포넌트로 수정해 보겠습니다. 그리고 컴포넌트를 `React.memo`함수로 전달해줍니다.\n\n```jsx\n// src/components/form.js\nimport React from \"react\";\nimport { withStyles, TextField, Grid } from \"@material-ui/core\";\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: \"1px solid lightgray\",\n  },\n};\n\nconst Form = props => {\n  const { classes, member, onChange } = props;\n  return (\n    <Grid container spacing={2} className={classes.form}>\n      <Grid item xs={2}>\n        {member.id}\n      </Grid>\n      <Grid item xs={5}>\n        <TextField\n          inputProps={ { \"data-id\": member.id } }\n          name=\"name\"\n          value={member.name}\n          onChange={onChange}\n        />\n      </Grid>\n      <Grid item xs={5}>\n        <TextField\n          inputProps={ { \"data-id\": member.id } }\n          name=\"phone\"\n          value={member.phone}\n          onChange={onChange}\n        />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default withStyles(styles)(React.memo(Form));\n```\n\n이렇게 하면 `PureComponent`를 사용하는 것과 같은 효과를 가지게 됩니다. 상태를 가지지 않는 `Form`컴포넌트의 경우에는 함수형 컴포넌트가 작성하기도 쉽고 직관적으로 코드를 작성/파악할 수 있습니다.\n\n---\n\n### 4. 세부 컴포넌트 분리하기\n\n`Form`컴포넌트로 분리했지만 아직 그 안에 두 개의 `TextField`가 있습니다. 지금은 두 개이지만 몇 개가 될 지 보장할 수 없습니다. 그렇다고 `TextField`를 또 다른 컴포넌트로 작성하면 번거로울 수 있습니다. 따로 컴포넌트로 분리하지 않고 `TextField`가 각각의 업데이트에 독립적으로 동작하도록 만들어 봅시다.\n\n`React.useMemo`를 이용하여 코드를 분리시켜보겠습니다. `form.js`를 다음과 같이 수정하겠습니다.\n\n```jsx\n// src/components/form.js\nimport React from \"react\";\nimport { withStyles, TextField, Grid } from \"@material-ui/core\";\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: \"1px solid lightgray\",\n  },\n};\n\nconst Form = props => {\n  const { classes, member, onChange } = props;\n\n  const nameField = React.useMemo(\n    () => (\n      <TextField\n        inputProps={ { \"data-id\": member.id } }\n        name=\"name\"\n        value={member.name}\n        onChange={onChange}\n      />\n    ),\n    [member.name, member.id],\n  );\n\n  const phoneField = React.useMemo(\n    () => (\n      <TextField\n        inputProps={ { \"data-id\": member.id } }\n        name=\"phone\"\n        value={member.phone}\n        onChange={onChange}\n      />\n    ),\n    [member.phone, member.id],\n  );\n\n  return (\n    <Grid container spacing={2} className={classes.form}>\n      <Grid item xs={2}>\n        {member.id}\n      </Grid>\n      <Grid item xs={5}>\n        {nameField}\n      </Grid>\n      <Grid item xs={5}>\n        {phoneField}\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default withStyles(styles)(React.memo(Form));\n```\n\n`TextField`를 사용하는 `name`과 `phone` 부분을 분리했습니다. `React.useMemo`를 이용하여 각각의 필드가 영향을 받는 값에 대해서만 업데이트 되도록 작성했습니다. 동작과 업데이트를 한번 보겠습니다.\n\n![screenshot](/react/react-component-rerendering/img/react-rerendering-test_4.gif)\n\n이제 `Form`컴포넌트 내에서도 각 `TextField`의 업데이트가 서로 영향을 주지 않습니다. 독립적으로 리렌더링 됩니다.\n\n---\n\n### 마무리\n\n오늘은 리액트 컴포넌트가 리렌더링 되는 것과 컴포넌트를 분리해서 불필요한 리렌더링을 방지하는 실습을 해봤습니다. 개발을 하다보면 컴포넌트가 커지고 복잡해질수록 불필요한 프로세스를 줄이고 성능 최적화를 구성하는 것이 어려워집니다. 작은 컴포넌트 단위부터 잘 구성하여서 성능 이슈를 발생시키지 않도록 하는 연습을 많이 해야할 것 같습니다.\n","html":"<p><img src=\"/react/react-component-rerendering/img/react_render_props.png\" alt=\"react render props\"></p>\n<p>React는 웹 프론트엔드 라이브러리로 많이 사용되어지고 있습니다. 저 역시 리액트를 처음 접하고 업무 프로젝트로 사용한 지 1년 정도가 되었습니다. 라이브러리를 이용하여 개발을 하면 더 편하지만 알아야 할 것도 많이 생깁니다.</p>\n<p>리액트로 개발을 할 때, 컴포넌트의 <strong>Rerendering</strong>에 대해 고민하게 될 때가 있는데요. React는 화면의 변경 사항에 대해서 ReactDOM을 이용하여 변경된 부분에 대해서만 Rerendering(또는 Update)합니다. React의 <a href=\"https://ko.reactjs.org/docs/react-component.html#the-component-lifecycle\">Lifecycle</a>을 이해하면 Rerendering을 잘 고려해서 개발할 수 있습니다.</p>\n<p>오늘은 간단한 Phonebook을 구현하면서, ReactDOM의 업데이트를 관찰하고, 컴포넌트의 Rerendering에 대해서 살펴보겠습니다. 특히 불필요한 업데이트를 줄이는 방법에 대해 중점적으로 보려고 합니다.</p>\n<hr>\n<h3 id=\"0-개발-환경-구성하기\">0. 개발 환경 구성하기</h3>\n<p>오늘 실습 개발 환경을 위해서 다음 두 가지가 필요합니다.</p>\n<ol>\n<li><a href=\"https://github.com/facebook/create-react-app\">CRA(create-react-app)</a></li>\n<li><a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\">chrome 확장프로그램 React Developer Tools</a></li>\n</ol>\n<p>먼저 CRA를 이용하여 간단한 React App을 만듭니다. 그리고 실습에 사용될 몇가지 패키지를 설치하겠습니다.</p>\n<pre><code class=\"language-bash\">$ npx create-react-app react-rerendering-test\n$ cd react-rerendering-test\n$ npm i lodash random-name @material-ui/core\n</code></pre>\n<p><code>lodash</code>와 <code>random-name</code>은 샘플 데이터를 다루기 위해서 설치합니다. <code>@material-ui</code>는 <code>input</code>태그를 대신하여 사용할 <code>TextField</code>를 위해 설치합니다. 또한 실제 업무에서도 html 태그가 아닌 UI 라이브러리의 컴포넌트를 사용하는 경우가 많으니 실습에 더 도움이 될 것이라 생각합니다.</p>\n<p><code>App.js</code>에 템플릿으로 작성되어있는 내용을 모두 지우고 다음과 같이 작성하겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/App.js\nimport React from &quot;react&quot;;\nimport PhoneBook from &quot;./components/phone-book&quot;;\n\nfunction App() {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;div\n        style={ {\n          backgroundColor: &quot;steelblue&quot;,\n          color: &quot;white&quot;,\n          marginBottom: 16,\n        } }\n      &gt;\n        &lt;h1\n          style={ {\n            margin: &quot;auto&quot;,\n            width: &quot;fit-content&quot;,\n            height: 100,\n            display: &quot;flex&quot;,\n            alignItems: &quot;center&quot;,\n          } }\n        &gt;\n          HELLO REACT RENDER\n        &lt;/h1&gt;\n      &lt;/div&gt;\n      &lt;PhoneBook /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>그리고 <code>src</code>폴더 아래에 <code>components</code>폴더를 만들고 <code>phone-book.js</code>파일을 다음과 같이 작성합니다.</p>\n<pre><code class=\"language-jsx\">// src/components/phone-book.js\nimport React from &quot;react&quot;;\nimport lodash from &quot;lodash&quot;;\nimport randomName from &quot;random-name&quot;;\nimport { withStyles, Grid, TextField } from &quot;@material-ui/core&quot;;\n\nconst randomNumber = () =&gt; String(Math.floor((Math.random() * 100) % 10));\nconst randomPhone = () =&gt; `010-xxxx-xxxx`.replace(/x/g, () =&gt; randomNumber());\n\nconst memberCount = 10;\nconst members = lodash\n  .range(memberCount)\n  .map(i =&gt; ({ id: i, name: randomName(), phone: randomPhone() }));\n\nclass PhoneBook extends React.Component {\n  state = { members };\n\n  handleChange = e =&gt; {\n    const {\n      dataset: { id },\n      name: field,\n      value,\n    } = e.target;\n\n    const members = [...this.state.members];\n    const index = members.findIndex(member =&gt; member.id === Number(id));\n    members[index] = { ...members[index], [field]: value };\n\n    this.setState({ members: [...members] });\n  };\n\n  render() {\n    const { classes } = this.props;\n    const { members } = this.state;\n    return (\n      &lt;div className={classes.root}&gt;\n        &lt;h2&gt;PhoneBook&lt;/h2&gt;\n        {members.map(member =&gt; (\n          &lt;Grid\n            key={member.id}\n            container\n            spacing={2}\n            className={classes.row}\n            alignItems=&quot;center&quot;\n          &gt;\n            &lt;Grid item xs={2}&gt;\n              {member.id}\n            &lt;/Grid&gt;\n            &lt;Grid item xs={5}&gt;\n              &lt;TextField\n                inputProps={ { &quot;data-id&quot;: member.id } }\n                label=&quot;name&quot;\n                name=&quot;name&quot;\n                value={member.name}\n                onChange={this.handleChange}\n              /&gt;\n            &lt;/Grid&gt;\n            &lt;Grid item xs={5}&gt;\n              &lt;TextField\n                inputProps={ { &quot;data-id&quot;: member.id } }\n                label=&quot;phone&quot;\n                name=&quot;phone&quot;\n                value={member.phone}\n                onChange={this.handleChange}\n              /&gt;\n            &lt;/Grid&gt;\n          &lt;/Grid&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n}\n\nconst styles = {\n  root: {\n    margin: &quot;0 200px&quot;,\n  },\n  row: {\n    margin: 16,\n  },\n};\n\nexport default withStyles(styles)(PhoneBook);\n</code></pre>\n<p>이제 개발 서버를 실행해보겠습니다. 콘솔에서 <code>npm run start</code>로 시작해주세요. 다음과 같은 화면이 표시됩니다. <code>input</code>의 값도 잘 변경 됩니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-rerendering-test_1.png\" alt=\"screenshot\"></p>\n<p>이제 컴포넌트의 변경(Rerendering)을 관찰할 수 있도록 React Developer Tools를 설치하겠습니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-developer-tools.png\" alt=\"react developer tools\"></p>\n<p>이제 크롬의 개발자 도구를 열고, <code>Profiler</code>탭에서 <code>톱니바퀴 모양(view settings)</code>을 누르고 <code>Highlight updates when components render</code>옵션을 켜줍니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-rerendering-test_2.gif\" alt=\"screenshot\"></p>\n<p>컴포넌트가 새로 그려질 때 마다 브라우저에 표시됩니다.</p>\n<hr>\n<h3 id=\"1-컴포넌트-rerendering-살펴보기\">1. 컴포넌트 Rerendering 살펴보기</h3>\n<p><code>PhoneBook</code> 컴포넌트를 살펴보겠습니다. <code>members</code> 배열을 <code>map</code>을 통해서 바로 렌더링하고 있습니다. 하나의 <code>TextField</code>에서 값을 변경하면 모든 <code>TextField</code>가 리렌더링 되는 것을 볼 수 있습니다. 그리고 타이핑을 할 때마다 모든 <code>TextField</code>가 리렌더링하느라 버벅임이 발생합니다. <code>setState</code>에서 <code>members</code>의 값을 변경하면 <code>PhoneBook</code> 컴포넌트가 업데이트 되기 때문에 자식 컴포넌트도 업데이트 되는 것입니다. 현재는 10개의 <code>member</code>가 있지만 늘어날 수록 더욱 느려질 것입니다.</p>\n<hr>\n<h3 id=\"2-자식-컴포넌트-분리하기\">2. 자식 컴포넌트 분리하기</h3>\n<p>하나의 <code>TextField</code>가 업데이트 될 때, 다른 컴포넌트는 업데이트 될 필요가 없습니다. 자식 컴포넌트로 분리해서 따로 동작하도록 만들어 보겠습니다.</p>\n<p>각 Member 단위로 컴포넌트로 구현하겠습니다. <code>src/components</code>폴더에 <code>form.js</code>파일을 만들고 다음과 같이 작성하겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/components/form.js\nimport React from &quot;react&quot;;\nimport { withStyles, TextField, Grid } from &quot;@material-ui/core&quot;;\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: &quot;1px solid lightgray&quot;,\n  },\n};\n\nclass Form extends React.PureComponent {\n  render() {\n    const { classes, member, onChange } = this.props;\n    return (\n      &lt;Grid container spacing={2} className={classes.form}&gt;\n        &lt;Grid item xs={2}&gt;\n          {member.id}\n        &lt;/Grid&gt;\n        &lt;Grid item xs={5}&gt;\n          &lt;TextField\n            inputProps={ { &quot;data-id&quot;: member.id } }\n            name=&quot;name&quot;\n            value={member.name}\n            onChange={onChange}\n          /&gt;\n        &lt;/Grid&gt;\n        &lt;Grid item xs={5}&gt;\n          &lt;TextField\n            inputProps={ { &quot;data-id&quot;: member.id } }\n            name=&quot;phone&quot;\n            value={member.phone}\n            onChange={onChange}\n          /&gt;\n        &lt;/Grid&gt;\n      &lt;/Grid&gt;\n    );\n  }\n}\n\nexport default withStyles(styles)(Form);\n</code></pre>\n<p>이제 <code>phone-book.js</code>파일을 수정해줍니다.</p>\n<pre><code class=\"language-jsx\">// src/components/phone-book.js\nimport React from &quot;react&quot;;\nimport lodash from &quot;lodash&quot;;\nimport randomName from &quot;random-name&quot;;\nimport { withStyles, Grid, TextField } from &quot;@material-ui/core&quot;;\nimport Form from &quot;./form&quot;;\n\nconst randomNumber = () =&gt; String(Math.floor((Math.random() * 100) % 10));\nconst randomPhone = () =&gt; `010-xxxx-xxxx`.replace(/x/g, () =&gt; randomNumber());\n\nconst memberCount = 10;\nconst members = lodash\n  .range(memberCount)\n  .map(i =&gt; ({ id: i, name: randomName(), phone: randomPhone() }));\n\nclass PhoneBook extends React.Component {\n  state = { members };\n\n  handleChange = e =&gt; {\n    const {\n      dataset: { id },\n      name: field,\n      value,\n    } = e.target;\n\n    const members = [...this.state.members];\n    const index = members.findIndex(member =&gt; member.id === Number(id));\n    members[index] = { ...members[index], [field]: value };\n\n    this.setState({ members: [...members] });\n  };\n\n  render() {\n    const { classes } = this.props;\n    const { members } = this.state;\n    return (\n      &lt;div className={classes.root}&gt;\n        &lt;h2&gt;PhoneBook&lt;/h2&gt;\n        {members.map(member =&gt; (\n          &lt;Form key={member.id} member={member} onChange={this.handleChange} /&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n}\n\nconst styles = {\n  root: {\n    margin: &quot;0 200px&quot;,\n  },\n  row: {\n    margin: 16,\n  },\n};\n\nexport default withStyles(styles)(PhoneBook);\n</code></pre>\n<p>각 Member를 그리는 부분을 컴포넌트로 분리했습니다. 그리고 자식 컴포넌트로 사용되는 <code>Form</code>컴포넌트는 <code>PureComponent</code>를 상속받은 컴포넌트입니다. 한번 실행해보겠습니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-rerendering-test_3.gif\" alt=\"screenshot\"></p>\n<p><code>TextField</code>에 입력을 하면 <code>PhoneBook</code>컴포넌트가 업데이트 됩니다. 하지만 자식 컴포넌트인 <code>Form</code>컴포넌트는 <code>props</code>가 변하는 컴포넌트만 리렌더링이 발생합니다. 버벅임도 사라졌습니다.</p>\n<hr>\n<h3 id=\"3-reactmemo-사용하기\">3. React.memo 사용하기</h3>\n<p><code>Form</code>컴포넌트를 <code>PureComponent</code>를 사용하지 않는다면 어떻게 할 수 있을까요? <code>Form</code>컴포넌트를 함수형 컴포넌트로 수정해 보겠습니다. 그리고 컴포넌트를 <code>React.memo</code>함수로 전달해줍니다.</p>\n<pre><code class=\"language-jsx\">// src/components/form.js\nimport React from &quot;react&quot;;\nimport { withStyles, TextField, Grid } from &quot;@material-ui/core&quot;;\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: &quot;1px solid lightgray&quot;,\n  },\n};\n\nconst Form = props =&gt; {\n  const { classes, member, onChange } = props;\n  return (\n    &lt;Grid container spacing={2} className={classes.form}&gt;\n      &lt;Grid item xs={2}&gt;\n        {member.id}\n      &lt;/Grid&gt;\n      &lt;Grid item xs={5}&gt;\n        &lt;TextField\n          inputProps={ { &quot;data-id&quot;: member.id } }\n          name=&quot;name&quot;\n          value={member.name}\n          onChange={onChange}\n        /&gt;\n      &lt;/Grid&gt;\n      &lt;Grid item xs={5}&gt;\n        &lt;TextField\n          inputProps={ { &quot;data-id&quot;: member.id } }\n          name=&quot;phone&quot;\n          value={member.phone}\n          onChange={onChange}\n        /&gt;\n      &lt;/Grid&gt;\n    &lt;/Grid&gt;\n  );\n};\n\nexport default withStyles(styles)(React.memo(Form));\n</code></pre>\n<p>이렇게 하면 <code>PureComponent</code>를 사용하는 것과 같은 효과를 가지게 됩니다. 상태를 가지지 않는 <code>Form</code>컴포넌트의 경우에는 함수형 컴포넌트가 작성하기도 쉽고 직관적으로 코드를 작성/파악할 수 있습니다.</p>\n<hr>\n<h3 id=\"4-세부-컴포넌트-분리하기\">4. 세부 컴포넌트 분리하기</h3>\n<p><code>Form</code>컴포넌트로 분리했지만 아직 그 안에 두 개의 <code>TextField</code>가 있습니다. 지금은 두 개이지만 몇 개가 될 지 보장할 수 없습니다. 그렇다고 <code>TextField</code>를 또 다른 컴포넌트로 작성하면 번거로울 수 있습니다. 따로 컴포넌트로 분리하지 않고 <code>TextField</code>가 각각의 업데이트에 독립적으로 동작하도록 만들어 봅시다.</p>\n<p><code>React.useMemo</code>를 이용하여 코드를 분리시켜보겠습니다. <code>form.js</code>를 다음과 같이 수정하겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/components/form.js\nimport React from &quot;react&quot;;\nimport { withStyles, TextField, Grid } from &quot;@material-ui/core&quot;;\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: &quot;1px solid lightgray&quot;,\n  },\n};\n\nconst Form = props =&gt; {\n  const { classes, member, onChange } = props;\n\n  const nameField = React.useMemo(\n    () =&gt; (\n      &lt;TextField\n        inputProps={ { &quot;data-id&quot;: member.id } }\n        name=&quot;name&quot;\n        value={member.name}\n        onChange={onChange}\n      /&gt;\n    ),\n    [member.name, member.id],\n  );\n\n  const phoneField = React.useMemo(\n    () =&gt; (\n      &lt;TextField\n        inputProps={ { &quot;data-id&quot;: member.id } }\n        name=&quot;phone&quot;\n        value={member.phone}\n        onChange={onChange}\n      /&gt;\n    ),\n    [member.phone, member.id],\n  );\n\n  return (\n    &lt;Grid container spacing={2} className={classes.form}&gt;\n      &lt;Grid item xs={2}&gt;\n        {member.id}\n      &lt;/Grid&gt;\n      &lt;Grid item xs={5}&gt;\n        {nameField}\n      &lt;/Grid&gt;\n      &lt;Grid item xs={5}&gt;\n        {phoneField}\n      &lt;/Grid&gt;\n    &lt;/Grid&gt;\n  );\n};\n\nexport default withStyles(styles)(React.memo(Form));\n</code></pre>\n<p><code>TextField</code>를 사용하는 <code>name</code>과 <code>phone</code> 부분을 분리했습니다. <code>React.useMemo</code>를 이용하여 각각의 필드가 영향을 받는 값에 대해서만 업데이트 되도록 작성했습니다. 동작과 업데이트를 한번 보겠습니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-rerendering-test_4.gif\" alt=\"screenshot\"></p>\n<p>이제 <code>Form</code>컴포넌트 내에서도 각 <code>TextField</code>의 업데이트가 서로 영향을 주지 않습니다. 독립적으로 리렌더링 됩니다.</p>\n<hr>\n<h3 id=\"마무리\">마무리</h3>\n<p>오늘은 리액트 컴포넌트가 리렌더링 되는 것과 컴포넌트를 분리해서 불필요한 리렌더링을 방지하는 실습을 해봤습니다. 개발을 하다보면 컴포넌트가 커지고 복잡해질수록 불필요한 프로세스를 줄이고 성능 최적화를 구성하는 것이 어려워집니다. 작은 컴포넌트 단위부터 잘 구성하여서 성능 이슈를 발생시키지 않도록 하는 연습을 많이 해야할 것 같습니다.</p>\n","excerpt":" React는 웹 프론트엔드 라이브러리로 많이 사용되어지고 있습니다. 저 역시 리액트를 처음 접하고 업무 프로젝트로 사용한 지 1년 정도가 되었습니다. 라이브러리를 이용하여 개발을 하면 더 편하지만 알아야 할 것도 많이 생깁니다. 리액트로 개발을 할 때, 컴포넌트의 Rerendering에 대해 고민하게 될 때가 있는데요. React는 화면의 변경 사항에 대해","thumbnail":"/react/react-component-rerendering/img/react_render_props.png","thumbnailUrl":"https://hoontae24.github.io/react/react-component-rerendering/img/react_render_props.png"},{"href":"11","round":11,"paths":["git","git-frequently-used-commands"],"slug":"git-frequently-used-commands","title":"자주 사용하는 Git 명령어 정리","description":"","date":"2020-03-08","category":"git","tags":["git"],"seriesId":null,"markdown":"\n![git](/git/git-frequently-used-commands/img/git.png)\n\nGit은 개발자들이 버전 관리 도구로 많이 사용하고 있습니다. 사용하기도 쉽고, Github과 연동하면 소스 코드를 관리하기도 편리합니다. 이번 포스트에서는 Git을 사용할 때, 자주 사용하는 명령어를 정리해보도록 하겠습니다.\n\n_(단, git의 명령어의 개념과 명령어의 모든 옵션을 다루지 않습니다. 개인적으로 자주 사용하는 것들만 다루도록 하겠습니다.)_\n\n---\n\n#### Init\n\n```shell\n$ git init\n```\n\n`init`은 Git 저장소를 초기화하는 명령어입니다. 프로젝트에서 Git을 사용하려면 `git init`을 통해서 저장소를 초기화하거나, `git clone`을 이용하여 저장소를 불러와야합니다.\n\n#### Clone\n\n```shell\n$ git clone <repository> [<directory>]\n```\n\n위에서 언급하였듯이, `git clone`은 이미 저장된 저장소를 불러오는 명령어입니다. 주로 Github에 있는 저장소를 불러와 복제할 때 이용합니다.\n\n```shell\n# github 저장소 clone하기\n# <directory>를 지정하지 않으면 새로운 폴더를 생성함\n$ git clone https://github.com/<github_username>/<repository_name>.git\n\n# github 저장소 clone하기\n# 현재 위치의 폴더에 clone함\n$ git clone https://github.com/<github_username>/<repository_name>.git ./\n\n# github 저장소 clone하기\n# my_project 폴더에 clone함\n$ git clone https://github.com/<github_username>/<repository_name>.git my_project\n\n# 로컬 저장소 clone하기\n$ git clone ./other_project/.git ./other_project_2\n```\n\n#### Status\n\n```shell\n$ git status\n```\n\ngit 저장소가 생성되면, 프로젝트의 파일 변경을 감지합니다. `git status`로 변경된 파일이 무엇인지 알 수 있습니다. 또한 해당 파일들을 어떤 index로 관리하고 있는지 표시해줍니다.\n\n#### Add\n\n```shell\n$ git add <file>\n```\n\n`git add`로 추가된 파일은 staged index로 관리합니다. staged 상태의 파일은 커밋 대상이 됩니다.\n\n```shell\n# 프로젝트의 모든 변경된 파일을 staged 상태로 등록합니다.\n$ git add .\n```\n\n#### Commit\n\n```shell\n$ git commit [-m <commit_message>]\n```\n\n현재 staged 상태 파일들의 버전을 저장합니다. commit은 파일의 변경 사항들을 저장하고 hash로 commit_id를 남깁니다.\n\n```shell\n# message를 작성하는 화면에서 추가 작업 후 commit됨\n$ git commit\n\n\n# 메시지를 포함하여 즉시 commit됨\n$ git commit -m \"initial commit\"\n```\n\n#### Log\n\n```shell\n$ git log [<branch_name>]\n```\n\n저장소의 commit 내역을 확인합니다.\n\n#### Diff\n\n```shell\n$ git diff [<commit>] [<target_commit>]\n```\n\ncommit 내용의 변경 내역을 보여줍니다. \\<commit>에는 commit_hash나 branch_name이 올 수도 있습니다.\n\n```shell\n# 현재 커밋에서 변경된 부분을 보여줌\n$ git diff --stat\n\n# 현재 커밋과 \"develop\" branch의 변경 사항을 보여줌\n$ git diff --stat develop\n\n# \"release\" branch와 \"develop\" branch의 변경 사항을 보여줌\n$ git diff --stat develop release\n```\n\n#### Branch\n\n```shell\n$ git branch [<new_branch_name>] [-a] [-r] [-d,-D <branch_name>]\n```\n\n```shell\n# 로컬 저장소의 branch 목록을 보여줌\n$ git branch\n\n# 원격 저장소의 branch 목록을 보여줌\n$ git branch -r\n\n# 모든 branch 목록을 보여줌\n$ git branch -a\n\n# 현재 커밋에 새로운 branch \"develop\"을 생성함\n$ git branch develop\n\n# \"master\" branch 커밋에 새로운 branch \"develop\"을 생성함\n$ git branch develop master\n\n# \"develop\" branch를 삭제함(merge되었을 경우에만)\n$ git branch -d develop\n\n# \"develop\" branch를 삭제함(강제 삭제)\n$ git branch -D develop\n```\n\n#### Checkout\n\n```shell\n# 버전(Head)을 \"develop\" branch로 이동\n$ git checkout develop\n\n# \"develop\" branch를 생성하고, 이동\n$ git checkout -b develop\n```\n\n#### Merge\n\n```shell\n$ git merge <branch_name> [--no-ff] [--squash]\n```\n\n```shell\n# 현재 branch에 develop branch를 병합\n$ git merge develop\n\n# fast-forward 없이 병합\n$ git merge develop --no-ff\n\n# \"develop\" branch의 병합할 commit을 합쳐서 staged로 가져옴\n$ git merge develop --squash\n```\n\n#### Rebase\n\n```shell\n# 현재 branch를 \"develop\" branch에서 시작하도록 이동\n$ git rebase develop\n\n# 마지막 5개의 커밋을 수정\n$ git rebase -i head~5\n```\n\n#### Stash\n\n```shell\n# 커밋되지 않은 변경된 내용을 따로 저장(Untracked 파일을 제외)\n$ git stash\n\n# stash 한 내용을 다시 적용하고, stash에서 삭제\n$ git stash pop\n```\n\n#### Reset\n\n```shell\n# 마지막 2개의 커밋을 되돌리고 변경 내용은 유지\n$ git reset head~2\n\n# 마지막 2개의 커밋을 되돌리고 변경 내용은 삭제\n$ git reset head~2 --hard\n\n# 현재 커밋에서 변경된 내용을 삭제\n$ git reset --hard\n```\n\n#### Remote\n\n```shell\n$ git remote add <remote_name> <remote_url>\n\n# url의 저장소를 origin 원격 저장소로 추가\n$ git remote add origin https://hoontae24.github.com/hoontae24.github.io.git\n```\n\n#### Fetch\n\n```shell\n# 현재 branch의 원격 저장소 버전을 불러옴\n$ git fetch\n\n# origin 원격 저장소의 develop branch를 불러옴\n$ git fetch origin develop\n```\n\n#### Pull\n\n```shell\n# 현재 branch에 원격 저장소 버전을 덮어씀(fetch + merge)\n$ git pull\n```\n\n#### Push\n\n```shell\n# origin 원격 저장소에 develop branch 버전을 저장함\n$ git push origin develop\n```\n\n#### Config\n\n```shell\n# 현재 저장소의 config 정보를 불러옴\n$ git config --list\n\n# 전역 저장소의 config 정보를 불러옴\n$ git config --list --global\n\n# 현재 저장소의 username을 불러옴\n$ git config user.name\n\n# 현재 저장소의 email을 불러옴\n$ git config user.email\n\n# 현재 저장소의 username을 등록(수정)함\n$ git config user.name \"hoontae24\"\n\n# 현재 저장소에 git 명령어 별칭(alias)을 등록함\n$ git config alias.<alias_name> \"command\"\n\n# develop branch로 checkout하는 명령어를 alias로 등록\n$ git config alias.dev \"checkout develop\"\n$ git dev # git checkout develop\n```\n\n---\n\n#### 마무리\n\n이번 포스트에서는 제가 개인적으로 자주 사용하는 Git 명령어를 정리해보았습니다. git을 사용하면서 아직도 모르는 기능이 많이 있는데, 명령어에 대해 자세히 몰라도 어떤 명령어가 있는지 대충 기억하기만 하면 검색하여 이용할 수 있으니 이렇게 정리해둡니다.\n\n이 포스트는 명령어를 정리하여 기억하기 위한 용도이니 사실 git을 배우거나 개념을 익히기에는 설명이 너무 부족합니다. 다음에는 기본적인 git 명령어를 가지고 실습해보는 법을 알아보도록 하겠습니다.\n","html":"<p><img src=\"/git/git-frequently-used-commands/img/git.png\" alt=\"git\"></p>\n<p>Git은 개발자들이 버전 관리 도구로 많이 사용하고 있습니다. 사용하기도 쉽고, Github과 연동하면 소스 코드를 관리하기도 편리합니다. 이번 포스트에서는 Git을 사용할 때, 자주 사용하는 명령어를 정리해보도록 하겠습니다.</p>\n<p><em>(단, git의 명령어의 개념과 명령어의 모든 옵션을 다루지 않습니다. 개인적으로 자주 사용하는 것들만 다루도록 하겠습니다.)</em></p>\n<hr>\n<h4 id=\"init\">Init</h4>\n<pre><code class=\"language-shell\">$ git init\n</code></pre>\n<p><code>init</code>은 Git 저장소를 초기화하는 명령어입니다. 프로젝트에서 Git을 사용하려면 <code>git init</code>을 통해서 저장소를 초기화하거나, <code>git clone</code>을 이용하여 저장소를 불러와야합니다.</p>\n<h4 id=\"clone\">Clone</h4>\n<pre><code class=\"language-shell\">$ git clone &lt;repository&gt; [&lt;directory&gt;]\n</code></pre>\n<p>위에서 언급하였듯이, <code>git clone</code>은 이미 저장된 저장소를 불러오는 명령어입니다. 주로 Github에 있는 저장소를 불러와 복제할 때 이용합니다.</p>\n<pre><code class=\"language-shell\"># github 저장소 clone하기\n# &lt;directory&gt;를 지정하지 않으면 새로운 폴더를 생성함\n$ git clone https://github.com/&lt;github_username&gt;/&lt;repository_name&gt;.git\n\n# github 저장소 clone하기\n# 현재 위치의 폴더에 clone함\n$ git clone https://github.com/&lt;github_username&gt;/&lt;repository_name&gt;.git ./\n\n# github 저장소 clone하기\n# my_project 폴더에 clone함\n$ git clone https://github.com/&lt;github_username&gt;/&lt;repository_name&gt;.git my_project\n\n# 로컬 저장소 clone하기\n$ git clone ./other_project/.git ./other_project_2\n</code></pre>\n<h4 id=\"status\">Status</h4>\n<pre><code class=\"language-shell\">$ git status\n</code></pre>\n<p>git 저장소가 생성되면, 프로젝트의 파일 변경을 감지합니다. <code>git status</code>로 변경된 파일이 무엇인지 알 수 있습니다. 또한 해당 파일들을 어떤 index로 관리하고 있는지 표시해줍니다.</p>\n<h4 id=\"add\">Add</h4>\n<pre><code class=\"language-shell\">$ git add &lt;file&gt;\n</code></pre>\n<p><code>git add</code>로 추가된 파일은 staged index로 관리합니다. staged 상태의 파일은 커밋 대상이 됩니다.</p>\n<pre><code class=\"language-shell\"># 프로젝트의 모든 변경된 파일을 staged 상태로 등록합니다.\n$ git add .\n</code></pre>\n<h4 id=\"commit\">Commit</h4>\n<pre><code class=\"language-shell\">$ git commit [-m &lt;commit_message&gt;]\n</code></pre>\n<p>현재 staged 상태 파일들의 버전을 저장합니다. commit은 파일의 변경 사항들을 저장하고 hash로 commit_id를 남깁니다.</p>\n<pre><code class=\"language-shell\"># message를 작성하는 화면에서 추가 작업 후 commit됨\n$ git commit\n\n\n# 메시지를 포함하여 즉시 commit됨\n$ git commit -m &quot;initial commit&quot;\n</code></pre>\n<h4 id=\"log\">Log</h4>\n<pre><code class=\"language-shell\">$ git log [&lt;branch_name&gt;]\n</code></pre>\n<p>저장소의 commit 내역을 확인합니다.</p>\n<h4 id=\"diff\">Diff</h4>\n<pre><code class=\"language-shell\">$ git diff [&lt;commit&gt;] [&lt;target_commit&gt;]\n</code></pre>\n<p>commit 내용의 변경 내역을 보여줍니다. &lt;commit&gt;에는 commit_hash나 branch_name이 올 수도 있습니다.</p>\n<pre><code class=\"language-shell\"># 현재 커밋에서 변경된 부분을 보여줌\n$ git diff --stat\n\n# 현재 커밋과 &quot;develop&quot; branch의 변경 사항을 보여줌\n$ git diff --stat develop\n\n# &quot;release&quot; branch와 &quot;develop&quot; branch의 변경 사항을 보여줌\n$ git diff --stat develop release\n</code></pre>\n<h4 id=\"branch\">Branch</h4>\n<pre><code class=\"language-shell\">$ git branch [&lt;new_branch_name&gt;] [-a] [-r] [-d,-D &lt;branch_name&gt;]\n</code></pre>\n<pre><code class=\"language-shell\"># 로컬 저장소의 branch 목록을 보여줌\n$ git branch\n\n# 원격 저장소의 branch 목록을 보여줌\n$ git branch -r\n\n# 모든 branch 목록을 보여줌\n$ git branch -a\n\n# 현재 커밋에 새로운 branch &quot;develop&quot;을 생성함\n$ git branch develop\n\n# &quot;master&quot; branch 커밋에 새로운 branch &quot;develop&quot;을 생성함\n$ git branch develop master\n\n# &quot;develop&quot; branch를 삭제함(merge되었을 경우에만)\n$ git branch -d develop\n\n# &quot;develop&quot; branch를 삭제함(강제 삭제)\n$ git branch -D develop\n</code></pre>\n<h4 id=\"checkout\">Checkout</h4>\n<pre><code class=\"language-shell\"># 버전(Head)을 &quot;develop&quot; branch로 이동\n$ git checkout develop\n\n# &quot;develop&quot; branch를 생성하고, 이동\n$ git checkout -b develop\n</code></pre>\n<h4 id=\"merge\">Merge</h4>\n<pre><code class=\"language-shell\">$ git merge &lt;branch_name&gt; [--no-ff] [--squash]\n</code></pre>\n<pre><code class=\"language-shell\"># 현재 branch에 develop branch를 병합\n$ git merge develop\n\n# fast-forward 없이 병합\n$ git merge develop --no-ff\n\n# &quot;develop&quot; branch의 병합할 commit을 합쳐서 staged로 가져옴\n$ git merge develop --squash\n</code></pre>\n<h4 id=\"rebase\">Rebase</h4>\n<pre><code class=\"language-shell\"># 현재 branch를 &quot;develop&quot; branch에서 시작하도록 이동\n$ git rebase develop\n\n# 마지막 5개의 커밋을 수정\n$ git rebase -i head~5\n</code></pre>\n<h4 id=\"stash\">Stash</h4>\n<pre><code class=\"language-shell\"># 커밋되지 않은 변경된 내용을 따로 저장(Untracked 파일을 제외)\n$ git stash\n\n# stash 한 내용을 다시 적용하고, stash에서 삭제\n$ git stash pop\n</code></pre>\n<h4 id=\"reset\">Reset</h4>\n<pre><code class=\"language-shell\"># 마지막 2개의 커밋을 되돌리고 변경 내용은 유지\n$ git reset head~2\n\n# 마지막 2개의 커밋을 되돌리고 변경 내용은 삭제\n$ git reset head~2 --hard\n\n# 현재 커밋에서 변경된 내용을 삭제\n$ git reset --hard\n</code></pre>\n<h4 id=\"remote\">Remote</h4>\n<pre><code class=\"language-shell\">$ git remote add &lt;remote_name&gt; &lt;remote_url&gt;\n\n# url의 저장소를 origin 원격 저장소로 추가\n$ git remote add origin https://hoontae24.github.com/hoontae24.github.io.git\n</code></pre>\n<h4 id=\"fetch\">Fetch</h4>\n<pre><code class=\"language-shell\"># 현재 branch의 원격 저장소 버전을 불러옴\n$ git fetch\n\n# origin 원격 저장소의 develop branch를 불러옴\n$ git fetch origin develop\n</code></pre>\n<h4 id=\"pull\">Pull</h4>\n<pre><code class=\"language-shell\"># 현재 branch에 원격 저장소 버전을 덮어씀(fetch + merge)\n$ git pull\n</code></pre>\n<h4 id=\"push\">Push</h4>\n<pre><code class=\"language-shell\"># origin 원격 저장소에 develop branch 버전을 저장함\n$ git push origin develop\n</code></pre>\n<h4 id=\"config\">Config</h4>\n<pre><code class=\"language-shell\"># 현재 저장소의 config 정보를 불러옴\n$ git config --list\n\n# 전역 저장소의 config 정보를 불러옴\n$ git config --list --global\n\n# 현재 저장소의 username을 불러옴\n$ git config user.name\n\n# 현재 저장소의 email을 불러옴\n$ git config user.email\n\n# 현재 저장소의 username을 등록(수정)함\n$ git config user.name &quot;hoontae24&quot;\n\n# 현재 저장소에 git 명령어 별칭(alias)을 등록함\n$ git config alias.&lt;alias_name&gt; &quot;command&quot;\n\n# develop branch로 checkout하는 명령어를 alias로 등록\n$ git config alias.dev &quot;checkout develop&quot;\n$ git dev # git checkout develop\n</code></pre>\n<hr>\n<h4 id=\"마무리\">마무리</h4>\n<p>이번 포스트에서는 제가 개인적으로 자주 사용하는 Git 명령어를 정리해보았습니다. git을 사용하면서 아직도 모르는 기능이 많이 있는데, 명령어에 대해 자세히 몰라도 어떤 명령어가 있는지 대충 기억하기만 하면 검색하여 이용할 수 있으니 이렇게 정리해둡니다.</p>\n<p>이 포스트는 명령어를 정리하여 기억하기 위한 용도이니 사실 git을 배우거나 개념을 익히기에는 설명이 너무 부족합니다. 다음에는 기본적인 git 명령어를 가지고 실습해보는 법을 알아보도록 하겠습니다.</p>\n","excerpt":" Git은 개발자들이 버전 관리 도구로 많이 사용하고 있습니다. 사용하기도 쉽고, Github과 연동하면 소스 코드를 관리하기도 편리합니다. 이번 포스트에서는 Git을 사용할 때, 자주 사용하는 명령어를 정리해보도록 하겠습니다. (단, git의 명령어의 개념과 명령어의 모든 옵션을 다루지 않습니다. 개인적으로 자주 사용하는 것들만 다루도록 하겠습니다.)  I","thumbnail":"/git/git-frequently-used-commands/img/git.png","thumbnailUrl":"https://hoontae24.github.io/git/git-frequently-used-commands/img/git.png"},{"href":"10","round":10,"paths":["aws","aws-ec2-rds-deploy-setting"],"slug":"aws-ec2-rds-deploy-setting","title":"AWS EC2 + RDS에 Node.js 서버 배포하기(Ubuntu, Mysql)","description":"","date":"2020-02-23","category":"aws","tags":["aws","ec2","rds"],"seriesId":null,"markdown":"\n![aws, node](/aws/aws-ec2-rds-deploy-setting/img/aws_node.png)\n\n보통의 웹 서비스는 서버를 이용하여 서비스를 제공합니다. 서버 컴퓨터를 직접 구성해서 할 수도 있지만, 요즘에는 클라우드 서비스를 많이 이용합니다. 클라우드 서비스를 이용하면 물리적으로 서버를 직접 구성하거나 가지고 있지 않아도 되고, 내가 사용할 서비스에만 집중하여 서버를 운영할 수 있습니다. 이번 포스트에서는 대표적인 클라우드 컴퓨팅 서비스 중 하나인 Amazon Web Service(AWS)를 이용하여 Node.js 서버를 배포해보겠습니다.\n\n오늘 배포할 웹 서비스 환경은 다음과 같이 구성됩니다.\n\n- Node.js 웹 어플리케이션\n- AWS EC2와 Ubuntu (+ nginx 프록시)\n- AWS RDS와 Mysql\n\n우리가 만든(미리 만들어둔) 웹 어플리케이션을 EC2의 Ubuntu에 구성할 것입니다. 그리고 서비스에 사용될 데이터베이스는 RDS의 Mysql 서버를 구성할 것입니다.\n\n---\n\n### 0. Node.js 웹 어플리케이션 준비하기\n\n우리의 웹 서비스가 실제로 동작할 웹 어플리케이션이 필요합니다. 여기서는 Node.js 웹 어플리케이션을 사용할 것인데, 간단한 Node.js REST Api 서버를 만듭니다. _(Node.js 어플리케이션에 대한 부분은 자세히 다루지 않습니다.)_\n\n저는 미리 준비한 Node 앱을 가져오겠습니다. 먼저 로컬에 설치해서 잘 동작하는 지 확인해볼게요. 코드를 깃헙에서 가져오고, 빌드 후 구동합니다.\n\n```bash\n$ git clone https://github.com/hoontae24/node-simple-server.git\n$ cd simple-node-server\n$ npm install\n$ npm run build\n$ npm start\n```\n\n서버가 시작하고, 브라우저에서 요청을 보내어 동작을 확인해봅니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/node_simple_server.png)\n\n간단한 응답이 도착하네요. 로컬에서 서버가 잘 동작하는 것 같습니다. 서버를 종료해줍니다.\n\n```bash\n$ npm run stop\n```\n\n---\n\n### 1. EC2 서버 구성하기\n\nEC2(Amazon Elastic Compute Cloud)는 클라우드에서 컴퓨팅 서비스를 이용할 수 있도록 해줍니다. AWS에서 인스턴스를 만들고, SSH로 원격 연결을 통해 서버 컴퓨터를 제어할 수 있습니다.\n\n#### 1.1 EC2 인스턴스 만들기\n\nAWS로 가서 EC2 인스턴스를 만들어 봅시다. [EC2 Management Console](https://ap-northeast-2.console.aws.amazon.com/ec2/home?region=ap-northeast-2)에 들어가서 `인스턴스 시작`을 선택합니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_1.png)\n\nAMI 템플릿은 빠른시작 탭에서 `Ubuntu Server 18버전`을 선택하겠습니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_2.png)\n\n인스턴스는 기본으로 선택되어있는 `t2.micro 유형`을 선택하겠습니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_3.png)\n\n저는 새 보안 그룹 생성을 하고, 적당한 이름을 붙여주겠습니다. 규칙은 기본으로 작성된 대로 모든 IP에서 접속 가능하도록 하겠습니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_4.png)\n\n다음 인스턴스 시작 검토에서 `시작하기`를 선택하고, `새 키페어 생성`을 선택합니다. 적당한 이름을 붙여주고 `키 페어 다운로드`를 선택합니다.\n\n키 페어 파일(`.pem`)이 다운로드 되면, 파일을 따로 보관해주세요. SSH 연결 시 사용됩니다.\n\n이제 `인스턴스 시작`을 선택합니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_5.png)\n\nAWS EC2 인스턴스 생성을 완료했습니다. EC2 인스턴스 탭에 새로운 인스턴스가 생성되었는지 확인해보세요.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_6.png)\n\n#### 1.2 EC2 인스턴스에 접속하기\n\nEC2 컴퓨터에 접속하는 방법은 여러가지가 있습니다. [여기](https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/AccessingInstances.html)를 참조해 주세요. 저는 이 중에서 Windows에서 [PuTTY를 사용하여 접속](https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/putty.html)하는 방법으로 연결해보겠습니다.\n\n먼저 AWS 설명서의 안내대로 [PuTTY를 설치](https://www.chiark.greenend.org.uk/~sgtatham/putty/)합니다. windows용 최신 버전으로 설치합니다.\n\n설치가 완료되었으면 `PuTTYGen`을 이용하여 `.pem`파일을 `PuTTY`에서 사용되어지는 `.ppk`파일로 변환합니다. `PuTTY`와 함께 설치된 `PuTTYGen`을 실행합니다.\n\n생성할 키 유형을 `RSA`로 선택하고, `Load`를 선택하여 인스턴스를 생성할 때 생성했던 `키 페어(.pem)` 파일을 불러옵니다. 그리고 `Save private key`를 선택하고 `.ppk`형식으로 저장합니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_1.png)\n\n이제 `PuTTY`를 실행해주세요. 아래와 같은 창이 뜨면, 빈칸을 입력해줍니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_2.png)\n\n(1) Hostname: `{username}@{public_dns_name}`형식의 주소를 입력합니다. `username`부분은 `\"Ubuntu\"`이고 `public_dns_name`은 EC2의 주소입니다. 아래 사진처럼 AWS EC2 Management Console에서 해당 인스턴스의 Public Dns를 확인해주세요.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_3.png)\n\n(2) Port: 22(ssh) 포트를 확인해주세요.\n\n(3) Connection Type: SSH 선택을 확인해주세요.\n\n(4) 왼쪽의 메뉴에서 Connection / SSH / Auth 탭을 선택하고, `PuTTYGen`으로 저장한 `.ppk`파일을 불러옵니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_4.png)\n\n(5) 이제 `Open`을 선택합니다. 아래와 같이 보안 알림이 뜨면 `예`를 선택합니다.(인스턴스에 처음으로 접속할 때, 인스턴스 호스트가 신뢰할만 한 지 PuTTY가 묻습니다.)\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_5.png)\n\n아래와 같이 원격 콘솔이 실행되네요. 접속에 성공했습니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_6.png)\n\n---\n\n### 2. RDS 데이터베이스 구성하기\n\nEC2가 웹 애플리케이션 서비스를 담당하는 서버 역할을 한다면, RDS는 웹 서비스의 데이터베이스 서버 역할을 담당합니다. 규모가 작고 트래픽이 적은 서비스라면 EC2 서버 컴퓨터에 로컬로 구성하여 사용할 수 있지만, AWS RDS를 이용하여 데이터베이스를 구성해 보겠습니다.\n\n#### 2.1 RDS 인스턴스 생성하기\n\nAWS의 RDS 페이지로 가서, `데이터베이스 생성`을 선택합니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_rds_instance_1.png)\n\n데이터베이스 엔진을 `Mysql`로 선택하고, 적당한 이름을 설정합니다. 마스터 사용자 이름과 암호를 입력합니다.\n\n그리고 `연결 섹션`에서 `추가 연결 구성`을 열고 `VPC 보안 그룹`을 EC2의 보안그룹과 같은 그룹으로 선택합니다. 이제 `데이터베이스 생성`을 선택하여 다음으로 진행합니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_rds_instance_2.png)\n\n대시보드에서 생성이 완료될 때까지 잠깐 기다립니다.\n\n#### 2.2 RDS 인스턴스에 접속하기\n\nRDS 인스턴스에 접속하기 위해서는 AWS 보안그룹 설정에서 접속을 허용해주어야 합니다. RDS의 보안그룹을 따로 가지면 좋겠지만, 이 포스트에서는 EC2의 보안그룹으로 같이 사용하겠습니다.\n\nEC2와 RDS의 보안그룹 설정으로 들어가주세요. (만약, EC2와 RDS의 보안그룹이 다르다면, 같은 보안그룹으로 설정해주세요.)\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_rds_connect_1.png)\n\n보안 그룹을 선택하고, `인바운드 규칙`을 편집합니다. `규칙 추가`를 선택하여 `Mysql/Aurora`유형을 선택하고, 포트 범위는 `3306`으로 지정합니다. 주소는 현재 보안그룹의 `ID`를 입력하고 저장합니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_rds_connect_2.png)\n\n이제 EC2에서 RDS Mysql(3306) 서버로 접속할 수 있습니다.\n\nEC2 콘솔에서 `mysql-server`를 설치합니다.\n\n```bash\n$ sudo apt-get update\n$ sudo apt-get install mysql-server\n```\n\n그리고 mysql client를 이용하여 RDS의 mysql 서버에 접속합니다.\n\n```bash\n# mysql -u {username} -p -h {rds_endpoint_url}\n# 제 경우에는 아래와 같습니다.\n$ mysql -u development -p -h node-simple-db.ctq3ujxhpaow.ap-northeast-2.rds.amazonaws.com\n\nEnter password: # 패스워드 입력\n```\n\nRDS의 mysql 서버에 접속이 되었다면, 웹 서비스가 사용할 Database를 생성해줍니다. 제가 간단히 작성한 Node 서버는 DB 연결만 이루어지고, 실제 작업은 구현된 게 없어서 따로 테이블은 만들지 않겠습니다.\n\n```mysql\nmysql> CREATE DATABASE node_simple_server;\n```\n\n이제 RDS도 준비되었습니다.\n\n---\n\n### 3. EC2에 웹 서비스 배포하기\n\n#### 3.1 Node.js, NPM 설치하기\n\nEC2에 Node.js가 설치되어 있지 않았다면 설치해주세요.\n\n```bash\n$ sudo apt install nodejs\n$ sudo apt install npm\n\n# 설치 확인\n$ node -v\n$ npm -v\n```\n\n#### 3.2 Node 웹 서버 배포하기\n\n이제 EC2에서 웹 서비스 프로젝트를 불러옵니다. 깃과 깃헙을 이용해서 불러오겠습니다.\n\n```bash\n$ git clone https://github.com/hoontae24/node-simple-server\n$ cd node-simple-server\n$ npm install\n```\n\nRDS 데이터베이스 서버에 연결할 수 있도록 약간의 설정을 수정해주세요. Database HOST, USERNAME, PASSWORD 등의 정보를 알맞게 수정합니다. 그리고 웹 서비스를 빌드하고, 서버를 시작하겠습니다.\n\n```bash\n$ npm run build\n$ npm start\n```\n\n이제 Node 서버가 구동되었는데요, 제가 작성한 Node 서버는 3000번 포트에 열려있습니다. EC2 보안그룹 인바운드 규칙에 3000번 포트를 열어주어야 합니다. (저는 http 전용 포트와 https 전용 포트도 함께 열어주었습니다.)\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_deploy_1.png)\n\n이렇게 포트를 열었으면 EC2 서버에 접속할 수 있습니다. `EC2 퍼블릭 DNS`를 주소창에 입력하고, 접속할 포트번호를 입력해주세요.\n\n```url\nhttp://ec2-54-180-25-154.ap-northeast-2.compute.amazonaws.com:3000/\n```\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_deploy_2.png)\n\n브라우저에서 주소창을 이용해 요청을 보내면 정상적으로 응답이 돌아오는 것을 확인할 수 있습니다.\n\n#### 3.3 Nginx 프록시 서버 구성하기\n\nNode 서버는 3000번 포트에 열려있는데, 일반적으로 서비스 url에는 포트번호를 포함하지 않습니다. 그래서 Nginx 프록시 서버를 이용해 http(80) 또는 https(443) 요청이 오면, 원하는 서비스로 매핑해줄 수 있습니다. 지금의 경우에는 `:3000`을 쓰지 않고 URL만으로 서비스에 요청할 수 있도록 매핑할 것입니다.\n\n먼저 EC2 Ubuntu에 `Nginx`를 설치합니다. 설치가 완료되면 `nginx`를 실행해보겠습니다.\n\n```bash\n# 설치\n$ sudo apt-get install nginx\n\n# 실행\n$ sudo service nginx start\n```\n\nnginx가 실행되었는지 확인하기 위해서, `퍼블릭 DNS`로 접속해봅니다. 브라우저에서 EC2의 url로 접속해보겠습니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_deploy_3.png)\n\nnginx가 잘 실행되니, 웹 서비스로 요청을 분배하도록 설정해주겠습니다.\n\n```bash\n$ sudo find / -name nginx.conf\n# >> /etc/nginx/nginx.conf\n$ cd /etc/nginx/sites-available\n$ sudo vi default\n```\n\n`default` 파일에서 기본 설정으로 되어있는 내용을 지우고 다음과 같이 입력해주세요.\n\n```txt\nserver {\n    listen 80;\n\n    location / {\n      proxy_pass http://127.0.0.1:3000;\n    }\n}\n```\n\n수정된 내용을 저장하고, `nginx`를 다시 시작하겠습니다.\n\n```bash\n$ sudo service nginx restart\n```\n\n이제 `EC2 퍼블릭 DNS`에 포트 번호 없이 접속해보겠습니다.\n\n![사진](/aws/aws-ec2-rds-deploy-setting/img/aws_deploy_4.png)\n\n잘 접속되는 것을 볼 수 있습니다. 이렇게 `nginx`를 이용하면, 웹 서비스가 제공하는 엔드포인트에 EC2서버로 들어오는 요청을 매핑할 수 있습니다. 또한 하나의 EC2 컴퓨터 서버에 여러 개의 서비스를 구동시키고, 각각 다른 엔드포인트로 접근할 수 있게 할 수 있습니다. 만약 프론트 엔드 서버와 API 서버가 있다면 각각을 다음과 같이 매핑할 수 있죠.\n\n- 프론트엔드 서버: {퍼블릭 DNS}/\n- API 서버: {퍼블릭 DNS}/api\n\n다른 두 개의 서비스를 하나의 도메인으로 제공할 수도 있습니다.\n\n---\n\n### 마무리\n\n여기까지 AWS의 클라우드 서비스인 EC2와 RDS를 이용하여 Node.js 웹 서비스를 배포해 보았습니다. 간단히 연결하는 작업만 해보았지만, 막상 하기전에 생각했던 것보다 복잡하지는 않았습니다. 아주 간단하지는 않지만 어떤 식으로 연결하고 구성하는 지 알게 되었습니다.\n\n서비스 규모가 커지거나 복잡해 질수록 더 많은 설정이 필요하겠지만 기본적인 개념을 익힐 수 있는 시간이었던 것 같습니다. 다음에는 AWS의 다른 클라우드 서비스나, Google Firebase, Microsoft Azure와 같은 다른 서비스를 알아보는 시간도 가져보겠습니다.\n","html":"<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_node.png\" alt=\"aws, node\"></p>\n<p>보통의 웹 서비스는 서버를 이용하여 서비스를 제공합니다. 서버 컴퓨터를 직접 구성해서 할 수도 있지만, 요즘에는 클라우드 서비스를 많이 이용합니다. 클라우드 서비스를 이용하면 물리적으로 서버를 직접 구성하거나 가지고 있지 않아도 되고, 내가 사용할 서비스에만 집중하여 서버를 운영할 수 있습니다. 이번 포스트에서는 대표적인 클라우드 컴퓨팅 서비스 중 하나인 Amazon Web Service(AWS)를 이용하여 Node.js 서버를 배포해보겠습니다.</p>\n<p>오늘 배포할 웹 서비스 환경은 다음과 같이 구성됩니다.</p>\n<ul>\n<li>Node.js 웹 어플리케이션</li>\n<li>AWS EC2와 Ubuntu (+ nginx 프록시)</li>\n<li>AWS RDS와 Mysql</li>\n</ul>\n<p>우리가 만든(미리 만들어둔) 웹 어플리케이션을 EC2의 Ubuntu에 구성할 것입니다. 그리고 서비스에 사용될 데이터베이스는 RDS의 Mysql 서버를 구성할 것입니다.</p>\n<hr>\n<h3 id=\"0-nodejs-웹-어플리케이션-준비하기\">0. Node.js 웹 어플리케이션 준비하기</h3>\n<p>우리의 웹 서비스가 실제로 동작할 웹 어플리케이션이 필요합니다. 여기서는 Node.js 웹 어플리케이션을 사용할 것인데, 간단한 Node.js REST Api 서버를 만듭니다. <em>(Node.js 어플리케이션에 대한 부분은 자세히 다루지 않습니다.)</em></p>\n<p>저는 미리 준비한 Node 앱을 가져오겠습니다. 먼저 로컬에 설치해서 잘 동작하는 지 확인해볼게요. 코드를 깃헙에서 가져오고, 빌드 후 구동합니다.</p>\n<pre><code class=\"language-bash\">$ git clone https://github.com/hoontae24/node-simple-server.git\n$ cd simple-node-server\n$ npm install\n$ npm run build\n$ npm start\n</code></pre>\n<p>서버가 시작하고, 브라우저에서 요청을 보내어 동작을 확인해봅니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/node_simple_server.png\" alt=\"사진\"></p>\n<p>간단한 응답이 도착하네요. 로컬에서 서버가 잘 동작하는 것 같습니다. 서버를 종료해줍니다.</p>\n<pre><code class=\"language-bash\">$ npm run stop\n</code></pre>\n<hr>\n<h3 id=\"1-ec2-서버-구성하기\">1. EC2 서버 구성하기</h3>\n<p>EC2(Amazon Elastic Compute Cloud)는 클라우드에서 컴퓨팅 서비스를 이용할 수 있도록 해줍니다. AWS에서 인스턴스를 만들고, SSH로 원격 연결을 통해 서버 컴퓨터를 제어할 수 있습니다.</p>\n<h4 id=\"11-ec2-인스턴스-만들기\">1.1 EC2 인스턴스 만들기</h4>\n<p>AWS로 가서 EC2 인스턴스를 만들어 봅시다. <a href=\"https://ap-northeast-2.console.aws.amazon.com/ec2/home?region=ap-northeast-2\">EC2 Management Console</a>에 들어가서 <code>인스턴스 시작</code>을 선택합니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_1.png\" alt=\"사진\"></p>\n<p>AMI 템플릿은 빠른시작 탭에서 <code>Ubuntu Server 18버전</code>을 선택하겠습니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_2.png\" alt=\"사진\"></p>\n<p>인스턴스는 기본으로 선택되어있는 <code>t2.micro 유형</code>을 선택하겠습니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_3.png\" alt=\"사진\"></p>\n<p>저는 새 보안 그룹 생성을 하고, 적당한 이름을 붙여주겠습니다. 규칙은 기본으로 작성된 대로 모든 IP에서 접속 가능하도록 하겠습니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_4.png\" alt=\"사진\"></p>\n<p>다음 인스턴스 시작 검토에서 <code>시작하기</code>를 선택하고, <code>새 키페어 생성</code>을 선택합니다. 적당한 이름을 붙여주고 <code>키 페어 다운로드</code>를 선택합니다.</p>\n<p>키 페어 파일(<code>.pem</code>)이 다운로드 되면, 파일을 따로 보관해주세요. SSH 연결 시 사용됩니다.</p>\n<p>이제 <code>인스턴스 시작</code>을 선택합니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_5.png\" alt=\"사진\"></p>\n<p>AWS EC2 인스턴스 생성을 완료했습니다. EC2 인스턴스 탭에 새로운 인스턴스가 생성되었는지 확인해보세요.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_instance_6.png\" alt=\"사진\"></p>\n<h4 id=\"12-ec2-인스턴스에-접속하기\">1.2 EC2 인스턴스에 접속하기</h4>\n<p>EC2 컴퓨터에 접속하는 방법은 여러가지가 있습니다. <a href=\"https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/AccessingInstances.html\">여기</a>를 참조해 주세요. 저는 이 중에서 Windows에서 <a href=\"https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/putty.html\">PuTTY를 사용하여 접속</a>하는 방법으로 연결해보겠습니다.</p>\n<p>먼저 AWS 설명서의 안내대로 <a href=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/\">PuTTY를 설치</a>합니다. windows용 최신 버전으로 설치합니다.</p>\n<p>설치가 완료되었으면 <code>PuTTYGen</code>을 이용하여 <code>.pem</code>파일을 <code>PuTTY</code>에서 사용되어지는 <code>.ppk</code>파일로 변환합니다. <code>PuTTY</code>와 함께 설치된 <code>PuTTYGen</code>을 실행합니다.</p>\n<p>생성할 키 유형을 <code>RSA</code>로 선택하고, <code>Load</code>를 선택하여 인스턴스를 생성할 때 생성했던 <code>키 페어(.pem)</code> 파일을 불러옵니다. 그리고 <code>Save private key</code>를 선택하고 <code>.ppk</code>형식으로 저장합니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_1.png\" alt=\"사진\"></p>\n<p>이제 <code>PuTTY</code>를 실행해주세요. 아래와 같은 창이 뜨면, 빈칸을 입력해줍니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_2.png\" alt=\"사진\"></p>\n<p>(1) Hostname: <code>{username}@{public_dns_name}</code>형식의 주소를 입력합니다. <code>username</code>부분은 <code>&quot;Ubuntu&quot;</code>이고 <code>public_dns_name</code>은 EC2의 주소입니다. 아래 사진처럼 AWS EC2 Management Console에서 해당 인스턴스의 Public Dns를 확인해주세요.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_3.png\" alt=\"사진\"></p>\n<p>(2) Port: 22(ssh) 포트를 확인해주세요.</p>\n<p>(3) Connection Type: SSH 선택을 확인해주세요.</p>\n<p>(4) 왼쪽의 메뉴에서 Connection / SSH / Auth 탭을 선택하고, <code>PuTTYGen</code>으로 저장한 <code>.ppk</code>파일을 불러옵니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_4.png\" alt=\"사진\"></p>\n<p>(5) 이제 <code>Open</code>을 선택합니다. 아래와 같이 보안 알림이 뜨면 <code>예</code>를 선택합니다.(인스턴스에 처음으로 접속할 때, 인스턴스 호스트가 신뢰할만 한 지 PuTTY가 묻습니다.)</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_5.png\" alt=\"사진\"></p>\n<p>아래와 같이 원격 콘솔이 실행되네요. 접속에 성공했습니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_ec2_connect_6.png\" alt=\"사진\"></p>\n<hr>\n<h3 id=\"2-rds-데이터베이스-구성하기\">2. RDS 데이터베이스 구성하기</h3>\n<p>EC2가 웹 애플리케이션 서비스를 담당하는 서버 역할을 한다면, RDS는 웹 서비스의 데이터베이스 서버 역할을 담당합니다. 규모가 작고 트래픽이 적은 서비스라면 EC2 서버 컴퓨터에 로컬로 구성하여 사용할 수 있지만, AWS RDS를 이용하여 데이터베이스를 구성해 보겠습니다.</p>\n<h4 id=\"21-rds-인스턴스-생성하기\">2.1 RDS 인스턴스 생성하기</h4>\n<p>AWS의 RDS 페이지로 가서, <code>데이터베이스 생성</code>을 선택합니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_rds_instance_1.png\" alt=\"사진\"></p>\n<p>데이터베이스 엔진을 <code>Mysql</code>로 선택하고, 적당한 이름을 설정합니다. 마스터 사용자 이름과 암호를 입력합니다.</p>\n<p>그리고 <code>연결 섹션</code>에서 <code>추가 연결 구성</code>을 열고 <code>VPC 보안 그룹</code>을 EC2의 보안그룹과 같은 그룹으로 선택합니다. 이제 <code>데이터베이스 생성</code>을 선택하여 다음으로 진행합니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_rds_instance_2.png\" alt=\"사진\"></p>\n<p>대시보드에서 생성이 완료될 때까지 잠깐 기다립니다.</p>\n<h4 id=\"22-rds-인스턴스에-접속하기\">2.2 RDS 인스턴스에 접속하기</h4>\n<p>RDS 인스턴스에 접속하기 위해서는 AWS 보안그룹 설정에서 접속을 허용해주어야 합니다. RDS의 보안그룹을 따로 가지면 좋겠지만, 이 포스트에서는 EC2의 보안그룹으로 같이 사용하겠습니다.</p>\n<p>EC2와 RDS의 보안그룹 설정으로 들어가주세요. (만약, EC2와 RDS의 보안그룹이 다르다면, 같은 보안그룹으로 설정해주세요.)</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_rds_connect_1.png\" alt=\"사진\"></p>\n<p>보안 그룹을 선택하고, <code>인바운드 규칙</code>을 편집합니다. <code>규칙 추가</code>를 선택하여 <code>Mysql/Aurora</code>유형을 선택하고, 포트 범위는 <code>3306</code>으로 지정합니다. 주소는 현재 보안그룹의 <code>ID</code>를 입력하고 저장합니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_rds_connect_2.png\" alt=\"사진\"></p>\n<p>이제 EC2에서 RDS Mysql(3306) 서버로 접속할 수 있습니다.</p>\n<p>EC2 콘솔에서 <code>mysql-server</code>를 설치합니다.</p>\n<pre><code class=\"language-bash\">$ sudo apt-get update\n$ sudo apt-get install mysql-server\n</code></pre>\n<p>그리고 mysql client를 이용하여 RDS의 mysql 서버에 접속합니다.</p>\n<pre><code class=\"language-bash\"># mysql -u {username} -p -h {rds_endpoint_url}\n# 제 경우에는 아래와 같습니다.\n$ mysql -u development -p -h node-simple-db.ctq3ujxhpaow.ap-northeast-2.rds.amazonaws.com\n\nEnter password: # 패스워드 입력\n</code></pre>\n<p>RDS의 mysql 서버에 접속이 되었다면, 웹 서비스가 사용할 Database를 생성해줍니다. 제가 간단히 작성한 Node 서버는 DB 연결만 이루어지고, 실제 작업은 구현된 게 없어서 따로 테이블은 만들지 않겠습니다.</p>\n<pre><code class=\"language-mysql\">mysql&gt; CREATE DATABASE node_simple_server;\n</code></pre>\n<p>이제 RDS도 준비되었습니다.</p>\n<hr>\n<h3 id=\"3-ec2에-웹-서비스-배포하기\">3. EC2에 웹 서비스 배포하기</h3>\n<h4 id=\"31-nodejs-npm-설치하기\">3.1 Node.js, NPM 설치하기</h4>\n<p>EC2에 Node.js가 설치되어 있지 않았다면 설치해주세요.</p>\n<pre><code class=\"language-bash\">$ sudo apt install nodejs\n$ sudo apt install npm\n\n# 설치 확인\n$ node -v\n$ npm -v\n</code></pre>\n<h4 id=\"32-node-웹-서버-배포하기\">3.2 Node 웹 서버 배포하기</h4>\n<p>이제 EC2에서 웹 서비스 프로젝트를 불러옵니다. 깃과 깃헙을 이용해서 불러오겠습니다.</p>\n<pre><code class=\"language-bash\">$ git clone https://github.com/hoontae24/node-simple-server\n$ cd node-simple-server\n$ npm install\n</code></pre>\n<p>RDS 데이터베이스 서버에 연결할 수 있도록 약간의 설정을 수정해주세요. Database HOST, USERNAME, PASSWORD 등의 정보를 알맞게 수정합니다. 그리고 웹 서비스를 빌드하고, 서버를 시작하겠습니다.</p>\n<pre><code class=\"language-bash\">$ npm run build\n$ npm start\n</code></pre>\n<p>이제 Node 서버가 구동되었는데요, 제가 작성한 Node 서버는 3000번 포트에 열려있습니다. EC2 보안그룹 인바운드 규칙에 3000번 포트를 열어주어야 합니다. (저는 http 전용 포트와 https 전용 포트도 함께 열어주었습니다.)</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_deploy_1.png\" alt=\"사진\"></p>\n<p>이렇게 포트를 열었으면 EC2 서버에 접속할 수 있습니다. <code>EC2 퍼블릭 DNS</code>를 주소창에 입력하고, 접속할 포트번호를 입력해주세요.</p>\n<pre><code class=\"language-url\">http://ec2-54-180-25-154.ap-northeast-2.compute.amazonaws.com:3000/\n</code></pre>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_deploy_2.png\" alt=\"사진\"></p>\n<p>브라우저에서 주소창을 이용해 요청을 보내면 정상적으로 응답이 돌아오는 것을 확인할 수 있습니다.</p>\n<h4 id=\"33-nginx-프록시-서버-구성하기\">3.3 Nginx 프록시 서버 구성하기</h4>\n<p>Node 서버는 3000번 포트에 열려있는데, 일반적으로 서비스 url에는 포트번호를 포함하지 않습니다. 그래서 Nginx 프록시 서버를 이용해 http(80) 또는 https(443) 요청이 오면, 원하는 서비스로 매핑해줄 수 있습니다. 지금의 경우에는 <code>:3000</code>을 쓰지 않고 URL만으로 서비스에 요청할 수 있도록 매핑할 것입니다.</p>\n<p>먼저 EC2 Ubuntu에 <code>Nginx</code>를 설치합니다. 설치가 완료되면 <code>nginx</code>를 실행해보겠습니다.</p>\n<pre><code class=\"language-bash\"># 설치\n$ sudo apt-get install nginx\n\n# 실행\n$ sudo service nginx start\n</code></pre>\n<p>nginx가 실행되었는지 확인하기 위해서, <code>퍼블릭 DNS</code>로 접속해봅니다. 브라우저에서 EC2의 url로 접속해보겠습니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_deploy_3.png\" alt=\"사진\"></p>\n<p>nginx가 잘 실행되니, 웹 서비스로 요청을 분배하도록 설정해주겠습니다.</p>\n<pre><code class=\"language-bash\">$ sudo find / -name nginx.conf\n# &gt;&gt; /etc/nginx/nginx.conf\n$ cd /etc/nginx/sites-available\n$ sudo vi default\n</code></pre>\n<p><code>default</code> 파일에서 기본 설정으로 되어있는 내용을 지우고 다음과 같이 입력해주세요.</p>\n<pre><code class=\"language-txt\">server {\n    listen 80;\n\n    location / {\n      proxy_pass http://127.0.0.1:3000;\n    }\n}\n</code></pre>\n<p>수정된 내용을 저장하고, <code>nginx</code>를 다시 시작하겠습니다.</p>\n<pre><code class=\"language-bash\">$ sudo service nginx restart\n</code></pre>\n<p>이제 <code>EC2 퍼블릭 DNS</code>에 포트 번호 없이 접속해보겠습니다.</p>\n<p><img src=\"/aws/aws-ec2-rds-deploy-setting/img/aws_deploy_4.png\" alt=\"사진\"></p>\n<p>잘 접속되는 것을 볼 수 있습니다. 이렇게 <code>nginx</code>를 이용하면, 웹 서비스가 제공하는 엔드포인트에 EC2서버로 들어오는 요청을 매핑할 수 있습니다. 또한 하나의 EC2 컴퓨터 서버에 여러 개의 서비스를 구동시키고, 각각 다른 엔드포인트로 접근할 수 있게 할 수 있습니다. 만약 프론트 엔드 서버와 API 서버가 있다면 각각을 다음과 같이 매핑할 수 있죠.</p>\n<ul>\n<li>프론트엔드 서버: {퍼블릭 DNS}/</li>\n<li>API 서버: {퍼블릭 DNS}/api</li>\n</ul>\n<p>다른 두 개의 서비스를 하나의 도메인으로 제공할 수도 있습니다.</p>\n<hr>\n<h3 id=\"마무리\">마무리</h3>\n<p>여기까지 AWS의 클라우드 서비스인 EC2와 RDS를 이용하여 Node.js 웹 서비스를 배포해 보았습니다. 간단히 연결하는 작업만 해보았지만, 막상 하기전에 생각했던 것보다 복잡하지는 않았습니다. 아주 간단하지는 않지만 어떤 식으로 연결하고 구성하는 지 알게 되었습니다.</p>\n<p>서비스 규모가 커지거나 복잡해 질수록 더 많은 설정이 필요하겠지만 기본적인 개념을 익힐 수 있는 시간이었던 것 같습니다. 다음에는 AWS의 다른 클라우드 서비스나, Google Firebase, Microsoft Azure와 같은 다른 서비스를 알아보는 시간도 가져보겠습니다.</p>\n","excerpt":" 보통의 웹 서비스는 서버를 이용하여 서비스를 제공합니다. 서버 컴퓨터를 직접 구성해서 할 수도 있지만, 요즘에는 클라우드 서비스를 많이 이용합니다. 클라우드 서비스를 이용하면 물리적으로 서버를 직접 구성하거나 가지고 있지 않아도 되고, 내가 사용할 서비스에만 집중하여 서버를 운영할 수 있습니다. 이번 포스트에서는 대표적인 클라우드 컴퓨팅 서비스 중 하나인 ","thumbnail":"/aws/aws-ec2-rds-deploy-setting/img/aws_node.png","thumbnailUrl":"https://hoontae24.github.io/aws/aws-ec2-rds-deploy-setting/img/aws_node.png"},{"href":"9","round":9,"paths":["node","node-dev-environment-babel-typescript-eslint"],"slug":"node-dev-environment-babel-typescript-eslint","title":"Node와 Babel + Typesciprt + Eslint 개발 환경 구성하기","description":"","date":"2020-02-07","category":"node","tags":["node","babel","typescript","eslint"],"seriesId":null,"markdown":"\n![babel, typescript, eslint](/node/node-dev-environment-babel-typescript-eslint/img/babel_typescript_eslint.png)\n\n애플리케이션을 개발할 때, 애플리케이션 자체에 대한 것이 아닌 개발자가 개발을 편하게 할 수 있도록 돕는 여러 가지 도구들이 있습니다. 개발에 앞서 그러한 개발 도구들로 개발 환경을 구성한 후, 개발을 하게 되는데요. 이 글에서는 Node.js를 기반으로 하고, `Babel` `Typescript` `Eslint`를 이용하여 개발환경을 구성해 보겠습니다.\n\n- Node.js: 자바스크립트 런타임\n- Babel: 자바스크립트 컴파일러, 최신 버전의 자바스크립트를 이전 버전으로 변환\n- Typescript: Type을 명시한 자바스크립트 슈퍼셋, 컴파일하여 자바스크립트로 변환\n- Eslint: 자바스크립트 문법 및 코딩 스타일 검사 툴\n\n_(이 글에서는 babel, typescript, eslint에 대한 소개나 개념은 깊이 다루지 않습니다.)_\n\n추가적으로 저는 VSCode를 이용하고, extensions으로 Eslint와 Prettier를 사용하는데요. 이 부분에 대해서도 함께 다루어 보겠습니다.\n\n[참조] 이 글을 작성하면서 아래의 글에 도움을 받았습니다.\n\n- [@babel/preset-typescript](https://babeljs.io/docs/en/babel-preset-typescript)\n- [바벨과 타입스크립트의 아름다운 결혼 - TOAST UI](https://ui.toast.com/weekly-pick/ko_20181220/)\n- [TypeScript ESLint 적용하기 (+ Airbnb) - Be an Overachiever](https://ivvve.github.io/2019/10/09/js/ts/typescript-eslint&airbnb/)\n\n---\n\n### Babel\n\n먼저 프로젝트 폴더에서 `npm init -y` 커맨드를 실행하여 `package.json` 파일이 생성합니다. 이제 Babel과 관련된 패키지를 설치해보겠습니다. 다음 커맨드를 실행해주세요.\n\n```bash\n$ npm i -D @babel/core @babel/cli @babel/node @babel/preset-env\n```\n\n- @babel/core: babel의 코어에 해당합니다.\n- @babel/cli: 터미널에서 babel 관련 커맨드를 실행해줍니다.\n- @babel/node: babel로 Node.js 런타임을 실행해줍니다.\n- @babel/preset-env: babel의 설정이 조합된 프리셋\n\n설치가 끝나면 루트 디렉토리에 `babel.config.json` 파일을 만들고 다음과 같이 작성합니다.\n\n```json\n{\n  \"presets\": [\"@babel/preset-env\"]\n}\n```\n\n**babel**을 이용하여 컴파일할 때에는 여러 가지 설정을 해서 컴파일을 할 수 있습니다. 그러한 설정들을 미리 조합해둔 프리셋을 지정해주었습니다.\n\nbabel의 동작을 한번 확인해 볼까요? `src`폴더를 만들고 `index.js` 파일을 다음과 같이 작성해주세요.\n\n```js\n// src/index.js\n// module import 방식\nimport fs from \"fs\";\n\n// arrow function 방식\nfs.readFile(\"package.json\", (err, data) => {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log(data);\n});\n```\n\n그리고 `package.json`의 `scripts`를 다음과 같이 작성합니다.\n\n```json\n\"scripts\": {\n  \"build\": \"babel -d dist/ src\",\n  \"dev\": \"babel-node index.js\"\n}\n```\n\n`build`명령어는 `src`폴더의 파일들을 `babel`로 컴파일하고, `dist`폴더에 저장하는 구문입니다. 이제 babel을 이용해 `index.js`파일을 컴파일 해봅시다.\n\n```bash\n$ npm run build\n```\n\n프로젝트 폴더에 `dist`폴더가 생겼나요? 그 안에 `index.js`파일을 열어보세요. 기존에 작성된 `index.js` 파일의 `import`문법이나, `arrow function`문법이 다르게 변경된 것을 볼 수 있을 것입니다. `@babel/preset-env`에 미리 조합된 설정들로 컴파일된 것입니다.\n\n---\n\n### Typescript\n\n**typescript는** `.ts`의 확장자의 파일로 작성됩니다. typescript만의 문법으로 작성된 `.ts`파일을 **typescript** 컴파일러로 컴파일을 하면 `.js`파일로 변환됩니다. typescript만으로도 따로 사용할 수 있지만, 이번 프로젝트에서는 **babel**과 함께 사용해 보겠습니다.\n\n먼저 `index.js`파일을 `index.ts`파일로 이름을 변경합니다. 그리고 약간의 typescript 문법을 추가해보겠습니다. 다음과 같이 수정해주세요.\n\n```js\nimport fs from \"fs\";\n\n// typescript 문법\nlet count: number = 0;\nfs.readFile(\"package.json\", \"utf-8\", (err, data) => {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  count = data.split(\"\\n\").length;\n  console.log(count + \" lines\");\n});\n```\n\n`.ts`파일을 babel이 읽을 수 있도록 `package.json`의 `scripts`를 변경해줍니다.\n\n```json\n\"scripts\": {\n  \"build\": \"babel -d dist/ --extensions \\\".ts\\\" src\",\n  \"dev\": \"babel-node index.js\"\n}\n```\n\ntypescript 문법을 추가하고 `npm run build`로 babel을 실행하여 컴파일하면 에러가 발생합니다. babel의 설정이 typescript 문법을 읽지 못하기 때문인데요. typescript를 위한 설정을 해주겠습니다. 다음을 실행해서 패키지를 설치합니다.\n\n```bash\n$ npm i -D @babel/preset-typescript\n```\n\n그리고 `babel.config.json`파일을 수정해주세요.\n\n```json\n{\n  \"presets\": [\"@babel/preset-env\", \"@babel/preset-typescript\"]\n}\n```\n\n이제 `npm run build`명령을 실행해 보세요. babel이 typescript 문법을 인식하여 에러로 처리하지 않습니다.\n\ntypescript를 컴파일할 때에도 몇가지 옵션을 설정할 수 있습니다. typescript 패키지를 설치하고, `tsconfig.json`파일을 만들어 설정해주겠습니다.\n\n```bash\n$ npm i -D npm-run-all typescript\n```\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ESNEXT\",\n    \"allowJs\": true,\n    \"declaration\": true,\n    \"outDir\": \"dist\",\n    \"isolatedModules\": true,\n    \"strict\": true,\n    \"noImplicitAny\": false,\n    \"moduleResolution\": \"node\",\n    \"baseUrl\": \"src\",\n    \"paths\": {},\n    \"esModuleInterop\": true,\n    \"experimentalDecorators\": true\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\ntypescript 타입 체크 명령어를 포함하도록 `package.json`의 `scripts`를 다음과 같이 변경해줍니다.\n\n```json\n\"scripts\": {\n  \"dev\": \"babel-node index.js\",\n  \"build\": \"npm-run-all types:check build:js\",\n  \"build:js\": \"babel -d dist --extensions \\\".js,.ts\\\" src\",\n  \"types:check\": \"tsc --noEmit\"\n}\n```\n\n`tsc --noEmit` 명령어를 실행하면, typescript의 타입체크만 이루어지고, 컴파일은 하지 않습니다. `npm run build`를 실행하여 typescript 타입 체크와 babel의 컴파일을 실행해봅시다.\n\n```bash\n$ npm run build\n```\n\n혹시 `Cannot find module 'fs'` 에러가 발생 하셨나요? 이 에러는 typescript가 모듈을 찾지 못해 생기는 오류입니다. 다음 패키지를 설치해주세요.\n\n```bash\n$ npm i -D @types/node\n```\n\n---\n\n### Eslint\n\n**eslint**를 이용해서 코드 문법을 검사하고, 코딩 스타일도 함께 체크해보는 기능을 추가하겠습니다.\n\n먼저 eslint를 설치합니다. 그리고 필요한 몇가지 패키지도 함께 설치하겠습니다.\n\n```bash\n$ npm i -D eslint eslint-config-airbnb-base eslint-plugin-import\n\n$ npm i -D @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n설치가 되었다면 `.eslintrc`파일을 생성해주세요.\n\n```json\n{\n  \"parser\": \"@typescript-eslint/parser\",\n  \"plugins\": [\"@typescript-eslint\"],\n  \"extends\": [\n    \"eslint-config-airbnb-base\",\n    \"plugin:@typescript-eslint/eslint-recommended\"\n  ]\n}\n```\n\n그리고 eslint를 실행하는 `scripts`를 `package.json`에 추가합니다.\n\n```json\n\"scripts\": {\n  \"lint:check\": \"eslint src/**/*.ts\",\n  \"lint:fix\": \"eslint --fix src/**/*.ts\"\n}\n```\n\n이제 `lint:check`를 실행하면, eslint가 `.eslintrc`의 설정으로 문법 및 코딩 스타일을 체크해줍니다. `lint:fix`를 실행하면 코드를 자동으로 고쳐줍니다.\n\n---\n\n#### Eslint - Prettier 함께 사용하기\n\n저는 VSCode에서 Prettier와 Eslint를 함께 사용하는데요, Prettier의 설정과 Eslint의 설정이 충돌을 일으키기 때문에 따로 설정을 해 주어야 합니다. 그렇지 않으면 같은 내용의 설정을 eslint와 prettier에서 각각 두번 해주어야 하는 불편함이 생기기 때문입니다.\n\neslint의 관련 패키지를 설치해줍니다.\n\n```bash\n$ npm i -D eslint-config-prettier eslint-plugin-prettier prettier\n```\n\n그리고 `.eslintrc`파일의 `extends` 부분에 다음을 추가해줍니다.\n\n```json\n\"extends\": [\n  \"plugin:prettier/recommended\"\n]\n```\n\n위 설정에는 두 가지가 적용되는데요. 첫번째로 `eslint-config-prettier`는 eslint와 prettier의 충돌되는 규칙들을 eslint가 무시해줍니다. prettier로 설정될 부분들은 eslint에서 담당하지 않겠다는 뜻입니다.\n\n두번째로 `eslint-plugin-prettier`는 prettier에서 설정한 규칙들을 eslint의 에러로 표시한다는 뜻입니다. 충돌되는 규칙들을 eslint가 무시해준다면 해당 규칙들에 대해 에러를 표시할 수 있도록 prettier의 규칙들을 에러로 표시한다는 것입니다.\n\n`.prettierrc` 파일을 만들어 prettier에 적용할 규칙을 작성해주세요.\n\n```json\n{\n  \"singleQuote\": true\n}\n```\n\n이렇게 하면 `.prettierrc`에 적용된 규칙은 eslint가 간섭하지 않습니다. 또한 그 규칙들에 대한 오류를 eslint가 'prettier'라는 이름의 규칙으로 표시해줍니다.\n\n---\n\n### 마무리\n\nbabel과 typescript를 적용한 컴파일 설정과 eslint를 통해 코드를 검사하고 수정하는 부분을 구성해 보았습니다. 가장 기본적인 설정 방법을 함께 적용해보았는데요, 사용자에 맞게 더 많은 기능을 추가할 수도 있습니다.\n\n기회가 된다면 세부적인 기능들에 대한 리뷰와 적용기도 한 번 작성해보도록 하겠습니다.\n","html":"<p><img src=\"/node/node-dev-environment-babel-typescript-eslint/img/babel_typescript_eslint.png\" alt=\"babel, typescript, eslint\"></p>\n<p>애플리케이션을 개발할 때, 애플리케이션 자체에 대한 것이 아닌 개발자가 개발을 편하게 할 수 있도록 돕는 여러 가지 도구들이 있습니다. 개발에 앞서 그러한 개발 도구들로 개발 환경을 구성한 후, 개발을 하게 되는데요. 이 글에서는 Node.js를 기반으로 하고, <code>Babel</code> <code>Typescript</code> <code>Eslint</code>를 이용하여 개발환경을 구성해 보겠습니다.</p>\n<ul>\n<li>Node.js: 자바스크립트 런타임</li>\n<li>Babel: 자바스크립트 컴파일러, 최신 버전의 자바스크립트를 이전 버전으로 변환</li>\n<li>Typescript: Type을 명시한 자바스크립트 슈퍼셋, 컴파일하여 자바스크립트로 변환</li>\n<li>Eslint: 자바스크립트 문법 및 코딩 스타일 검사 툴</li>\n</ul>\n<p><em>(이 글에서는 babel, typescript, eslint에 대한 소개나 개념은 깊이 다루지 않습니다.)</em></p>\n<p>추가적으로 저는 VSCode를 이용하고, extensions으로 Eslint와 Prettier를 사용하는데요. 이 부분에 대해서도 함께 다루어 보겠습니다.</p>\n<p>[참조] 이 글을 작성하면서 아래의 글에 도움을 받았습니다.</p>\n<ul>\n<li><a href=\"https://babeljs.io/docs/en/babel-preset-typescript\">@babel/preset-typescript</a></li>\n<li><a href=\"https://ui.toast.com/weekly-pick/ko_20181220/\">바벨과 타입스크립트의 아름다운 결혼 - TOAST UI</a></li>\n<li><a href=\"https://ivvve.github.io/2019/10/09/js/ts/typescript-eslint&amp;airbnb/\">TypeScript ESLint 적용하기 (+ Airbnb) - Be an Overachiever</a></li>\n</ul>\n<hr>\n<h3 id=\"babel\">Babel</h3>\n<p>먼저 프로젝트 폴더에서 <code>npm init -y</code> 커맨드를 실행하여 <code>package.json</code> 파일이 생성합니다. 이제 Babel과 관련된 패키지를 설치해보겠습니다. 다음 커맨드를 실행해주세요.</p>\n<pre><code class=\"language-bash\">$ npm i -D @babel/core @babel/cli @babel/node @babel/preset-env\n</code></pre>\n<ul>\n<li>@babel/core: babel의 코어에 해당합니다.</li>\n<li>@babel/cli: 터미널에서 babel 관련 커맨드를 실행해줍니다.</li>\n<li>@babel/node: babel로 Node.js 런타임을 실행해줍니다.</li>\n<li>@babel/preset-env: babel의 설정이 조합된 프리셋</li>\n</ul>\n<p>설치가 끝나면 루트 디렉토리에 <code>babel.config.json</code> 파일을 만들고 다음과 같이 작성합니다.</p>\n<pre><code class=\"language-json\">{\n  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]\n}\n</code></pre>\n<p><strong>babel</strong>을 이용하여 컴파일할 때에는 여러 가지 설정을 해서 컴파일을 할 수 있습니다. 그러한 설정들을 미리 조합해둔 프리셋을 지정해주었습니다.</p>\n<p>babel의 동작을 한번 확인해 볼까요? <code>src</code>폴더를 만들고 <code>index.js</code> 파일을 다음과 같이 작성해주세요.</p>\n<pre><code class=\"language-js\">// src/index.js\n// module import 방식\nimport fs from &quot;fs&quot;;\n\n// arrow function 방식\nfs.readFile(&quot;package.json&quot;, (err, data) =&gt; {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log(data);\n});\n</code></pre>\n<p>그리고 <code>package.json</code>의 <code>scripts</code>를 다음과 같이 작성합니다.</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;build&quot;: &quot;babel -d dist/ src&quot;,\n  &quot;dev&quot;: &quot;babel-node index.js&quot;\n}\n</code></pre>\n<p><code>build</code>명령어는 <code>src</code>폴더의 파일들을 <code>babel</code>로 컴파일하고, <code>dist</code>폴더에 저장하는 구문입니다. 이제 babel을 이용해 <code>index.js</code>파일을 컴파일 해봅시다.</p>\n<pre><code class=\"language-bash\">$ npm run build\n</code></pre>\n<p>프로젝트 폴더에 <code>dist</code>폴더가 생겼나요? 그 안에 <code>index.js</code>파일을 열어보세요. 기존에 작성된 <code>index.js</code> 파일의 <code>import</code>문법이나, <code>arrow function</code>문법이 다르게 변경된 것을 볼 수 있을 것입니다. <code>@babel/preset-env</code>에 미리 조합된 설정들로 컴파일된 것입니다.</p>\n<hr>\n<h3 id=\"typescript\">Typescript</h3>\n<p><strong>typescript는</strong> <code>.ts</code>의 확장자의 파일로 작성됩니다. typescript만의 문법으로 작성된 <code>.ts</code>파일을 <strong>typescript</strong> 컴파일러로 컴파일을 하면 <code>.js</code>파일로 변환됩니다. typescript만으로도 따로 사용할 수 있지만, 이번 프로젝트에서는 <strong>babel</strong>과 함께 사용해 보겠습니다.</p>\n<p>먼저 <code>index.js</code>파일을 <code>index.ts</code>파일로 이름을 변경합니다. 그리고 약간의 typescript 문법을 추가해보겠습니다. 다음과 같이 수정해주세요.</p>\n<pre><code class=\"language-js\">import fs from &quot;fs&quot;;\n\n// typescript 문법\nlet count: number = 0;\nfs.readFile(&quot;package.json&quot;, &quot;utf-8&quot;, (err, data) =&gt; {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  count = data.split(&quot;\\n&quot;).length;\n  console.log(count + &quot; lines&quot;);\n});\n</code></pre>\n<p><code>.ts</code>파일을 babel이 읽을 수 있도록 <code>package.json</code>의 <code>scripts</code>를 변경해줍니다.</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;build&quot;: &quot;babel -d dist/ --extensions \\&quot;.ts\\&quot; src&quot;,\n  &quot;dev&quot;: &quot;babel-node index.js&quot;\n}\n</code></pre>\n<p>typescript 문법을 추가하고 <code>npm run build</code>로 babel을 실행하여 컴파일하면 에러가 발생합니다. babel의 설정이 typescript 문법을 읽지 못하기 때문인데요. typescript를 위한 설정을 해주겠습니다. 다음을 실행해서 패키지를 설치합니다.</p>\n<pre><code class=\"language-bash\">$ npm i -D @babel/preset-typescript\n</code></pre>\n<p>그리고 <code>babel.config.json</code>파일을 수정해주세요.</p>\n<pre><code class=\"language-json\">{\n  &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-typescript&quot;]\n}\n</code></pre>\n<p>이제 <code>npm run build</code>명령을 실행해 보세요. babel이 typescript 문법을 인식하여 에러로 처리하지 않습니다.</p>\n<p>typescript를 컴파일할 때에도 몇가지 옵션을 설정할 수 있습니다. typescript 패키지를 설치하고, <code>tsconfig.json</code>파일을 만들어 설정해주겠습니다.</p>\n<pre><code class=\"language-bash\">$ npm i -D npm-run-all typescript\n</code></pre>\n<pre><code class=\"language-json\">{\n  &quot;compilerOptions&quot;: {\n    &quot;target&quot;: &quot;ESNEXT&quot;,\n    &quot;allowJs&quot;: true,\n    &quot;declaration&quot;: true,\n    &quot;outDir&quot;: &quot;dist&quot;,\n    &quot;isolatedModules&quot;: true,\n    &quot;strict&quot;: true,\n    &quot;noImplicitAny&quot;: false,\n    &quot;moduleResolution&quot;: &quot;node&quot;,\n    &quot;baseUrl&quot;: &quot;src&quot;,\n    &quot;paths&quot;: {},\n    &quot;esModuleInterop&quot;: true,\n    &quot;experimentalDecorators&quot;: true\n  },\n  &quot;include&quot;: [&quot;src&quot;],\n  &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;]\n}\n</code></pre>\n<p>typescript 타입 체크 명령어를 포함하도록 <code>package.json</code>의 <code>scripts</code>를 다음과 같이 변경해줍니다.</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;dev&quot;: &quot;babel-node index.js&quot;,\n  &quot;build&quot;: &quot;npm-run-all types:check build:js&quot;,\n  &quot;build:js&quot;: &quot;babel -d dist --extensions \\&quot;.js,.ts\\&quot; src&quot;,\n  &quot;types:check&quot;: &quot;tsc --noEmit&quot;\n}\n</code></pre>\n<p><code>tsc --noEmit</code> 명령어를 실행하면, typescript의 타입체크만 이루어지고, 컴파일은 하지 않습니다. <code>npm run build</code>를 실행하여 typescript 타입 체크와 babel의 컴파일을 실행해봅시다.</p>\n<pre><code class=\"language-bash\">$ npm run build\n</code></pre>\n<p>혹시 <code>Cannot find module &#39;fs&#39;</code> 에러가 발생 하셨나요? 이 에러는 typescript가 모듈을 찾지 못해 생기는 오류입니다. 다음 패키지를 설치해주세요.</p>\n<pre><code class=\"language-bash\">$ npm i -D @types/node\n</code></pre>\n<hr>\n<h3 id=\"eslint\">Eslint</h3>\n<p><strong>eslint</strong>를 이용해서 코드 문법을 검사하고, 코딩 스타일도 함께 체크해보는 기능을 추가하겠습니다.</p>\n<p>먼저 eslint를 설치합니다. 그리고 필요한 몇가지 패키지도 함께 설치하겠습니다.</p>\n<pre><code class=\"language-bash\">$ npm i -D eslint eslint-config-airbnb-base eslint-plugin-import\n\n$ npm i -D @typescript-eslint/eslint-plugin @typescript-eslint/parser\n</code></pre>\n<p>설치가 되었다면 <code>.eslintrc</code>파일을 생성해주세요.</p>\n<pre><code class=\"language-json\">{\n  &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;,\n  &quot;plugins&quot;: [&quot;@typescript-eslint&quot;],\n  &quot;extends&quot;: [\n    &quot;eslint-config-airbnb-base&quot;,\n    &quot;plugin:@typescript-eslint/eslint-recommended&quot;\n  ]\n}\n</code></pre>\n<p>그리고 eslint를 실행하는 <code>scripts</code>를 <code>package.json</code>에 추가합니다.</p>\n<pre><code class=\"language-json\">&quot;scripts&quot;: {\n  &quot;lint:check&quot;: &quot;eslint src/**/*.ts&quot;,\n  &quot;lint:fix&quot;: &quot;eslint --fix src/**/*.ts&quot;\n}\n</code></pre>\n<p>이제 <code>lint:check</code>를 실행하면, eslint가 <code>.eslintrc</code>의 설정으로 문법 및 코딩 스타일을 체크해줍니다. <code>lint:fix</code>를 실행하면 코드를 자동으로 고쳐줍니다.</p>\n<hr>\n<h4 id=\"eslint---prettier-함께-사용하기\">Eslint - Prettier 함께 사용하기</h4>\n<p>저는 VSCode에서 Prettier와 Eslint를 함께 사용하는데요, Prettier의 설정과 Eslint의 설정이 충돌을 일으키기 때문에 따로 설정을 해 주어야 합니다. 그렇지 않으면 같은 내용의 설정을 eslint와 prettier에서 각각 두번 해주어야 하는 불편함이 생기기 때문입니다.</p>\n<p>eslint의 관련 패키지를 설치해줍니다.</p>\n<pre><code class=\"language-bash\">$ npm i -D eslint-config-prettier eslint-plugin-prettier prettier\n</code></pre>\n<p>그리고 <code>.eslintrc</code>파일의 <code>extends</code> 부분에 다음을 추가해줍니다.</p>\n<pre><code class=\"language-json\">&quot;extends&quot;: [\n  &quot;plugin:prettier/recommended&quot;\n]\n</code></pre>\n<p>위 설정에는 두 가지가 적용되는데요. 첫번째로 <code>eslint-config-prettier</code>는 eslint와 prettier의 충돌되는 규칙들을 eslint가 무시해줍니다. prettier로 설정될 부분들은 eslint에서 담당하지 않겠다는 뜻입니다.</p>\n<p>두번째로 <code>eslint-plugin-prettier</code>는 prettier에서 설정한 규칙들을 eslint의 에러로 표시한다는 뜻입니다. 충돌되는 규칙들을 eslint가 무시해준다면 해당 규칙들에 대해 에러를 표시할 수 있도록 prettier의 규칙들을 에러로 표시한다는 것입니다.</p>\n<p><code>.prettierrc</code> 파일을 만들어 prettier에 적용할 규칙을 작성해주세요.</p>\n<pre><code class=\"language-json\">{\n  &quot;singleQuote&quot;: true\n}\n</code></pre>\n<p>이렇게 하면 <code>.prettierrc</code>에 적용된 규칙은 eslint가 간섭하지 않습니다. 또한 그 규칙들에 대한 오류를 eslint가 &#39;prettier&#39;라는 이름의 규칙으로 표시해줍니다.</p>\n<hr>\n<h3 id=\"마무리\">마무리</h3>\n<p>babel과 typescript를 적용한 컴파일 설정과 eslint를 통해 코드를 검사하고 수정하는 부분을 구성해 보았습니다. 가장 기본적인 설정 방법을 함께 적용해보았는데요, 사용자에 맞게 더 많은 기능을 추가할 수도 있습니다.</p>\n<p>기회가 된다면 세부적인 기능들에 대한 리뷰와 적용기도 한 번 작성해보도록 하겠습니다.</p>\n","excerpt":" 애플리케이션을 개발할 때, 애플리케이션 자체에 대한 것이 아닌 개발자가 개발을 편하게 할 수 있도록 돕는 여러 가지 도구들이 있습니다. 개발에 앞서 그러한 개발 도구들로 개발 환경을 구성한 후, 개발을 하게 되는데요. 이 글에서는 Node.js를 기반으로 하고, Babel Typescript Eslint를 이용하여 개발환경을 구성해 보겠습니다.  Node.","thumbnail":"/node/node-dev-environment-babel-typescript-eslint/img/babel_typescript_eslint.png","thumbnailUrl":"https://hoontae24.github.io/node/node-dev-environment-babel-typescript-eslint/img/babel_typescript_eslint.png"},{"href":"8","round":8,"paths":["react","react-mobx-action"],"slug":"react-mobx-action","title":"Mobx의 상태 변화, Action을 알아보자(feat. 비동기 Action)","description":"","date":"2020-01-30","category":"react","tags":["mobx","react"],"seriesId":null,"markdown":"\n![mobx](/react/react-mobx-action/img/mobx.png)\n\nMobx는 리액트에서 사용되어지는 상태 관리 라이브러리입니다. 리액트 자체적으로 state나 useState를 이용해서 상태 관리를 할 수 있지만, 전역적인 상태나 반응적인 변화를 위해서 Mobx와 같은 외부 라이브러리를 사용하기도 합니다.\n\n`Mobx`에서 상태 변화를 일으키는 것을 `Action`이라고 합니다. 이 글에서는 `리액트`에서 `Action`을 사용하는 것과 `비동기` 작업에서는 어떻게 사용해야할 지 살펴보겠습니다.\n\n_(이 글에서는 `Mobx`에 대한 주요 개념이나 사용법을 다루지 않습니다.)_\n\n[참조] 이 글을 작성하면서 아래의 글에 도움을 받았습니다.\n\n- [Mobx와 비동기 작업 - React - BYSEOP's devlog](https://byseop.netlify.com/mobx-async/)\n- [MobX (2) 리액트 프로젝트에서 MobX 사용하기 - velog](https://velog.io/@velopert/MobX-2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-MobX-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-oejltas52z)\n\n---\n\n### 1. 작업 환경 구성\n\n먼저 리액트와 Mobx를 사용할 수 있는 환경을 구성하겠습니다. 작업 순서는 다음과 같습니다.\n\n1. create-react-app으로 리액트 프로젝트 생성\n2. 프로젝트 eject 및 decorator 사용 환경 구성\n3. mobx 설치 및 실습\n\n먼저 create-react-app을 이용해 실습 프로젝트를 생성합니다.\n\n```bash\n$ npx create-react-app mobx-async-action --use-npm\n```\n\n`--use-npm` 옵션은 `yarn` 대신에 `npm`을 사용하기 위한 옵션입니다. 하지 않아도 상관없습니다.\n\n```bash\n$ cd mobx-async-action\n$ npm run eject # eject에 대한 confirm 질문이 나오면 y 입력\n```\n\n`eject` 명령어를 이용해 `webpack`설정을 커스텀할 수 있게 만듭니다. 그리고 `decorator`를 사용할 수 있도록 babel 설정을 해줍니다.\n\n```bash\n$ npm i @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators\n```\n\n이제 `package.json`을 열고 babel 설정을 다음과 같이 수정합니다.\n\n```json\n\"babel\": {\n    \"presets\": [\n      \"react-app\"\n    ],\n    \"plugins\": [\n      [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }],\n      [\"@babel/plugin-proposal-class-properties\", { \"loose\": true }]\n    ]\n  }\n```\n\n혹시 vscode에서 데코레이터 때문에 오류가 발생하면, 프로젝트 폴더에 `jsconfig.json`파일을 만들고 다음 코드를 추가해주세요.\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n이제 실습 대상 라이브러리인 `mobx`를 설치합니다.\n\n```bash\n$ npm i mobx mobx-react\n```\n\n이제 환경 설정이 끝났습니다. 설정이 잘 동작하는지 개발 서버를 구동시켜서 확인해 보겠습니다.\n\n```bash\n$ npm start\n```\n\n![개발 서버 스크린샷](/react/react-mobx-action/img/mobx-async-action-ss-1.png)\n\n이제 CRA를 통해 만든 프로젝트에서 필요 없는 부분을 삭제해주겠습니다.\n\n`src`폴더에서 `index.css`, `logo.svg`, `App.css`, `App.test.js` 파일은 지우고, `index.js`와 `App.js`파일을 수정해줍니다.\n\n```jsx\n// src/index.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n```\n\n```jsx\n// src/App.js\nimport React, { Component } from 'react'\n\nclass App extends Component {\n  render() {\n    return (\n      <div className='App'>\n        <h1>mobx-async-action</h1>\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n---\n\n### 2. Mobx Action 살펴보기\n\n먼저 `mobx`의 `observable` 변수를 선언해주고, 변수에 `reaction`을 걸어두겠습니다. 그리고 간단히 값을 변경시키는 버튼과 로직을 만들겠습니다.\n\n```jsx\n// src/App.js\nimport React, { Component } from 'react'\nimport { observable, reaction } from 'mobx'\nimport { observer } from 'mobx-react'\n\n@observer\nclass App extends Component {\n  @observable number1 = 0\n  @observable number2 = 0\n\n  constructor(props) {\n    super(props)\n    reaction(\n      () => [this.number1, this.number2],\n      ([number1, number2]) => console.log('Reaction:', number1, number2),\n    )\n  }\n\n  componentDidUpdate() {\n    console.log('Updated:', this.number1, this.number2)\n  }\n\n  handleClick = () => {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }\n\n  getRandomNumber = () => Math.ceil(Math.random() * 10)\n\n  render() {\n    return (\n      <div className='App'>\n        <h1>mobx-async-action</h1>\n        <h5>number1: {this.number1}</h5>\n        <h5>number2: {this.number2}</h5>\n        <button onClick={this.handleClick}>random</button>\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n`App`컴포넌트는 `number1`과 `number2`라는 상태를 가지고 있고, 버튼을 클릭하면 두 상태 변수에 랜덤한 값이 저장됩니다. 상태가 변경되면 콘솔에 `Reaction:` 으로 출력되도록 `reaction`을 만들어 두었고, 컴포넌트가 변경되면 `Updated:`로 콘솔에 출력됩니다.\n\n먼저 `random`버튼을 클릭해보겠습니다.\n\n제 경우에는 다음과 같이 출력되었습니다.\n\n```output\n# output\nReaction: 2 0\nReaction: 2 1\nUpdated: 2 1\n```\n\n출력을 분석해보면 두 개의 상태 변수가 변경될 때 각각의 `Action`이 총 2번 발생되고, `Action`이 끝나면 컴포넌트가 업데이트 되는 것을 알 수 있습니다.\n\n그렇다면 비동기 상황에서는 어떻게 동작할까요? `handleClick`메소드에 `setTimeout`으로 비동기적 상황을 만들어 보겠습니다.\n\n```jsx\n// src/App.js\nhandleClick = () => {\n  // 1초 후에 number의 값이 변하는 동작\n  setTimeout(() => {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }, 1000)\n}\n```\n\n```output\n# output\nReaction: 4 0\nUpdated: 4 0\nReaction: 4 6\nUpdated: 4 6\n```\n\n`setTimeout`함수를 이용해서 1초 후에 값이 변하는 `Action`을 실행시켜보았습니다. 아까와 같이 2번의 `Action`이 발생하였고, 이번에는 `Updated` 또한 2번이 발생했습니다.\n\n`mobx`에서는 이러한 상태 변화를 하나로 묶는 `action`함수를 제공합니다. 데코레이터를 사용해서 `handleClick`메소드를 `action`으로 감싸보겠습니다.\n\n```js\n// src/App.js\nimport { observable, reaction, action } from 'mobx'\n\n// 데코레이터를 이용해 mobx의 action으로 handleClick 메소드를 감싸줌\n@action\nhandleClick = () => {\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n```\n\n```output\n# output\nReaction: 5 9\nUpdated: 5 9\n```\n\n실행되는 메소드를 `action`으로 감싸주니 두 변수의 상태가 변했음에도 한번의 `Action`만 발생하는 것을 볼 수 있습니다. 또한 `mobx`의 `action`으로 감싸주면 개발자도구를 통해 변화의 정보를 추적할 수 있습니다.\n\n이번에는 하나의 함수 안에서 `action`으로 감싼 함수를 호출해보도록 하겠습니다.\n\n```js\n// src/App.js\nhandleClick = () => {\n  this.setNumber1()\n  this.setNumber2()\n}\n\n@action setNumber1 = () => (this.number1 = this.getRandomNumber())\n@action setNumber2 = () => (this.number2 = this.getRandomNumber())\n```\n\n```output\n# output\nReaction: 3 0\nReaction: 3 3\nUpdated: 3 3\n```\n\n`action`으로 감싼 함수를 각각 호출해보니 독립적으로 `Action`이 발생했습니다. 다시 `handleClick`메소드에 `action`을 감싸봅시다.\n\n```js\n// src/App.js\n@action\nhandleClick = () => {\n  this.setNumber1()\n  this.setNumber2()\n}\n\n@action setNumber1 = () => (this.number1 = this.getRandomNumber())\n@action setNumber2 = () => (this.number2 = this.getRandomNumber())\n```\n\n```output\n# output\nReaction: 5 3\nUpdated: 5 3\n```\n\n`action`을 감싸주니 독립된 `Action`을 하나로 묶어 동작하게 됩니다. 또한 `setNumber1`과 `setNumber2`에 `@action`을 제거하더라도 하나의 `Action`으로 묶여 동작하는 것을 볼 수 있습니다.\n\n이번에는 `action`내에서 비동기 동작을 관찰해 보겠습니다.\n\n```js\n// src/App.js\n@action\nhandleClick = () => {\n  setTimeout(() => {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }, 1000)\n}\n```\n\n```output\n# output\nReaction: 1 0\nUpdated: 1 0\nReaction: 1 4\nUpdated: 1 4\n```\n\n동작하는 함수에 `action`을 적용시켰음에도 전혀 그렇지 않은 것처럼 동작합니다. mobx 문서에서는 다음과 같이 말합니다.\n\n> _The action wrapper / decorator only affects the currently running function, not functions that are scheduled (but not invoked) by the current function!_\n\n`action`으로 감싸주더라도 그 영향은 현재 실행 중인 함수 내에만 적용됩니다. `setTimeout` 또는 `Promise.then`, `async`함수 등 새롭게 호출되는 함수의 동작에 대해서는 `action`의 기능을 적용받을 수 없습니다.\n\n---\n\n### 3. 비동기 작업의 Action 다루기\n\nmobx에서 이러한 비동기 작업에서 `Action`을 처리하기 위해서는 새로운 `action`을 적용해야 합니다. mobx 문서에서 다루고 있는 방법들을 살펴보겠습니다.\n\n#### 3-1. 다른 action으로 감싸기\n\n비동기 작업에서의 `Action`이 발생하는 부분을 다른 `action`으로 감싸주도록 하겠습니다.\n\n```js\n// src/App.js\n// @action\nhandleClick = () => {\n  setTimeout(() => {\n    this.setNumbers()\n  }, 1000)\n}\n\n@action\nsetNumbers = () => {\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n```\n\n이렇게 비동기 작업 자체를 `action`으로 감싸 새로운 함수로 만들 수 있습니다. 만약 메인으로 호출하는 `handleClick`메소드에 `Action`이 발생할 일이 없다면 `@action`을 제거해도 됩니다.\n\n데코레이터를 이용하지 않고 `action`을 감싸주는 방법도 있습니다.\n\n```js\n// src/App.js\n@action\nhandleClick = () => {\n  setTimeout(\n    action('setNumbersAsync1', () => {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    }),\n    1000,\n  )\n\n  Promise.resolve().then(\n    action('setNumbersAsync2', () => {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    }),\n  )\n}\n```\n\n데코레이터를 사용하지 않고 `action`으로 감싸면서 새로운 함수를 생성합니다. `action`으로 생성된 `setNumbersAsync`함수가 실행 로직이 아니라 `setTimeout`과 `Promise.then`의 콜백함수 자리를 대신하고 있습니다.\n\n#### 3-2. runInAction 사용하기\n\n비동기 작업이 있을 때마다 `action`으로 감싸주거나, 새로운 함수를 선언하는 것은 약간 귀찮은 일이 될 수도 있습니다. mobx는 `runInAction`함수를 통해 실행 로직에서 직관성을 잃지 않고 `Action`을 발생 시킬 수 있게합니다.\n\n```js\n// src/App.js\n@action\nhandleClick = () => {\n  Promise.resolve().then(() => {\n    runInAction(() => {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    })\n  })\n}\n```\n\n`runInAction`함수의 첫번째 인자로 익명의 함수를 넘겨줍니다. `runInAction`은 인자로 받은 함수를 즉시 실행하며 `Action`을 묶어주게 됩니다.\n\n#### 3-3. async/await\n\n만약 비동기 작업을 호출하는 함수가 `async`함수라면 `await`이 실행된 후에는 `action`의 적용되지 않습니다. `await` 이후의 코드 블록에서 `상태 변화`가 발생한다면 `runInAction`으로 감싸주어야 합니다.\n\n```js\n@action\nhandleClick = async () => {\n  await Promise.resolve()\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n```\n\n```output\n# output\nReaction: 3 0\nUpdated: 3 0\nReaction: 3 7\nUpdated: 3 7\n```\n\n```js\n@action\nhandleClick = async () => {\n  await Promise.resolve()\n  runInAction(() => {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  })\n}\n```\n\n```output\n# output\nReaction: 8 3\nUpdated: 8 3\n```\n\n#### 3-4 flow\n\n`flow`를 사용하면 코드는 가장 깔끔하고 직관적이게 작성할 수 있습니다. 하지만 약간 다른 방법으로 비동기 작업을 제어합니다. `async/await`와 비슷하지만 `function *` 제너레이터를 사용합니다. `await` 대신에 제너레이터의 `yield`를 사용합니다. `runInAction`과 같은 새로운 `Action`을 감싸 줄 필요가 없어집니다.\n\n```js\nconstructor(props) {\n    super(props)\n    // flow 내에서 this를 사용하기 위해 바인딩\n    this.handleClick = this.handleClick.bind(this)\n}\n\nhandleClick = flow(function*() {\n  yield Promise.resolve()\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n})\n```\n\n---\n\n### 마무리\n\n지금까지 mobx의 상태 변화 Action을 다루는 법을 살펴보았습니다. 상태 변화를 감지하여 `Action`이 발생할 때, 여러 번의 `Action`을 하나로 묶어주어 상태 변화를 잘 처리할 수 있도록 여러 가지 방법을 살펴보았습니다.\n\n특히 비동기 작업에서의 `Action` 적용은 컴포넌트의 업데이트에도 영향을 주기 때문에, 직관적이고 보기 좋은 코드를 작성할 뿐만 아니라, 컴포넌트 라이프 사이클을 이해하고 `Action`과 함께 잘 다루는 법을 익혀야 할 것 같습니다.\n","html":"<p><img src=\"/react/react-mobx-action/img/mobx.png\" alt=\"mobx\"></p>\n<p>Mobx는 리액트에서 사용되어지는 상태 관리 라이브러리입니다. 리액트 자체적으로 state나 useState를 이용해서 상태 관리를 할 수 있지만, 전역적인 상태나 반응적인 변화를 위해서 Mobx와 같은 외부 라이브러리를 사용하기도 합니다.</p>\n<p><code>Mobx</code>에서 상태 변화를 일으키는 것을 <code>Action</code>이라고 합니다. 이 글에서는 <code>리액트</code>에서 <code>Action</code>을 사용하는 것과 <code>비동기</code> 작업에서는 어떻게 사용해야할 지 살펴보겠습니다.</p>\n<p><em>(이 글에서는 <code>Mobx</code>에 대한 주요 개념이나 사용법을 다루지 않습니다.)</em></p>\n<p>[참조] 이 글을 작성하면서 아래의 글에 도움을 받았습니다.</p>\n<ul>\n<li><a href=\"https://byseop.netlify.com/mobx-async/\">Mobx와 비동기 작업 - React - BYSEOP&#39;s devlog</a></li>\n<li><a href=\"https://velog.io/@velopert/MobX-2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-MobX-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-oejltas52z\">MobX (2) 리액트 프로젝트에서 MobX 사용하기 - velog</a></li>\n</ul>\n<hr>\n<h3 id=\"1-작업-환경-구성\">1. 작업 환경 구성</h3>\n<p>먼저 리액트와 Mobx를 사용할 수 있는 환경을 구성하겠습니다. 작업 순서는 다음과 같습니다.</p>\n<ol>\n<li>create-react-app으로 리액트 프로젝트 생성</li>\n<li>프로젝트 eject 및 decorator 사용 환경 구성</li>\n<li>mobx 설치 및 실습</li>\n</ol>\n<p>먼저 create-react-app을 이용해 실습 프로젝트를 생성합니다.</p>\n<pre><code class=\"language-bash\">$ npx create-react-app mobx-async-action --use-npm\n</code></pre>\n<p><code>--use-npm</code> 옵션은 <code>yarn</code> 대신에 <code>npm</code>을 사용하기 위한 옵션입니다. 하지 않아도 상관없습니다.</p>\n<pre><code class=\"language-bash\">$ cd mobx-async-action\n$ npm run eject # eject에 대한 confirm 질문이 나오면 y 입력\n</code></pre>\n<p><code>eject</code> 명령어를 이용해 <code>webpack</code>설정을 커스텀할 수 있게 만듭니다. 그리고 <code>decorator</code>를 사용할 수 있도록 babel 설정을 해줍니다.</p>\n<pre><code class=\"language-bash\">$ npm i @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators\n</code></pre>\n<p>이제 <code>package.json</code>을 열고 babel 설정을 다음과 같이 수정합니다.</p>\n<pre><code class=\"language-json\">&quot;babel&quot;: {\n    &quot;presets&quot;: [\n      &quot;react-app&quot;\n    ],\n    &quot;plugins&quot;: [\n      [&quot;@babel/plugin-proposal-decorators&quot;, { &quot;legacy&quot;: true }],\n      [&quot;@babel/plugin-proposal-class-properties&quot;, { &quot;loose&quot;: true }]\n    ]\n  }\n</code></pre>\n<p>혹시 vscode에서 데코레이터 때문에 오류가 발생하면, 프로젝트 폴더에 <code>jsconfig.json</code>파일을 만들고 다음 코드를 추가해주세요.</p>\n<pre><code class=\"language-json\">{\n  &quot;compilerOptions&quot;: {\n    &quot;experimentalDecorators&quot;: true\n  }\n}\n</code></pre>\n<p>이제 실습 대상 라이브러리인 <code>mobx</code>를 설치합니다.</p>\n<pre><code class=\"language-bash\">$ npm i mobx mobx-react\n</code></pre>\n<p>이제 환경 설정이 끝났습니다. 설정이 잘 동작하는지 개발 서버를 구동시켜서 확인해 보겠습니다.</p>\n<pre><code class=\"language-bash\">$ npm start\n</code></pre>\n<p><img src=\"/react/react-mobx-action/img/mobx-async-action-ss-1.png\" alt=\"개발 서버 스크린샷\"></p>\n<p>이제 CRA를 통해 만든 프로젝트에서 필요 없는 부분을 삭제해주겠습니다.</p>\n<p><code>src</code>폴더에서 <code>index.css</code>, <code>logo.svg</code>, <code>App.css</code>, <code>App.test.js</code> 파일은 지우고, <code>index.js</code>와 <code>App.js</code>파일을 수정해줍니다.</p>\n<pre><code class=\"language-jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport App from &#39;./App&#39;\nimport * as serviceWorker from &#39;./serviceWorker&#39;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n</code></pre>\n<pre><code class=\"language-jsx\">// src/App.js\nimport React, { Component } from &#39;react&#39;\n\nclass App extends Component {\n  render() {\n    return (\n      &lt;div className=&#39;App&#39;&gt;\n        &lt;h1&gt;mobx-async-action&lt;/h1&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<hr>\n<h3 id=\"2-mobx-action-살펴보기\">2. Mobx Action 살펴보기</h3>\n<p>먼저 <code>mobx</code>의 <code>observable</code> 변수를 선언해주고, 변수에 <code>reaction</code>을 걸어두겠습니다. 그리고 간단히 값을 변경시키는 버튼과 로직을 만들겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/App.js\nimport React, { Component } from &#39;react&#39;\nimport { observable, reaction } from &#39;mobx&#39;\nimport { observer } from &#39;mobx-react&#39;\n\n@observer\nclass App extends Component {\n  @observable number1 = 0\n  @observable number2 = 0\n\n  constructor(props) {\n    super(props)\n    reaction(\n      () =&gt; [this.number1, this.number2],\n      ([number1, number2]) =&gt; console.log(&#39;Reaction:&#39;, number1, number2),\n    )\n  }\n\n  componentDidUpdate() {\n    console.log(&#39;Updated:&#39;, this.number1, this.number2)\n  }\n\n  handleClick = () =&gt; {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }\n\n  getRandomNumber = () =&gt; Math.ceil(Math.random() * 10)\n\n  render() {\n    return (\n      &lt;div className=&#39;App&#39;&gt;\n        &lt;h1&gt;mobx-async-action&lt;/h1&gt;\n        &lt;h5&gt;number1: {this.number1}&lt;/h5&gt;\n        &lt;h5&gt;number2: {this.number2}&lt;/h5&gt;\n        &lt;button onClick={this.handleClick}&gt;random&lt;/button&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<p><code>App</code>컴포넌트는 <code>number1</code>과 <code>number2</code>라는 상태를 가지고 있고, 버튼을 클릭하면 두 상태 변수에 랜덤한 값이 저장됩니다. 상태가 변경되면 콘솔에 <code>Reaction:</code> 으로 출력되도록 <code>reaction</code>을 만들어 두었고, 컴포넌트가 변경되면 <code>Updated:</code>로 콘솔에 출력됩니다.</p>\n<p>먼저 <code>random</code>버튼을 클릭해보겠습니다.</p>\n<p>제 경우에는 다음과 같이 출력되었습니다.</p>\n<pre><code class=\"language-output\"># output\nReaction: 2 0\nReaction: 2 1\nUpdated: 2 1\n</code></pre>\n<p>출력을 분석해보면 두 개의 상태 변수가 변경될 때 각각의 <code>Action</code>이 총 2번 발생되고, <code>Action</code>이 끝나면 컴포넌트가 업데이트 되는 것을 알 수 있습니다.</p>\n<p>그렇다면 비동기 상황에서는 어떻게 동작할까요? <code>handleClick</code>메소드에 <code>setTimeout</code>으로 비동기적 상황을 만들어 보겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/App.js\nhandleClick = () =&gt; {\n  // 1초 후에 number의 값이 변하는 동작\n  setTimeout(() =&gt; {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }, 1000)\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 4 0\nUpdated: 4 0\nReaction: 4 6\nUpdated: 4 6\n</code></pre>\n<p><code>setTimeout</code>함수를 이용해서 1초 후에 값이 변하는 <code>Action</code>을 실행시켜보았습니다. 아까와 같이 2번의 <code>Action</code>이 발생하였고, 이번에는 <code>Updated</code> 또한 2번이 발생했습니다.</p>\n<p><code>mobx</code>에서는 이러한 상태 변화를 하나로 묶는 <code>action</code>함수를 제공합니다. 데코레이터를 사용해서 <code>handleClick</code>메소드를 <code>action</code>으로 감싸보겠습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\nimport { observable, reaction, action } from &#39;mobx&#39;\n\n// 데코레이터를 이용해 mobx의 action으로 handleClick 메소드를 감싸줌\n@action\nhandleClick = () =&gt; {\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 5 9\nUpdated: 5 9\n</code></pre>\n<p>실행되는 메소드를 <code>action</code>으로 감싸주니 두 변수의 상태가 변했음에도 한번의 <code>Action</code>만 발생하는 것을 볼 수 있습니다. 또한 <code>mobx</code>의 <code>action</code>으로 감싸주면 개발자도구를 통해 변화의 정보를 추적할 수 있습니다.</p>\n<p>이번에는 하나의 함수 안에서 <code>action</code>으로 감싼 함수를 호출해보도록 하겠습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\nhandleClick = () =&gt; {\n  this.setNumber1()\n  this.setNumber2()\n}\n\n@action setNumber1 = () =&gt; (this.number1 = this.getRandomNumber())\n@action setNumber2 = () =&gt; (this.number2 = this.getRandomNumber())\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 3 0\nReaction: 3 3\nUpdated: 3 3\n</code></pre>\n<p><code>action</code>으로 감싼 함수를 각각 호출해보니 독립적으로 <code>Action</code>이 발생했습니다. 다시 <code>handleClick</code>메소드에 <code>action</code>을 감싸봅시다.</p>\n<pre><code class=\"language-js\">// src/App.js\n@action\nhandleClick = () =&gt; {\n  this.setNumber1()\n  this.setNumber2()\n}\n\n@action setNumber1 = () =&gt; (this.number1 = this.getRandomNumber())\n@action setNumber2 = () =&gt; (this.number2 = this.getRandomNumber())\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 5 3\nUpdated: 5 3\n</code></pre>\n<p><code>action</code>을 감싸주니 독립된 <code>Action</code>을 하나로 묶어 동작하게 됩니다. 또한 <code>setNumber1</code>과 <code>setNumber2</code>에 <code>@action</code>을 제거하더라도 하나의 <code>Action</code>으로 묶여 동작하는 것을 볼 수 있습니다.</p>\n<p>이번에는 <code>action</code>내에서 비동기 동작을 관찰해 보겠습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\n@action\nhandleClick = () =&gt; {\n  setTimeout(() =&gt; {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }, 1000)\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 1 0\nUpdated: 1 0\nReaction: 1 4\nUpdated: 1 4\n</code></pre>\n<p>동작하는 함수에 <code>action</code>을 적용시켰음에도 전혀 그렇지 않은 것처럼 동작합니다. mobx 문서에서는 다음과 같이 말합니다.</p>\n<blockquote>\n<p><em>The action wrapper / decorator only affects the currently running function, not functions that are scheduled (but not invoked) by the current function!</em></p>\n</blockquote>\n<p><code>action</code>으로 감싸주더라도 그 영향은 현재 실행 중인 함수 내에만 적용됩니다. <code>setTimeout</code> 또는 <code>Promise.then</code>, <code>async</code>함수 등 새롭게 호출되는 함수의 동작에 대해서는 <code>action</code>의 기능을 적용받을 수 없습니다.</p>\n<hr>\n<h3 id=\"3-비동기-작업의-action-다루기\">3. 비동기 작업의 Action 다루기</h3>\n<p>mobx에서 이러한 비동기 작업에서 <code>Action</code>을 처리하기 위해서는 새로운 <code>action</code>을 적용해야 합니다. mobx 문서에서 다루고 있는 방법들을 살펴보겠습니다.</p>\n<h4 id=\"3-1-다른-action으로-감싸기\">3-1. 다른 action으로 감싸기</h4>\n<p>비동기 작업에서의 <code>Action</code>이 발생하는 부분을 다른 <code>action</code>으로 감싸주도록 하겠습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\n// @action\nhandleClick = () =&gt; {\n  setTimeout(() =&gt; {\n    this.setNumbers()\n  }, 1000)\n}\n\n@action\nsetNumbers = () =&gt; {\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n</code></pre>\n<p>이렇게 비동기 작업 자체를 <code>action</code>으로 감싸 새로운 함수로 만들 수 있습니다. 만약 메인으로 호출하는 <code>handleClick</code>메소드에 <code>Action</code>이 발생할 일이 없다면 <code>@action</code>을 제거해도 됩니다.</p>\n<p>데코레이터를 이용하지 않고 <code>action</code>을 감싸주는 방법도 있습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\n@action\nhandleClick = () =&gt; {\n  setTimeout(\n    action(&#39;setNumbersAsync1&#39;, () =&gt; {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    }),\n    1000,\n  )\n\n  Promise.resolve().then(\n    action(&#39;setNumbersAsync2&#39;, () =&gt; {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    }),\n  )\n}\n</code></pre>\n<p>데코레이터를 사용하지 않고 <code>action</code>으로 감싸면서 새로운 함수를 생성합니다. <code>action</code>으로 생성된 <code>setNumbersAsync</code>함수가 실행 로직이 아니라 <code>setTimeout</code>과 <code>Promise.then</code>의 콜백함수 자리를 대신하고 있습니다.</p>\n<h4 id=\"3-2-runinaction-사용하기\">3-2. runInAction 사용하기</h4>\n<p>비동기 작업이 있을 때마다 <code>action</code>으로 감싸주거나, 새로운 함수를 선언하는 것은 약간 귀찮은 일이 될 수도 있습니다. mobx는 <code>runInAction</code>함수를 통해 실행 로직에서 직관성을 잃지 않고 <code>Action</code>을 발생 시킬 수 있게합니다.</p>\n<pre><code class=\"language-js\">// src/App.js\n@action\nhandleClick = () =&gt; {\n  Promise.resolve().then(() =&gt; {\n    runInAction(() =&gt; {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    })\n  })\n}\n</code></pre>\n<p><code>runInAction</code>함수의 첫번째 인자로 익명의 함수를 넘겨줍니다. <code>runInAction</code>은 인자로 받은 함수를 즉시 실행하며 <code>Action</code>을 묶어주게 됩니다.</p>\n<h4 id=\"3-3-asyncawait\">3-3. async/await</h4>\n<p>만약 비동기 작업을 호출하는 함수가 <code>async</code>함수라면 <code>await</code>이 실행된 후에는 <code>action</code>의 적용되지 않습니다. <code>await</code> 이후의 코드 블록에서 <code>상태 변화</code>가 발생한다면 <code>runInAction</code>으로 감싸주어야 합니다.</p>\n<pre><code class=\"language-js\">@action\nhandleClick = async () =&gt; {\n  await Promise.resolve()\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 3 0\nUpdated: 3 0\nReaction: 3 7\nUpdated: 3 7\n</code></pre>\n<pre><code class=\"language-js\">@action\nhandleClick = async () =&gt; {\n  await Promise.resolve()\n  runInAction(() =&gt; {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  })\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 8 3\nUpdated: 8 3\n</code></pre>\n<h4 id=\"3-4-flow\">3-4 flow</h4>\n<p><code>flow</code>를 사용하면 코드는 가장 깔끔하고 직관적이게 작성할 수 있습니다. 하지만 약간 다른 방법으로 비동기 작업을 제어합니다. <code>async/await</code>와 비슷하지만 <code>function *</code> 제너레이터를 사용합니다. <code>await</code> 대신에 제너레이터의 <code>yield</code>를 사용합니다. <code>runInAction</code>과 같은 새로운 <code>Action</code>을 감싸 줄 필요가 없어집니다.</p>\n<pre><code class=\"language-js\">constructor(props) {\n    super(props)\n    // flow 내에서 this를 사용하기 위해 바인딩\n    this.handleClick = this.handleClick.bind(this)\n}\n\nhandleClick = flow(function*() {\n  yield Promise.resolve()\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n})\n</code></pre>\n<hr>\n<h3 id=\"마무리\">마무리</h3>\n<p>지금까지 mobx의 상태 변화 Action을 다루는 법을 살펴보았습니다. 상태 변화를 감지하여 <code>Action</code>이 발생할 때, 여러 번의 <code>Action</code>을 하나로 묶어주어 상태 변화를 잘 처리할 수 있도록 여러 가지 방법을 살펴보았습니다.</p>\n<p>특히 비동기 작업에서의 <code>Action</code> 적용은 컴포넌트의 업데이트에도 영향을 주기 때문에, 직관적이고 보기 좋은 코드를 작성할 뿐만 아니라, 컴포넌트 라이프 사이클을 이해하고 <code>Action</code>과 함께 잘 다루는 법을 익혀야 할 것 같습니다.</p>\n","excerpt":" Mobx는 리액트에서 사용되어지는 상태 관리 라이브러리입니다. 리액트 자체적으로 state나 useState를 이용해서 상태 관리를 할 수 있지만, 전역적인 상태나 반응적인 변화를 위해서 Mobx와 같은 외부 라이브러리를 사용하기도 합니다. Mobx에서 상태 변화를 일으키는 것을 Action이라고 합니다. 이 글에서는 리액트에서 Action을 사용하는 것과","thumbnail":"/react/react-mobx-action/img/mobx.png","thumbnailUrl":"https://hoontae24.github.io/react/react-mobx-action/img/mobx.png"},{"href":"7","round":7,"paths":["javascript","javascript-promise-async-await"],"slug":"javascript-promise-async-await","title":"Javascript의 비동기 처리, async/await를 알아보자","description":"","date":"2020-01-11","category":"javascript","tags":["javascript","promise","async/await"],"seriesId":null,"markdown":"\n![async and await](/javascript/javascript-promise-async-await/img/async_await.png)\n\n안녕하세요. 오늘은 자바스크립트의 비동기 처리를 다루는 async/await 문법에 대해 알아보겠습니다. 지난 글에서 다루었던 [Promise](6)와 함께 자바스크립트의 비동기 패턴 중 하나입니다. 또한 async/await 패턴은 **Promise**를 기반으로 하고 있습니다. 혹시 아직 **Promise**에 대해 모르신다면 이 글들을 추천드립니다.\n\n> [자바스크립트 Promise 쉽게 이해하기 • Captain Pangyo](https://joshua1988.github.io/web-development/javascript/promise-for-beginners/)  \n> [Promise - MDN - Mozilla](https://developer.mozilla.org/ko-KR/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\n---\n\n## 1. async/await 문법 살펴보기\n\n**async/await**는 ECMAScript 2017부터 추가된 문법입니다. **Promise**를 살펴볼 때, 하나의 객체로 취급했었습니다. 그래서 **Promise**가 자바스크립트 표준으로 정의되기 전에도 커스텀으로 구현되어 사용되어지고 있었습니다. 하지만 **async/await**는 하나의 문법이기 때문에 라이브러리나 모듈이 아닌 자바스크립트 새로운 키워드를 사용합니다.\n\n**async/await**는 새로운 문법이기 때문에 최신 버전의 자바스크립트를 지원하지 않는 런타임에서는 구동할 수 없습니다. 오늘의 예제 코드는 Chrome 브라우저에서 실행되는 코드이며, Chrome에서는 **async/await**문법을 지원합니다.\n\n&nbsp;\n\n### 1-1. async function(비동기 함수) 정의하기\n\n> async function 선언은 AsyncFunction객체를 반환하는 하나의 비동기 함수를 정의합니다. [_(출처: MDN)_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function)\n\n`async` 키워드를 이용하여 함수를 선언하면 `AsyncFunction`객체를 만들 수 있습니다. 코드를 함께 보겠습니다.\n\n```js\nfunction myFunc() {\n  return 'Hello Function'\n}\nconsole.log(myFunc)\n\nasync function myAsyncFunc() {\n  return 'Hello Async Function'\n}\nconsole.log(myAsyncFunc)\n```\n\n기존 `function`키워드로 선언한 함수와 `async function`키워드로 선언한 함수를 비교해 보겠습니다. 출력 로그를 확인해 보세요.\n\n![async function](/javascript/javascript-promise-async-await/img/async_screenshot_1.png)\n\n`async function`키워드로 선언한 함수는 `async f`로 표시되는 것을 볼 수 있습니다. 화살표 함수로도 선언할 수 있습니다.\n\n```js\nasync function myAsyncFunc() {\n  return 'Hello Async function'\n}\nconsole.log(myAsyncFunc)\n\nconst myAsyncArrow = async () => 'Hello Async Arrow'\nconsole.log(myAsyncArrow)\n```\n\n![async function](/javascript/javascript-promise-async-await/img/async_screenshot_2.png)\n\n&nbsp;\n\n### 1-2. await 키워드와 함께 사용하기\n\n> await 연산자는 async function 내부에서만 사용할 수 있습니다. [_(출처: MDN)_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/await)\n\n`await`키워드는 `async function`내부에서만 사용되어집니다. 만약 `async function`밖에서 사용한다면 문법이 틀렸다고 판단해 `SyntaxError`를 발생합니다.\n\n`await`키워드는 `promise`를 기다리기 위해 사용됩니다. 즉, `async function` 내부에서 `promise`의 비동기 작업을 기다리기 위해 `await`키워드를 사용합니다. 코드를 보겠습니다.\n\n```js\n// 브라우저에 내장된 fetch함수를 이용해 비동기 작업을 수행합니다.\n// fetch함수는 URL로부터 데이터를 가져와서 promise를 반환합니다.\n// fetch('https://jsonplaceholder.typicode.com/posts/1')\n\nconst url = 'https://jsonplaceholder.typicode.com/posts/1'\nasync function myAsyncFunc() {\n  const data = await fetch(url)\n  console.log('await', data)\n}\nmyAsyncFunc()\n```\n\n![await](/javascript/javascript-promise-async-await/img/await_screenshot_1.png)\n\n콘솔에서 실행해 보면 `Response`객체가 출력되는 것을 볼 수 있습니다. `fetch API`를 통해 불러온 데이터가 출력되는 것입니다. `fetch`함수에서 비동기 작업이 이루어지고, `await`키워드가 붙었기 때문에 `async function`내에서 해당 작업을 기다립니다.\n\n만약 위와 같은 작업을 `promise`패턴으로 코드를 작성하면 다음과 같을 것입니다.\n\n```js\nconst url = 'https://jsonplaceholder.typicode.com/posts/1'\nfunction myFunc() {\n  fetch(url).then(data => {\n    console.log(data)\n  })\n}\n```\n\n아직 코드의 양이나 로직이 이해되는 것에 크게 차이가 있지 않아 보입니다. 하지만 비동기 작업이 많아지거나 함수의 코드가 길어지면 `await`키워드를 이용하여 조금 더 가독성이 좋은 직관적인 코드를 작성할 수 있습니다.\n_(Promise와 async/await는 비동기 작업을 다루는 패턴 중 하나입니다. 개인 취향에 따라 다르게 평가될 수 있습니다.)_\n\n비동기 작업이 여러 번 반복된다면 더 진가를 발휘한다고 생각합니다.\n\n```js\nconst userDataUrl = 'https://jsonplaceholder.typicode.com/users/1'\nconst postDataUrl = 'https://jsonplaceholder.typicode.com/posts/1'\n\n// promise 패턴\nfunction myFunc() {\n  fetch(userDataUrl)\n    .then(res => res.json())\n    .then(user => {\n      console.log(user)\n    })\n  fetch(postDataUrl)\n    .then(res => res.json())\n    .then(post => {\n      console.log(post)\n    })\n}\nmyFunc()\n\n// async/await 패턴\nasync function myAsyncFunc() {\n  const user = await fetch(userDataUrl).then(res => res.json())\n  const post = await fetch(postDataUrl).then(res => res.json())\n\n  console.log(user)\n  console.log(post)\n}\nmyAsyncFunc()\n```\n\n위 코드에서 `console.log`부분의 작업이 단순히 출력이 아니라고 생각해보세요. `user`데이터와 `post`데이터를 함께 다루어야 한다면 `promise`패턴보다 `async/await`패턴으로 더 직관적인 코드를 작성할 수 있을 것입니다.\n\n---\n\n&nbsp;\n\n## 2. async/await 이해 & 응용하기\n\n새로운 문법이라 하더라도 자바스크립트의 비동기 처리의 코어 내부적인 동작이 크게 달라진 것은 아닙니다. 그럼 어떻게 async/await이 동작하는지 이해하고 비동기 작업을 다양한 상황에서 잘 다룰 수 있게 살펴봅시다.\n\n&nbsp;\n\n### 2-1. async function 이해하기\n\n`await`키워드가 `promise`를 기다리는 동작이 마치 프로그램이 정지된 것처럼 느껴질 수 있습니다. 하지만 `promise.then`함수처럼 다음 동작이 완료되는 것을 기다리는 것뿐입니다. `await`키워드가 `async function` 내부에서만 사용할 수 있다는 것을 기억하세요. `await`키워드가 `promise`를 기다릴 수 있는 이유는 `async function`이 이미 `promise`를 반환하기 때문입니다. 코드를 통해서 동작을 이해해 봅시다.\n\n```js\nasync function myAsyncFunc() {\n  const result = await new Promise(res => {\n    setTimeout(res, 1000, 'hello')\n  })\n  console.log(result)\n  return result\n}\nconsole.log(myAsyncFunc())\nconsole.log('Finish')\n```\n\n위 코드의 순서를 한번 보세요. `async function`인 `myAsyncFunc`을 호출하면서 동시에 반환값을 출력해보면 `Promise {<pending>}`이 출력됩니다. 그 후에 `Finish`가 출력되고, 1초 후에 `hello`가 출력됩니다.\n\n출력순서:\n\n- `Promise {<pending>}`\n- `Finish`\n- `Hello`\n\n`async function`이 호출되면 즉시 `promise`가 반환됩니다. 위 코드에서 `myAsyncFunc()`로 함수를 호출하고 나면 메인 콜스택에서는 `promise`를 반환받고, 내부의 동작에는 신경쓰지 않습니다. `async function` 내부의 `await`의 기다림 동작에서도 메인 프로세스는 멈추지 않고 동작할 수 있습니다.\n\n또한 `async function`에서 `return`되는 값을 그 `promise`의 `resolved`로 전달됩니다. 그렇기 때문에 `return` 구문에서는 `await` 키워드를 사용할 필요가 없습니다.\n\n```js\nasync function myAsyncFunc() {\n  return 'Done'\n}\nconst result = myAsyncFunc()\nresult.then(console.log)\nconsole.log(result)\n```\n\n&nbsp;\n\n### 2-2. await 이해하기\n\n`await`키워드가 사용되는 문법은 이러한 형태입니다.\n\n```js\nasync function myAsyncFunc() {\n  await someAsyncFunc()\n  // or\n  await somePromise\n  // or\n  await someValue\n}\n```\n\n`await`는 `promise`를 기다린 후에 반환하지만, 꼭 `promise`가 아닌 `어떤 값`일 수도 있습니다.\n\n```js\nfunction getPromise() {\n  return new Promise(res => setTimeout(res, 1000, 'promise'))\n}\nasync function myAsyncFunc() {\n  const someCondition = Math.random() > 0.5\n  const result = await (someCondition ? getPromise() : 'Done')\n  console.log(result)\n}\nmyAsyncFunc()\n```\n\n위 코드를 여러 번 실행해 보면, 실행할 때 마다 다른 결과를 얻을 수 있습니다. `someCondition`에 따라 `await`키워드는 `promise`를 받을 수도, `Done`이라는 값을 받을 수도 있습니다. 만약 `promise`라면 해당 동작을 기다린 후에 값을 `result`에 전달합니다.\n\n이러한 특징을 이용해서 어떠한 값에 대해 `promise`이든 `어떤 값`이든 유연하게 처리할 수 있습니다.\n\n### 2-3. async/await와 promise 응용하기\n\n`async function`내에서 `await`를 이용하여 원하는 시점에 결과값을 다룰 수 있습니다. 다음 코드를 봅시다.\n\n```js\nfunction delay(time, msg) {\n  return new Promise(res =>\n    setTimeout(() => {\n      console.log(msg)\n      res(msg)\n    }, time),\n  )\n}\nasync function myAsyncFunc() {\n  const result1 = await delay(1000, 'Hello')\n  const result2 = await delay(2000, 'Async')\n}\nmyAsyncFunc()\n```\n\n`dealy`함수는 입력된 시간후에 `msg`를 출력하는 함수입니다. 비동기 작업인 `delay`함수를 호출할 때마다 `await`를 붙여주었습니다. 위 코드의 실행 순서는 먼저 1초를 기다린 후 `Hello`가 출력되고, 2초후에 `Async`가 출력됩니다. 두번째 `delay`함수가 호출되기 위해서 앞선 `delay`함수가 끝날 때까지 `await`로 인해 기다리게 됩니다. 동작이 완료되기 위해서는 총 3초의 시간이 소요됩니다.\n\n만약 두 개의 비동기 작업이 서로 관련이 없이 독립적으로 동작해도 괜찮다면 이렇게 코드를 수정할 수 있을 것입니다.\n\n```js\nfunction delay(time, msg) {\n  return new Promise(res =>\n    setTimeout(() => {\n      console.log(msg)\n      res(msg)\n    }, time),\n  )\n}\nasync function myAsyncFunc() {\n  const _result1 = delay(1000, 'Hello')\n  const _result2 = delay(2000, 'Async')\n  const result1 = await _result1\n  const result2 = await _result2\n}\nmyAsyncFunc()\n```\n\n이전의 순서와 다른 점을 찾으셨나요? `delay`함수를 호출하는 순서는 같지만, 두번째 `delay`함수가 호출되기 위해서 첫번째 `delay`함수를 기다리지 않습니다. 그렇기 때문에 두 개의 `delay`함수가 지연없이 연속적으로 호출됩니다. 출력 시간도 1초 후에 `Hello`가 출력되고, 또 1초후에 `Async`가 출력됩니다. 총 소요 시간은 2초 정도의 시간이 소요됩니다.\n\n이렇게 비동기 작업이 서로 연관이 없거나, 독립적인 요청으로 데이터를 불러올 수 있는 상황이라면 필요한 시점에 `await`를 사용하면 됩니다. 또 `Promise` 메소드를 이용하면 이렇게 표현할 수도 있습니다.\n\n```js\nfunction delay(time, msg) {\n  return new Promise(res =>\n    setTimeout(() => {\n      console.log(msg)\n      res(msg)\n    }, time),\n  )\n}\nasync function myAsyncFunc() {\n  const _result1 = delay(1000, 'Hello')\n  const _result2 = delay(2000, 'Async')\n  const [result1, result2] = await Promise.all([_result1, _result2])\n}\nmyAsyncFunc()\n```\n\n---\n\n&nbsp;\n\n### 3. async/await 예외 처리하기\n\n`async function`에서 **예외 처리**방법은 `try/catch`를 이용합니다.\n\n```js\nconst url = 'https://jsonplaceholder.typicode.com'\nconst getData = async (field, id) => {\n  const _id = id ? `/${id}` : ''\n  return fetch(`${url}/${field}${_id}`).then(res => res.json())\n}\nasync function myAsyncFunc() {\n  try {\n    const posts = await getData('posts')\n    console.log(posts)\n  } catch (e) {\n    console.error(e)\n  }\n}\nmyAsyncFunc()\n```\n\n`async function`내에서 발생하는 오류에 대해 위와 같이 처리할 수 있습니다. 비동기에 대한 오류 뿐만 아니라 일반적인 오류도 처리할 수 있습니다. 만약 `await`가 기다리는 `promise`인 `getData`함수가 `rejected`를 반환한다면 오류가 발생하게 됩니다.\n\n```js\nconst url = 'https://jsonplaceholder.typicode.com'\nasync function myAsyncFunc() {\n  const posts = await fetch(`${url}/posts`).then(res => res.json())\n  throw new Error('Error in Async!!')\n  console.log(posts)\n}\nmyAsyncFunc()\n  .then(() => console.log('Done'))\n  .catch(e => console.log(e))\n```\n\n만약 `async function`에서 에러를 처리해주지 않으면 `async function`이 반환하는 `promise`가 `rejected`상태와 오류를 반환해줍니다. 이 경우에는 `async function`이 호출된 부분에서 에러를 처리해주어야 합니다.\n\n&nbsp;\n\n## 마무리\n\n자바스크립트의 비동기 처리에 대해 알아보았습니다. **async/await**를 이용하면 조금 더 직관적인 코드를 작성할 수 있을 것입니다.\n\n특히 **Promise**를 기반으로 하고 있기 때문에, 직관적이면서도 비동기 작업을 단순히 동기적으로 보여지는 가독성만 높이는 것이 아니라, 하나의 값으로 다루면서 유연하게 처리할 수 있도록 공부해야겠습니다.\n","html":"<p><img src=\"/javascript/javascript-promise-async-await/img/async_await.png\" alt=\"async and await\"></p>\n<p>안녕하세요. 오늘은 자바스크립트의 비동기 처리를 다루는 async/await 문법에 대해 알아보겠습니다. 지난 글에서 다루었던 <a href=\"6\">Promise</a>와 함께 자바스크립트의 비동기 패턴 중 하나입니다. 또한 async/await 패턴은 <strong>Promise</strong>를 기반으로 하고 있습니다. 혹시 아직 <strong>Promise</strong>에 대해 모르신다면 이 글들을 추천드립니다.</p>\n<blockquote>\n<p><a href=\"https://joshua1988.github.io/web-development/javascript/promise-for-beginners/\">자바스크립트 Promise 쉽게 이해하기 • Captain Pangyo</a><br><a href=\"https://developer.mozilla.org/ko-KR/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise - MDN - Mozilla</a></p>\n</blockquote>\n<hr>\n<h2 id=\"1-asyncawait-문법-살펴보기\">1. async/await 문법 살펴보기</h2>\n<p><strong>async/await</strong>는 ECMAScript 2017부터 추가된 문법입니다. <strong>Promise</strong>를 살펴볼 때, 하나의 객체로 취급했었습니다. 그래서 <strong>Promise</strong>가 자바스크립트 표준으로 정의되기 전에도 커스텀으로 구현되어 사용되어지고 있었습니다. 하지만 <strong>async/await</strong>는 하나의 문법이기 때문에 라이브러리나 모듈이 아닌 자바스크립트 새로운 키워드를 사용합니다.</p>\n<p><strong>async/await</strong>는 새로운 문법이기 때문에 최신 버전의 자바스크립트를 지원하지 않는 런타임에서는 구동할 수 없습니다. 오늘의 예제 코드는 Chrome 브라우저에서 실행되는 코드이며, Chrome에서는 <strong>async/await</strong>문법을 지원합니다.</p>\n<p>&nbsp;</p>\n<h3 id=\"1-1-async-function비동기-함수-정의하기\">1-1. async function(비동기 함수) 정의하기</h3>\n<blockquote>\n<p>async function 선언은 AsyncFunction객체를 반환하는 하나의 비동기 함수를 정의합니다. <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function\"><em>(출처: MDN)</em></a></p>\n</blockquote>\n<p><code>async</code> 키워드를 이용하여 함수를 선언하면 <code>AsyncFunction</code>객체를 만들 수 있습니다. 코드를 함께 보겠습니다.</p>\n<pre><code class=\"language-js\">function myFunc() {\n  return &#39;Hello Function&#39;\n}\nconsole.log(myFunc)\n\nasync function myAsyncFunc() {\n  return &#39;Hello Async Function&#39;\n}\nconsole.log(myAsyncFunc)\n</code></pre>\n<p>기존 <code>function</code>키워드로 선언한 함수와 <code>async function</code>키워드로 선언한 함수를 비교해 보겠습니다. 출력 로그를 확인해 보세요.</p>\n<p><img src=\"/javascript/javascript-promise-async-await/img/async_screenshot_1.png\" alt=\"async function\"></p>\n<p><code>async function</code>키워드로 선언한 함수는 <code>async f</code>로 표시되는 것을 볼 수 있습니다. 화살표 함수로도 선언할 수 있습니다.</p>\n<pre><code class=\"language-js\">async function myAsyncFunc() {\n  return &#39;Hello Async function&#39;\n}\nconsole.log(myAsyncFunc)\n\nconst myAsyncArrow = async () =&gt; &#39;Hello Async Arrow&#39;\nconsole.log(myAsyncArrow)\n</code></pre>\n<p><img src=\"/javascript/javascript-promise-async-await/img/async_screenshot_2.png\" alt=\"async function\"></p>\n<p>&nbsp;</p>\n<h3 id=\"1-2-await-키워드와-함께-사용하기\">1-2. await 키워드와 함께 사용하기</h3>\n<blockquote>\n<p>await 연산자는 async function 내부에서만 사용할 수 있습니다. <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/await\"><em>(출처: MDN)</em></a></p>\n</blockquote>\n<p><code>await</code>키워드는 <code>async function</code>내부에서만 사용되어집니다. 만약 <code>async function</code>밖에서 사용한다면 문법이 틀렸다고 판단해 <code>SyntaxError</code>를 발생합니다.</p>\n<p><code>await</code>키워드는 <code>promise</code>를 기다리기 위해 사용됩니다. 즉, <code>async function</code> 내부에서 <code>promise</code>의 비동기 작업을 기다리기 위해 <code>await</code>키워드를 사용합니다. 코드를 보겠습니다.</p>\n<pre><code class=\"language-js\">// 브라우저에 내장된 fetch함수를 이용해 비동기 작업을 수행합니다.\n// fetch함수는 URL로부터 데이터를 가져와서 promise를 반환합니다.\n// fetch(&#39;https://jsonplaceholder.typicode.com/posts/1&#39;)\n\nconst url = &#39;https://jsonplaceholder.typicode.com/posts/1&#39;\nasync function myAsyncFunc() {\n  const data = await fetch(url)\n  console.log(&#39;await&#39;, data)\n}\nmyAsyncFunc()\n</code></pre>\n<p><img src=\"/javascript/javascript-promise-async-await/img/await_screenshot_1.png\" alt=\"await\"></p>\n<p>콘솔에서 실행해 보면 <code>Response</code>객체가 출력되는 것을 볼 수 있습니다. <code>fetch API</code>를 통해 불러온 데이터가 출력되는 것입니다. <code>fetch</code>함수에서 비동기 작업이 이루어지고, <code>await</code>키워드가 붙었기 때문에 <code>async function</code>내에서 해당 작업을 기다립니다.</p>\n<p>만약 위와 같은 작업을 <code>promise</code>패턴으로 코드를 작성하면 다음과 같을 것입니다.</p>\n<pre><code class=\"language-js\">const url = &#39;https://jsonplaceholder.typicode.com/posts/1&#39;\nfunction myFunc() {\n  fetch(url).then(data =&gt; {\n    console.log(data)\n  })\n}\n</code></pre>\n<p>아직 코드의 양이나 로직이 이해되는 것에 크게 차이가 있지 않아 보입니다. 하지만 비동기 작업이 많아지거나 함수의 코드가 길어지면 <code>await</code>키워드를 이용하여 조금 더 가독성이 좋은 직관적인 코드를 작성할 수 있습니다.\n<em>(Promise와 async/await는 비동기 작업을 다루는 패턴 중 하나입니다. 개인 취향에 따라 다르게 평가될 수 있습니다.)</em></p>\n<p>비동기 작업이 여러 번 반복된다면 더 진가를 발휘한다고 생각합니다.</p>\n<pre><code class=\"language-js\">const userDataUrl = &#39;https://jsonplaceholder.typicode.com/users/1&#39;\nconst postDataUrl = &#39;https://jsonplaceholder.typicode.com/posts/1&#39;\n\n// promise 패턴\nfunction myFunc() {\n  fetch(userDataUrl)\n    .then(res =&gt; res.json())\n    .then(user =&gt; {\n      console.log(user)\n    })\n  fetch(postDataUrl)\n    .then(res =&gt; res.json())\n    .then(post =&gt; {\n      console.log(post)\n    })\n}\nmyFunc()\n\n// async/await 패턴\nasync function myAsyncFunc() {\n  const user = await fetch(userDataUrl).then(res =&gt; res.json())\n  const post = await fetch(postDataUrl).then(res =&gt; res.json())\n\n  console.log(user)\n  console.log(post)\n}\nmyAsyncFunc()\n</code></pre>\n<p>위 코드에서 <code>console.log</code>부분의 작업이 단순히 출력이 아니라고 생각해보세요. <code>user</code>데이터와 <code>post</code>데이터를 함께 다루어야 한다면 <code>promise</code>패턴보다 <code>async/await</code>패턴으로 더 직관적인 코드를 작성할 수 있을 것입니다.</p>\n<hr>\n<p>&nbsp;</p>\n<h2 id=\"2-asyncawait-이해--응용하기\">2. async/await 이해 &amp; 응용하기</h2>\n<p>새로운 문법이라 하더라도 자바스크립트의 비동기 처리의 코어 내부적인 동작이 크게 달라진 것은 아닙니다. 그럼 어떻게 async/await이 동작하는지 이해하고 비동기 작업을 다양한 상황에서 잘 다룰 수 있게 살펴봅시다.</p>\n<p>&nbsp;</p>\n<h3 id=\"2-1-async-function-이해하기\">2-1. async function 이해하기</h3>\n<p><code>await</code>키워드가 <code>promise</code>를 기다리는 동작이 마치 프로그램이 정지된 것처럼 느껴질 수 있습니다. 하지만 <code>promise.then</code>함수처럼 다음 동작이 완료되는 것을 기다리는 것뿐입니다. <code>await</code>키워드가 <code>async function</code> 내부에서만 사용할 수 있다는 것을 기억하세요. <code>await</code>키워드가 <code>promise</code>를 기다릴 수 있는 이유는 <code>async function</code>이 이미 <code>promise</code>를 반환하기 때문입니다. 코드를 통해서 동작을 이해해 봅시다.</p>\n<pre><code class=\"language-js\">async function myAsyncFunc() {\n  const result = await new Promise(res =&gt; {\n    setTimeout(res, 1000, &#39;hello&#39;)\n  })\n  console.log(result)\n  return result\n}\nconsole.log(myAsyncFunc())\nconsole.log(&#39;Finish&#39;)\n</code></pre>\n<p>위 코드의 순서를 한번 보세요. <code>async function</code>인 <code>myAsyncFunc</code>을 호출하면서 동시에 반환값을 출력해보면 <code>Promise {&lt;pending&gt;}</code>이 출력됩니다. 그 후에 <code>Finish</code>가 출력되고, 1초 후에 <code>hello</code>가 출력됩니다.</p>\n<p>출력순서:</p>\n<ul>\n<li><code>Promise {&lt;pending&gt;}</code></li>\n<li><code>Finish</code></li>\n<li><code>Hello</code></li>\n</ul>\n<p><code>async function</code>이 호출되면 즉시 <code>promise</code>가 반환됩니다. 위 코드에서 <code>myAsyncFunc()</code>로 함수를 호출하고 나면 메인 콜스택에서는 <code>promise</code>를 반환받고, 내부의 동작에는 신경쓰지 않습니다. <code>async function</code> 내부의 <code>await</code>의 기다림 동작에서도 메인 프로세스는 멈추지 않고 동작할 수 있습니다.</p>\n<p>또한 <code>async function</code>에서 <code>return</code>되는 값을 그 <code>promise</code>의 <code>resolved</code>로 전달됩니다. 그렇기 때문에 <code>return</code> 구문에서는 <code>await</code> 키워드를 사용할 필요가 없습니다.</p>\n<pre><code class=\"language-js\">async function myAsyncFunc() {\n  return &#39;Done&#39;\n}\nconst result = myAsyncFunc()\nresult.then(console.log)\nconsole.log(result)\n</code></pre>\n<p>&nbsp;</p>\n<h3 id=\"2-2-await-이해하기\">2-2. await 이해하기</h3>\n<p><code>await</code>키워드가 사용되는 문법은 이러한 형태입니다.</p>\n<pre><code class=\"language-js\">async function myAsyncFunc() {\n  await someAsyncFunc()\n  // or\n  await somePromise\n  // or\n  await someValue\n}\n</code></pre>\n<p><code>await</code>는 <code>promise</code>를 기다린 후에 반환하지만, 꼭 <code>promise</code>가 아닌 <code>어떤 값</code>일 수도 있습니다.</p>\n<pre><code class=\"language-js\">function getPromise() {\n  return new Promise(res =&gt; setTimeout(res, 1000, &#39;promise&#39;))\n}\nasync function myAsyncFunc() {\n  const someCondition = Math.random() &gt; 0.5\n  const result = await (someCondition ? getPromise() : &#39;Done&#39;)\n  console.log(result)\n}\nmyAsyncFunc()\n</code></pre>\n<p>위 코드를 여러 번 실행해 보면, 실행할 때 마다 다른 결과를 얻을 수 있습니다. <code>someCondition</code>에 따라 <code>await</code>키워드는 <code>promise</code>를 받을 수도, <code>Done</code>이라는 값을 받을 수도 있습니다. 만약 <code>promise</code>라면 해당 동작을 기다린 후에 값을 <code>result</code>에 전달합니다.</p>\n<p>이러한 특징을 이용해서 어떠한 값에 대해 <code>promise</code>이든 <code>어떤 값</code>이든 유연하게 처리할 수 있습니다.</p>\n<h3 id=\"2-3-asyncawait와-promise-응용하기\">2-3. async/await와 promise 응용하기</h3>\n<p><code>async function</code>내에서 <code>await</code>를 이용하여 원하는 시점에 결과값을 다룰 수 있습니다. 다음 코드를 봅시다.</p>\n<pre><code class=\"language-js\">function delay(time, msg) {\n  return new Promise(res =&gt;\n    setTimeout(() =&gt; {\n      console.log(msg)\n      res(msg)\n    }, time),\n  )\n}\nasync function myAsyncFunc() {\n  const result1 = await delay(1000, &#39;Hello&#39;)\n  const result2 = await delay(2000, &#39;Async&#39;)\n}\nmyAsyncFunc()\n</code></pre>\n<p><code>dealy</code>함수는 입력된 시간후에 <code>msg</code>를 출력하는 함수입니다. 비동기 작업인 <code>delay</code>함수를 호출할 때마다 <code>await</code>를 붙여주었습니다. 위 코드의 실행 순서는 먼저 1초를 기다린 후 <code>Hello</code>가 출력되고, 2초후에 <code>Async</code>가 출력됩니다. 두번째 <code>delay</code>함수가 호출되기 위해서 앞선 <code>delay</code>함수가 끝날 때까지 <code>await</code>로 인해 기다리게 됩니다. 동작이 완료되기 위해서는 총 3초의 시간이 소요됩니다.</p>\n<p>만약 두 개의 비동기 작업이 서로 관련이 없이 독립적으로 동작해도 괜찮다면 이렇게 코드를 수정할 수 있을 것입니다.</p>\n<pre><code class=\"language-js\">function delay(time, msg) {\n  return new Promise(res =&gt;\n    setTimeout(() =&gt; {\n      console.log(msg)\n      res(msg)\n    }, time),\n  )\n}\nasync function myAsyncFunc() {\n  const _result1 = delay(1000, &#39;Hello&#39;)\n  const _result2 = delay(2000, &#39;Async&#39;)\n  const result1 = await _result1\n  const result2 = await _result2\n}\nmyAsyncFunc()\n</code></pre>\n<p>이전의 순서와 다른 점을 찾으셨나요? <code>delay</code>함수를 호출하는 순서는 같지만, 두번째 <code>delay</code>함수가 호출되기 위해서 첫번째 <code>delay</code>함수를 기다리지 않습니다. 그렇기 때문에 두 개의 <code>delay</code>함수가 지연없이 연속적으로 호출됩니다. 출력 시간도 1초 후에 <code>Hello</code>가 출력되고, 또 1초후에 <code>Async</code>가 출력됩니다. 총 소요 시간은 2초 정도의 시간이 소요됩니다.</p>\n<p>이렇게 비동기 작업이 서로 연관이 없거나, 독립적인 요청으로 데이터를 불러올 수 있는 상황이라면 필요한 시점에 <code>await</code>를 사용하면 됩니다. 또 <code>Promise</code> 메소드를 이용하면 이렇게 표현할 수도 있습니다.</p>\n<pre><code class=\"language-js\">function delay(time, msg) {\n  return new Promise(res =&gt;\n    setTimeout(() =&gt; {\n      console.log(msg)\n      res(msg)\n    }, time),\n  )\n}\nasync function myAsyncFunc() {\n  const _result1 = delay(1000, &#39;Hello&#39;)\n  const _result2 = delay(2000, &#39;Async&#39;)\n  const [result1, result2] = await Promise.all([_result1, _result2])\n}\nmyAsyncFunc()\n</code></pre>\n<hr>\n<p>&nbsp;</p>\n<h3 id=\"3-asyncawait-예외-처리하기\">3. async/await 예외 처리하기</h3>\n<p><code>async function</code>에서 <strong>예외 처리</strong>방법은 <code>try/catch</code>를 이용합니다.</p>\n<pre><code class=\"language-js\">const url = &#39;https://jsonplaceholder.typicode.com&#39;\nconst getData = async (field, id) =&gt; {\n  const _id = id ? `/${id}` : &#39;&#39;\n  return fetch(`${url}/${field}${_id}`).then(res =&gt; res.json())\n}\nasync function myAsyncFunc() {\n  try {\n    const posts = await getData(&#39;posts&#39;)\n    console.log(posts)\n  } catch (e) {\n    console.error(e)\n  }\n}\nmyAsyncFunc()\n</code></pre>\n<p><code>async function</code>내에서 발생하는 오류에 대해 위와 같이 처리할 수 있습니다. 비동기에 대한 오류 뿐만 아니라 일반적인 오류도 처리할 수 있습니다. 만약 <code>await</code>가 기다리는 <code>promise</code>인 <code>getData</code>함수가 <code>rejected</code>를 반환한다면 오류가 발생하게 됩니다.</p>\n<pre><code class=\"language-js\">const url = &#39;https://jsonplaceholder.typicode.com&#39;\nasync function myAsyncFunc() {\n  const posts = await fetch(`${url}/posts`).then(res =&gt; res.json())\n  throw new Error(&#39;Error in Async!!&#39;)\n  console.log(posts)\n}\nmyAsyncFunc()\n  .then(() =&gt; console.log(&#39;Done&#39;))\n  .catch(e =&gt; console.log(e))\n</code></pre>\n<p>만약 <code>async function</code>에서 에러를 처리해주지 않으면 <code>async function</code>이 반환하는 <code>promise</code>가 <code>rejected</code>상태와 오류를 반환해줍니다. 이 경우에는 <code>async function</code>이 호출된 부분에서 에러를 처리해주어야 합니다.</p>\n<p>&nbsp;</p>\n<h2 id=\"마무리\">마무리</h2>\n<p>자바스크립트의 비동기 처리에 대해 알아보았습니다. <strong>async/await</strong>를 이용하면 조금 더 직관적인 코드를 작성할 수 있을 것입니다.</p>\n<p>특히 <strong>Promise</strong>를 기반으로 하고 있기 때문에, 직관적이면서도 비동기 작업을 단순히 동기적으로 보여지는 가독성만 높이는 것이 아니라, 하나의 값으로 다루면서 유연하게 처리할 수 있도록 공부해야겠습니다.</p>\n","excerpt":" 안녕하세요. 오늘은 자바스크립트의 비동기 처리를 다루는 async/await 문법에 대해 알아보겠습니다. 지난 글에서 다루었던 Promise와 함께 자바스크립트의 비동기 패턴 중 하나입니다. 또한 async/await 패턴은 Promise를 기반으로 하고 있습니다. 혹시 아직 Promise에 대해 모르신다면 이 글들을 추천드립니다.  자바스크립트 Promi","thumbnail":"/javascript/javascript-promise-async-await/img/async_await.png","thumbnailUrl":"https://hoontae24.github.io/javascript/javascript-promise-async-await/img/async_await.png"},{"href":"6","round":6,"paths":["javascript","javascript-promise-concept-and-usage"],"slug":"javascript-promise-concept-and-usage","title":"Javascript의 비동기 처리, Promise를 알아보자","description":"싱글스레드 환경에서 동작하는 자바스크립트의 비동기 처리를 하기 위한 Promise의 개념과 기본적인 사용법을 알아보겠습니다.","date":"2019-12-28","category":"javascript","tags":["javascript","promise"],"seriesId":null,"markdown":"\n![promise](/javascript/javascript-promise-concept-and-usage/img/promise.png)\n\n오늘은 자바스크립트에서 비동기 처리를 다루는 **Promise**에 대해 알아보겠습니다.\n\n## 1. Promise? 왜 필요할까요?\n\n자바스크립트 코드가 동작할 때, 어떠한 작업을 기다리게 된다면 어떻게 될까요? 만약 브라우저에서 실행되는 코드라면 웹 페이지의 동작이 멈추게 될 것입니다. 특히 웹 페이지에서는 1-2초의 먹통에도 사용자는 답답함을 느끼게 됩니다. 개발자는 이러한 상황을 만들지 않고 싶을 것입니다.\n\n자바스크립트는 그러한 상황에서 그 작업을 기다리지 않고 다음 작업을 수행하는 특성을 가지고 있습니다. 그래서 즉시 응답을 보장하지 못하는 경우에는 따로 비동기를 위한 처리를 해주어야 합니다. 대표적인 방법으로 기존에 많이 쓰였던 **Callback**함수를 이용한 패턴이 있습니다.\n\n예시 코드를 통해서 **Callback**함수를 사용하는 방식을 간단히 짚어보겠습니다.\n\n```js\n// getUsers: 사용자 목록을 불러오는 함수\ngetUsers(users => {\n  console.log(users)\n})\n```\n\n`getUsers`라는 함수를 통해 사용자의 데이터를 불러오는 작업을 가정해봅시다. 불러오는 값이 즉시 반환되지 못하고, API서버나 DB 등에서 불러오는 작업을 한다면 비동기 작업으로 이루어집니다. `getUsers` 내부에서는 불러온 `users` 데이터를 `Callback`함수의 인자로 전달해 주어, 해당 데이터를 다룰 수 있게 됩니다.\n\n만약 이러한 작업이 여러 개이면 어떨까요?\n\n```js\n// getUsers: 사용자 목록을 불러오는 함수\n// getPosts: 게시글 목록을 불러오는 함수\n// getComments: 댓글 목록을 불러오는 함수\ngetUsers(users => {\n  getPosts(posts => {\n    getComments(comments => {\n      console.log(users, posts, comments)\n    })\n  })\n})\n```\n\n위와 같이 비동기 작업이 연속적으로 여러 개라면 콜백 안의 콜백으로 이루어져 조금 더 복잡해 보입니다. 또 다른 경우를 봅시다.\n\n```js\n// getUsers: 사용자 목록을 불러오는 함수\n// getPosts: 게시글 목록을 불러오는 함수\n// getComments: 댓글 목록을 불러오는 함수\nconst data = {}\nfunction doSomething() {\n  const { users, posts, comments } = data\n  if (!users || !posts || !comments) return\n  // do something with users, posts, comments...\n}\n\ngetUsers(users => {\n  data.users = users\n  doSomething()\n})\ngetPosts(posts => {\n  data.posts = posts\n  doSomething()\n})\ngetComments(comments => {\n  data.comments = comments\n  doSomething()\n})\n```\n\n이번에는 세가지의 비동기 작업이 병렬적으로 진행됩니다. 하지만 세가지 데이터를 한번에 다룰 작업이 필요하다면 코드가 복잡해지고, 가독성도 떨어지게 됩니다.\n\n## 2. 그럼... Promise 어떻게 사용할까요?\n\n이제 본격적으로 **Promise**에 대해 알아보겠습니다. **Promise**는 콜백 방식에 비해 비동기 작업을 조금 더 유연하게 다룰 수 있습니다.\n\n> Promise 개체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다.\n> [_(출처: MDN)_](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\n**Promise**는 비동기 작업을 하나의 객체로 다루는 개념입니다. 단순히 **Callback**보다 깔끔한 코드를 위해서가 아니라 작업 자체를 값으로 생각하는 것입니다.\n\n### 2.1 Promise 객체 생성하기\n\n그럼 **Promise**가 어떻게 사용되어지고, 동작하는지 한번 알아봅시다.\n\n```js\nconst promise = new Promise((resolve, reject) => {\n  // ... do something with async process\n  resolve('완료!')\n})\nconsole.log(promise) // output: Promise {<resolved>: \"완료!\"}\n```\n\n`Promise`는 `new Promise()`를 통해 객체를 생성합니다. 생성자의 인자로 넘겨준 `executor(callback)`함수에서 `resolve`를 호출하여 작업을 처리합니다. 그렇게 출력되어진 결과는 `완료!`라는 값을 가진 `Promise` 객체입니다.\n\n### 2.2 Promise의 상태\n\n- 대기(pending): 이행하거나 거부되지 않은 초기 상태\n- 이행(fulfilled): 연산이 성공적으로 완료됨\n- 거부(rejected): 연산이 실패함\n\n**Promise**는 위와 같은 세가지 중 하나의 상태를 가집니다. 위의 코드에서 `new Promise()`에 전달한 함수에서 첫번째 인자인 `resolve`를 호출하면 **이행(fulfilled)** 상태가 됩니다. 만약 두번째 인자인 `reject`를 호출하면 **거부(rejected)** 상태가 됩니다. 그리고 주석 처리된 부분에서 비동기 작업이 아직 진행 중이면 아직 `resolve`나 `reject`를 호출하지 않았기 때문에 **대기(pending)** 상태가 됩니다.  \n_(**대기** 중이지 않으며 **이행** 또는 **거부** 상태가 된 것을 **처리(settled)** 라고 부르기도 합니다.)_\n\n```js\nconst pending = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('대기!'), 1000)\n})\nconst fulfilled = new Promise((resolve, reject) => {\n  resolve('완료!')\n})\nconst rejected = new Promise((resolve, reject) => {\n  reject('거부!')\n})\n\nconsole.log(pending) // output: Promise {<pending>}\nconsole.log(fulfilled) // output: Promise {<resolved>: \"완료!\"}\nconsole.log(rejected) // output: Promise {<rejected>: \"거부!\"}\nsetTimeout(() => console.log(pending), 1000) // output: Promise {<resolved>: \"대기!\"}\n```\n\n`Promise` 객체를 콘솔에 출력해보면 각각의 상태와 값을 볼 수 있습니다. `pending`의 경우에는 처음에는 `대기`상태였지만, 1초 후에 출력하면 `이행`상태가 되어 있는 것을 확인할 수 있습니다.\n\n이렇게 `Promise` 객체를 통해 비동기 작업을 코드의 순서와 관계없이 객체에 담아서 다룰 수 있습니다. 하지만 `Promise` 객체 자체를 데이터로 사용할 순 없으니, `이행` 또는 `거부`된 `Promise` 객체에서 값을 꺼내 다루는 법을 알아보겠습니다.\n\n### 2.3 Promise 사용하기\n\n`Promise`객체는 다음과 같은 메소드를 가집니다. 메소드를 호출하여 `Promise`객체에 담긴 값을 다룰 수 있습니다.\n\n- then: Promise에 이행 또는 거부에 대한 처리기(callback)를 추가합니다.\n- catch: Promise에 거부에 대한 처리기(callback)를 추가합니다.\n- finally: Promise가 처리(settled)되면 무조건 실행되는 처리기(callback)를 추가합니다.\n\n```js\nconst promise = new Promise((res, rej) => {\n  // 무언가 비동기 작업...\n  const data = { users: ['Jason', 'Conan'] }\n  if (data) {\n    res(data)\n  } else {\n    rej(new Error('data가 없어요'))\n  }\n})\n\npromise\n  .then(value => {\n    console.log(value.users) // output: ['Jason', 'Conan']\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n\n위의 3가지 메소드는 모두 `Promise`객체를 반환합니다. `then`과 `catch`는 콜백함수의 반환값이 담긴 `이행(fulfilled)`된 `Promise`가 반환됩니다. `finally`는 콜백 함수에서 에러가 발생하면 `거부`된 `Promise`가 반환되고, 그렇지 않으면 `finally`가 호출된 `Promise`가 반환됩니다.\n\n`Promise`의 메소드는 값의 변경이 있든 아니든 다시 `Promise`를 반환하기 때문에 메소드 체이닝(Chaining)이 가능합니다. 이미 위의 `then`과 `catch`를 이어서 호출한 것도 그때문에 가능합니다.\n\n```js\nconst promise = new Promise((res, rej) => {\n  // 무언가 비동기 작업...\n  const data = { users: ['Jason', 'Conan'] }\n  if (data) {\n    res(data)\n  } else {\n    rej(new Error('data가 없어요'))\n  }\n})\n\npromise\n  .then(value => {\n    return new Promise(res => {\n      // 무언가...\n      res(value.users)\n    })\n  })\n  .then(users => {\n    return new Promise(res => {\n      // 비동기...\n      res(users.map(user => user.length))\n    })\n  })\n  .then(counts => {\n    // 작업...\n    console.log(counts) // output: [5, 5]\n  })\n  .catch(err => {\n    console.error(err)\n  })\n```\n\n이렇게 `Promise`의 체이닝을 이용해서 연속적인 비동기 작업을 처리할 수 있습니다. 위의 코드에서는 `new Promise()`를 선언하여 객체를 생성했지만, 비동기 작업에 대한 코드를 미리 `Promise`객체를 반환하는 라이브러리를 사용하거나 함수를 선언해두면 더 보기 좋게 코드를 작성할 수 있습니다.\n\n### 2.4 Promise 메소드 더 알아보기\n\n`Promise`에는 자체 메소드가 몇가지 있습니다.\n\n- Promise.all()\n- Promise.race()\n- Promise.resolve()\n- Promise.reject()\n\n#### 2.4.1 Promise.all\n\n`Promise.all()` 메소드는 여러 개의 `Promise`객체의 처리 여부에 대한 작업을 수행합니다. 또한 인자로 받는 `iterable`의 모든 처리 결과가 `이행(fulfilled)`이면 `Promise.all()`은 `이행`된 `Promise`객체를 반환합니다. 만약 하나의 `Promise` 객체라도 `거부(rejected)`되면 `Promise.all()`은 즉시 `거부`된 `Promise`를 반환합니다.\n\n```js\nconst promise1 = new Promise(res => res(1))\nconst promise2 = new Promise(res => res(2))\nconst promise3 = new Promise((r, j) => r(3))\nconst promise = Promise.all([promise1, promise2, promise3])\npromise.then(value => {\n  console.log(value) // output: [1, 2, 3]\n})\n```\n\n위의 코드에서는 간단히 작성 하였지만, 여러개의 비동기 작업을 처리해야 할 때 잘 활용하면 좋습니다. `이행`된 값을 확인해 보면 `Promise.all()`의 매개변수로 넘겨준 `iterable`의 각각의 `이행`된 값을 가지고 있습니다.\n\n#### 2.4.2 Promise.race()\n\n`Promise.race()` 메소드는 여러 개의 `Promise`객체를 매개변수로 받아 가장 먼저 `처리(settled)`된 `Promise` 객체를 반환합니.\n\n```js\nconst promise1 = new Promise(res => setTimeout(() => res(1), 1000))\nconst promise2 = new Promise(res => setTimeout(() => res(2), 500))\nconst promise3 = new Promise((res, rej) => rej(3))\nconst promise = Promise.race([promise1, promise2, promise3])\npromise\n  .then(value => {\n    console.log(value) // \"이행되지 않음\"\n  })\n  .catch(err => {\n    console.log('error:', err) // output: error: 3\n  })\n```\n\n#### 2.4.3 Promise.resolve() / Promise.reject()\n\n`Promise.resolve()`메소드는 파라미터로 넘겨준 값을 가진 `이행`된 `Promise` 객체를 즉시 반환합니다. 만약 어떤 값을 처리할 때, `Promise`인지 아닌지 확실하지 않은데 `Promise`로 처리하고자 하면 `Promise.resolve(value)`를 이행한 후 반환된 `Promise`에 대해 값을 처리하면 됩니다.\n\n`Promise.reject()`메소드는 파라미터로 넘겨준 이유로 `거부`된 `Promise` 객체를 반환합니다.\n\n## 마무리\n\n이렇게 **Promise**를 다루는 방법을 알아 보았습니다. 어떻게 사용되어지고 어떠한 메소드들이 있는지 알아보았는데, 사실 이번 글을 통해 비동기를 다루는 **Promise**의 특징과 장점에 대해서는 많이 알지 못해서 조금 아쉽습니다. 단순히 사용법을 넘어서 **Promise**를 이용해 비동기를 더 유연하고, 쉽게 다루는 스킬을 익혀야겠습니다.\n","html":"<p><img src=\"/javascript/javascript-promise-concept-and-usage/img/promise.png\" alt=\"promise\"></p>\n<p>오늘은 자바스크립트에서 비동기 처리를 다루는 <strong>Promise</strong>에 대해 알아보겠습니다.</p>\n<h2 id=\"1-promise-왜-필요할까요\">1. Promise? 왜 필요할까요?</h2>\n<p>자바스크립트 코드가 동작할 때, 어떠한 작업을 기다리게 된다면 어떻게 될까요? 만약 브라우저에서 실행되는 코드라면 웹 페이지의 동작이 멈추게 될 것입니다. 특히 웹 페이지에서는 1-2초의 먹통에도 사용자는 답답함을 느끼게 됩니다. 개발자는 이러한 상황을 만들지 않고 싶을 것입니다.</p>\n<p>자바스크립트는 그러한 상황에서 그 작업을 기다리지 않고 다음 작업을 수행하는 특성을 가지고 있습니다. 그래서 즉시 응답을 보장하지 못하는 경우에는 따로 비동기를 위한 처리를 해주어야 합니다. 대표적인 방법으로 기존에 많이 쓰였던 <strong>Callback</strong>함수를 이용한 패턴이 있습니다.</p>\n<p>예시 코드를 통해서 <strong>Callback</strong>함수를 사용하는 방식을 간단히 짚어보겠습니다.</p>\n<pre><code class=\"language-js\">// getUsers: 사용자 목록을 불러오는 함수\ngetUsers(users =&gt; {\n  console.log(users)\n})\n</code></pre>\n<p><code>getUsers</code>라는 함수를 통해 사용자의 데이터를 불러오는 작업을 가정해봅시다. 불러오는 값이 즉시 반환되지 못하고, API서버나 DB 등에서 불러오는 작업을 한다면 비동기 작업으로 이루어집니다. <code>getUsers</code> 내부에서는 불러온 <code>users</code> 데이터를 <code>Callback</code>함수의 인자로 전달해 주어, 해당 데이터를 다룰 수 있게 됩니다.</p>\n<p>만약 이러한 작업이 여러 개이면 어떨까요?</p>\n<pre><code class=\"language-js\">// getUsers: 사용자 목록을 불러오는 함수\n// getPosts: 게시글 목록을 불러오는 함수\n// getComments: 댓글 목록을 불러오는 함수\ngetUsers(users =&gt; {\n  getPosts(posts =&gt; {\n    getComments(comments =&gt; {\n      console.log(users, posts, comments)\n    })\n  })\n})\n</code></pre>\n<p>위와 같이 비동기 작업이 연속적으로 여러 개라면 콜백 안의 콜백으로 이루어져 조금 더 복잡해 보입니다. 또 다른 경우를 봅시다.</p>\n<pre><code class=\"language-js\">// getUsers: 사용자 목록을 불러오는 함수\n// getPosts: 게시글 목록을 불러오는 함수\n// getComments: 댓글 목록을 불러오는 함수\nconst data = {}\nfunction doSomething() {\n  const { users, posts, comments } = data\n  if (!users || !posts || !comments) return\n  // do something with users, posts, comments...\n}\n\ngetUsers(users =&gt; {\n  data.users = users\n  doSomething()\n})\ngetPosts(posts =&gt; {\n  data.posts = posts\n  doSomething()\n})\ngetComments(comments =&gt; {\n  data.comments = comments\n  doSomething()\n})\n</code></pre>\n<p>이번에는 세가지의 비동기 작업이 병렬적으로 진행됩니다. 하지만 세가지 데이터를 한번에 다룰 작업이 필요하다면 코드가 복잡해지고, 가독성도 떨어지게 됩니다.</p>\n<h2 id=\"2-그럼-promise-어떻게-사용할까요\">2. 그럼... Promise 어떻게 사용할까요?</h2>\n<p>이제 본격적으로 <strong>Promise</strong>에 대해 알아보겠습니다. <strong>Promise</strong>는 콜백 방식에 비해 비동기 작업을 조금 더 유연하게 다룰 수 있습니다.</p>\n<blockquote>\n<p>Promise 개체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다.\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><em>(출처: MDN)</em></a></p>\n</blockquote>\n<p><strong>Promise</strong>는 비동기 작업을 하나의 객체로 다루는 개념입니다. 단순히 <strong>Callback</strong>보다 깔끔한 코드를 위해서가 아니라 작업 자체를 값으로 생각하는 것입니다.</p>\n<h3 id=\"21-promise-객체-생성하기\">2.1 Promise 객체 생성하기</h3>\n<p>그럼 <strong>Promise</strong>가 어떻게 사용되어지고, 동작하는지 한번 알아봅시다.</p>\n<pre><code class=\"language-js\">const promise = new Promise((resolve, reject) =&gt; {\n  // ... do something with async process\n  resolve(&#39;완료!&#39;)\n})\nconsole.log(promise) // output: Promise {&lt;resolved&gt;: &quot;완료!&quot;}\n</code></pre>\n<p><code>Promise</code>는 <code>new Promise()</code>를 통해 객체를 생성합니다. 생성자의 인자로 넘겨준 <code>executor(callback)</code>함수에서 <code>resolve</code>를 호출하여 작업을 처리합니다. 그렇게 출력되어진 결과는 <code>완료!</code>라는 값을 가진 <code>Promise</code> 객체입니다.</p>\n<h3 id=\"22-promise의-상태\">2.2 Promise의 상태</h3>\n<ul>\n<li>대기(pending): 이행하거나 거부되지 않은 초기 상태</li>\n<li>이행(fulfilled): 연산이 성공적으로 완료됨</li>\n<li>거부(rejected): 연산이 실패함</li>\n</ul>\n<p><strong>Promise</strong>는 위와 같은 세가지 중 하나의 상태를 가집니다. 위의 코드에서 <code>new Promise()</code>에 전달한 함수에서 첫번째 인자인 <code>resolve</code>를 호출하면 <strong>이행(fulfilled)</strong> 상태가 됩니다. 만약 두번째 인자인 <code>reject</code>를 호출하면 <strong>거부(rejected)</strong> 상태가 됩니다. 그리고 주석 처리된 부분에서 비동기 작업이 아직 진행 중이면 아직 <code>resolve</code>나 <code>reject</code>를 호출하지 않았기 때문에 <strong>대기(pending)</strong> 상태가 됩니다.<br><em>(<strong>대기</strong> 중이지 않으며 <strong>이행</strong> 또는 <strong>거부</strong> 상태가 된 것을 <strong>처리(settled)</strong> 라고 부르기도 합니다.)</em></p>\n<pre><code class=\"language-js\">const pending = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; resolve(&#39;대기!&#39;), 1000)\n})\nconst fulfilled = new Promise((resolve, reject) =&gt; {\n  resolve(&#39;완료!&#39;)\n})\nconst rejected = new Promise((resolve, reject) =&gt; {\n  reject(&#39;거부!&#39;)\n})\n\nconsole.log(pending) // output: Promise {&lt;pending&gt;}\nconsole.log(fulfilled) // output: Promise {&lt;resolved&gt;: &quot;완료!&quot;}\nconsole.log(rejected) // output: Promise {&lt;rejected&gt;: &quot;거부!&quot;}\nsetTimeout(() =&gt; console.log(pending), 1000) // output: Promise {&lt;resolved&gt;: &quot;대기!&quot;}\n</code></pre>\n<p><code>Promise</code> 객체를 콘솔에 출력해보면 각각의 상태와 값을 볼 수 있습니다. <code>pending</code>의 경우에는 처음에는 <code>대기</code>상태였지만, 1초 후에 출력하면 <code>이행</code>상태가 되어 있는 것을 확인할 수 있습니다.</p>\n<p>이렇게 <code>Promise</code> 객체를 통해 비동기 작업을 코드의 순서와 관계없이 객체에 담아서 다룰 수 있습니다. 하지만 <code>Promise</code> 객체 자체를 데이터로 사용할 순 없으니, <code>이행</code> 또는 <code>거부</code>된 <code>Promise</code> 객체에서 값을 꺼내 다루는 법을 알아보겠습니다.</p>\n<h3 id=\"23-promise-사용하기\">2.3 Promise 사용하기</h3>\n<p><code>Promise</code>객체는 다음과 같은 메소드를 가집니다. 메소드를 호출하여 <code>Promise</code>객체에 담긴 값을 다룰 수 있습니다.</p>\n<ul>\n<li>then: Promise에 이행 또는 거부에 대한 처리기(callback)를 추가합니다.</li>\n<li>catch: Promise에 거부에 대한 처리기(callback)를 추가합니다.</li>\n<li>finally: Promise가 처리(settled)되면 무조건 실행되는 처리기(callback)를 추가합니다.</li>\n</ul>\n<pre><code class=\"language-js\">const promise = new Promise((res, rej) =&gt; {\n  // 무언가 비동기 작업...\n  const data = { users: [&#39;Jason&#39;, &#39;Conan&#39;] }\n  if (data) {\n    res(data)\n  } else {\n    rej(new Error(&#39;data가 없어요&#39;))\n  }\n})\n\npromise\n  .then(value =&gt; {\n    console.log(value.users) // output: [&#39;Jason&#39;, &#39;Conan&#39;]\n  })\n  .catch(err =&gt; {\n    console.error(err)\n  })\n</code></pre>\n<p>위의 3가지 메소드는 모두 <code>Promise</code>객체를 반환합니다. <code>then</code>과 <code>catch</code>는 콜백함수의 반환값이 담긴 <code>이행(fulfilled)</code>된 <code>Promise</code>가 반환됩니다. <code>finally</code>는 콜백 함수에서 에러가 발생하면 <code>거부</code>된 <code>Promise</code>가 반환되고, 그렇지 않으면 <code>finally</code>가 호출된 <code>Promise</code>가 반환됩니다.</p>\n<p><code>Promise</code>의 메소드는 값의 변경이 있든 아니든 다시 <code>Promise</code>를 반환하기 때문에 메소드 체이닝(Chaining)이 가능합니다. 이미 위의 <code>then</code>과 <code>catch</code>를 이어서 호출한 것도 그때문에 가능합니다.</p>\n<pre><code class=\"language-js\">const promise = new Promise((res, rej) =&gt; {\n  // 무언가 비동기 작업...\n  const data = { users: [&#39;Jason&#39;, &#39;Conan&#39;] }\n  if (data) {\n    res(data)\n  } else {\n    rej(new Error(&#39;data가 없어요&#39;))\n  }\n})\n\npromise\n  .then(value =&gt; {\n    return new Promise(res =&gt; {\n      // 무언가...\n      res(value.users)\n    })\n  })\n  .then(users =&gt; {\n    return new Promise(res =&gt; {\n      // 비동기...\n      res(users.map(user =&gt; user.length))\n    })\n  })\n  .then(counts =&gt; {\n    // 작업...\n    console.log(counts) // output: [5, 5]\n  })\n  .catch(err =&gt; {\n    console.error(err)\n  })\n</code></pre>\n<p>이렇게 <code>Promise</code>의 체이닝을 이용해서 연속적인 비동기 작업을 처리할 수 있습니다. 위의 코드에서는 <code>new Promise()</code>를 선언하여 객체를 생성했지만, 비동기 작업에 대한 코드를 미리 <code>Promise</code>객체를 반환하는 라이브러리를 사용하거나 함수를 선언해두면 더 보기 좋게 코드를 작성할 수 있습니다.</p>\n<h3 id=\"24-promise-메소드-더-알아보기\">2.4 Promise 메소드 더 알아보기</h3>\n<p><code>Promise</code>에는 자체 메소드가 몇가지 있습니다.</p>\n<ul>\n<li>Promise.all()</li>\n<li>Promise.race()</li>\n<li>Promise.resolve()</li>\n<li>Promise.reject()</li>\n</ul>\n<h4 id=\"241-promiseall\">2.4.1 Promise.all</h4>\n<p><code>Promise.all()</code> 메소드는 여러 개의 <code>Promise</code>객체의 처리 여부에 대한 작업을 수행합니다. 또한 인자로 받는 <code>iterable</code>의 모든 처리 결과가 <code>이행(fulfilled)</code>이면 <code>Promise.all()</code>은 <code>이행</code>된 <code>Promise</code>객체를 반환합니다. 만약 하나의 <code>Promise</code> 객체라도 <code>거부(rejected)</code>되면 <code>Promise.all()</code>은 즉시 <code>거부</code>된 <code>Promise</code>를 반환합니다.</p>\n<pre><code class=\"language-js\">const promise1 = new Promise(res =&gt; res(1))\nconst promise2 = new Promise(res =&gt; res(2))\nconst promise3 = new Promise((r, j) =&gt; r(3))\nconst promise = Promise.all([promise1, promise2, promise3])\npromise.then(value =&gt; {\n  console.log(value) // output: [1, 2, 3]\n})\n</code></pre>\n<p>위의 코드에서는 간단히 작성 하였지만, 여러개의 비동기 작업을 처리해야 할 때 잘 활용하면 좋습니다. <code>이행</code>된 값을 확인해 보면 <code>Promise.all()</code>의 매개변수로 넘겨준 <code>iterable</code>의 각각의 <code>이행</code>된 값을 가지고 있습니다.</p>\n<h4 id=\"242-promiserace\">2.4.2 Promise.race()</h4>\n<p><code>Promise.race()</code> 메소드는 여러 개의 <code>Promise</code>객체를 매개변수로 받아 가장 먼저 <code>처리(settled)</code>된 <code>Promise</code> 객체를 반환합니.</p>\n<pre><code class=\"language-js\">const promise1 = new Promise(res =&gt; setTimeout(() =&gt; res(1), 1000))\nconst promise2 = new Promise(res =&gt; setTimeout(() =&gt; res(2), 500))\nconst promise3 = new Promise((res, rej) =&gt; rej(3))\nconst promise = Promise.race([promise1, promise2, promise3])\npromise\n  .then(value =&gt; {\n    console.log(value) // &quot;이행되지 않음&quot;\n  })\n  .catch(err =&gt; {\n    console.log(&#39;error:&#39;, err) // output: error: 3\n  })\n</code></pre>\n<h4 id=\"243-promiseresolve--promisereject\">2.4.3 Promise.resolve() / Promise.reject()</h4>\n<p><code>Promise.resolve()</code>메소드는 파라미터로 넘겨준 값을 가진 <code>이행</code>된 <code>Promise</code> 객체를 즉시 반환합니다. 만약 어떤 값을 처리할 때, <code>Promise</code>인지 아닌지 확실하지 않은데 <code>Promise</code>로 처리하고자 하면 <code>Promise.resolve(value)</code>를 이행한 후 반환된 <code>Promise</code>에 대해 값을 처리하면 됩니다.</p>\n<p><code>Promise.reject()</code>메소드는 파라미터로 넘겨준 이유로 <code>거부</code>된 <code>Promise</code> 객체를 반환합니다.</p>\n<h2 id=\"마무리\">마무리</h2>\n<p>이렇게 <strong>Promise</strong>를 다루는 방법을 알아 보았습니다. 어떻게 사용되어지고 어떠한 메소드들이 있는지 알아보았는데, 사실 이번 글을 통해 비동기를 다루는 <strong>Promise</strong>의 특징과 장점에 대해서는 많이 알지 못해서 조금 아쉽습니다. 단순히 사용법을 넘어서 <strong>Promise</strong>를 이용해 비동기를 더 유연하고, 쉽게 다루는 스킬을 익혀야겠습니다.</p>\n","excerpt":"싱글스레드 환경에서 동작하는 자바스크립트의 비동기 처리를 하기 위한 Promise의 개념과 기본적인 사용법을 알아보겠습니다. 오늘은 자바스크립트에서 비동기 처리를 다루는 Promise에 대해 알아보겠습니다. 1. Promise? 왜 필요할까요? 자바스크립트 코드가 동작할 때, 어떠한 작업을 기다리게 된다면 어떻게 될까요? 만약 브라우저에서 실행되는 코드라면 웹 페이지의 동작이 멈추게 될 것입니다. 특히 웹 페이지에서는 1-2초의 먹통에도 사용자는 답답함을 느끼게 됩니다. 개발자는","thumbnail":"/javascript/javascript-promise-concept-and-usage/img/promise.png","thumbnailUrl":"https://hoontae24.github.io/javascript/javascript-promise-concept-and-usage/img/promise.png"},{"href":"5","round":5,"paths":["svelte","svelte-change-list-order"],"slug":"svelte-change-list-order","title":"Svelte로 만드는 TODO-App (3), Item 순서 변경하기","description":"","date":"2019-11-29","category":"svelte","tags":["javascript","frontend","svelte"],"seriesId":2,"markdown":"\n![svelte](/svelte/svelte-change-list-order/img/svelte_2.png)\n\n이번 포스트에서는 `Item`의 순서를 변경할 수 있도록 구현하겠습니다.\n\n### 1. Item 순서 변경 구현하기\n\n`Item`의 순서를 변경하여서 Todo-App을 사용하기 좋게 만들어 보겠습니다. 순서를 변경하는 UI/UX는 심플하게 드래그해서 변경할 수 있게 만들 것입니다.\n\n`event`를 이용하여 구현할 수도 있겠지만, 해본 적도 없고 하니 이미 만들어진 라이브러리를 이용하여 적용해보겠습니다.\n\n#### 1.1 Sortablejs 라이브러리 적용하기\n\n정렬을 구현하는 여러 라이브러리 중 [Sortablejs](https://github.com/SortableJS/Sortable)를 이용하겠습니다.\n\n`npm`을 이용해서 설치하겠습니다.\n\n> $ npm install sortablejs\n\n이제 각 `Board`의 리스트에 적용해 보겠습니다. `Item`들을 감싸는 `div`를 만들어줍니다. 또 `list`라는 변수를 선언해주고 만들어 준 `div`에 바인딩 시켜주겠습니다.\n\n`svelte`로 부터 `onMount`함수를 `import`하고, 그 안에 다음과 같이 구현해주세요. `list`변수에 `div` Element가 바인딩 되면 `Sortable` 라이브러리를 적용시키도록 합니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  import { onMount } from 'svelte'\n  import Sortable from 'sortablejs'\n  \n  let list = null\n  onMount(() => {\n    if(list) {\n      new Sortable(list)\n    }\n  })\n</script>\n<div id={board.id} class=\"item-list\" bind:this={list}>\n{#each _items as item (item.id)}\n  <Item\n    {item}\n    on:update={handleUpdateItem}\n    on:remove={handleRemoveItem}\n  />\n{/each}\n</div>\n```\n\n이제 브라우저로 가서 잘 적용되었는지 확인해 봅니다. `Item`을 드래그해서 이동할 수 있게 되었고, 순서도 변경이 됩니다.\n\n하지만 DOM Element만 움직이는 것 일뿐, 아직 실제 `Store`에 있는 데이터의 순서가 변경되는 것은 아닙니다.\n\n#### 1.2 Sortablejs를 이용하여 순서 변경 구현하기\n\n`Sortablejs`를 적용하여서 `DOM Element`를 드래그로 움직일 수 있게 했습니다. 드래그로 순서가 변경될 때, `Store`에 있는 실제 데이터가 변경되도록, 이벤트 핸들러를 연결시켜주면 됩니다.\n\n먼저 그 전에 `Store`에 있는 데이터에서 `Item`의 `id` 값을 약간 수정해주고, `Item` 컴포넌트에서 드래그 핸들을 만들어주도록 하겠습니다.\n\n```js\n// stores/index.js\nconst _boards = [\n  { id: uuid(), title: 'Planning' },\n  { id: uuid(), title: 'In Progress' },\n  { id: uuid(), title: 'All Done' },\n]\n\nconst _items = [\n  { id: uuid(), boardId: _boards[0].id, title: '자료 조사하기', done: false },\n  { id: uuid(), boardId: _boards[0].id, title: '교양책 읽기', done: false },\n  { id: uuid(), boardId: _boards[1].id, title: '분리수거하기', done: false },\n  { id: uuid(), boardId: _boards[1].id, title: '가계부 정리하기', done: false },\n  { id: uuid(), boardId: _boards[2].id, title: '버그 수정하기', done: false },\n]\n\nconst createItems = () => {\n  const { subscribe, reset, update: _update, set } = items\n  // ...생략...\n  return { subscribe, reset, set, add, remove, update }\n}\n```\n\n`Board`와 `Item`의 `id`를 이용해서 비교할 때, 문자와 숫자가 섞이면 비교하기 번거로우니 모두 문자로 수정하겠습니다. 그리고 `items`에 `set`함수를 넣어줘서 순서가 변경되면 적용되는 부분에 사용하도록 하겠습니다.\n\n다음은 `Item`컴포넌트를 수정해줍니다.\n\n```html\n<!-- Item.svelte -->\n<div\n  id={item.id}\n  class=\"item card p-1 mb-2 shadow-sm\"\n  class:shadow={hovering}\n  on:mouseenter={() => hovering = true}\n  on:mouseleave={() => hovering = false}\n>\n  <span class=\"drag-handle\">=</span>\n  {#if isEditable}\n  <input bind:value={item.title} />\n  {:else}\n  <span class:item-done={item.done} on:click={handleToggleDone}>\n    {item.title}\n  </span>\n  {/if}\n  <div class=\"item-action\">\n    <button class=\"item-btn\" on:click={handleToggleEditable}>E</button>\n    <button class=\"item-btn\" on:click={handleRemoveItem}>-</button>\n  </div>\n</div>\n```\n\n`Item`의 가장 상위 `div` 태그에 `id`속성을 넣어주었고, 드래그를 위한 핸들 아이콘을 하나 만들어 주었습니다.\n\n이제 순서가 변경될 수 있도록 `Sortable`에 옵션과 이벤트를 등록합니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  const handleSortItem = e => {\n    const target = $items.find(item => item.id === e.item.id)\n    const allItems = $items.filter(item => item.id !== e.item.id)\n    const _items = allItems.filter(item => item.boardId === e.to.id)\n    target.boardId = e.to.id\n    _items.splice(e.newIndex, 0, target)\n\n    const newItems = allItems\n      .filter(item => item.boardId !== e.to.id)\n      .concat(_items)\n    items.set(newItems)\n  }\n\n  let list = null\n  onMount(() => {\n    if (list) {\n      new Sortable(list, {\n        group: 'board',\n        handle: '.drag-handle',\n        animation: 300,\n        onEnd: handleSortItem,\n      })\n    }\n  })\n</script>\n```\n\n`onMount`함수에서 `Sortable` 생성자에 옵션을 추가해줍니다.\n\n- `group`옵션은 다른 `Board`의 리스트로 드래그하여 움직일 수 있게 해줍니다.\n- `handle`옵션은 `Item`전체를 클릭하여 드래그하지 않고, `handle`에 주입된 클래스이름을 가진 `Element`를 클릭하여 드래그할 수 있게 해줍니다.\n- `animation`옵션은 드래그로 `Item`의 순서가 변경될 때, 약간의 애니매이션을 사용합니다.\n- `onEnd`옵션은 드래그가 끝났을 때, 이벤트 핸들러로 콜백 함수를 호출합니다. 실제 `Store`의 데이터를 변경하기 위해 사용됩니다.\n\n`onEnd`옵션의 이벤트 핸들러로 위에서 선언한 `handleSortItem`함수를 호출합니다. 해당 함수에서는 실제 데이터의 순서가 변경되도록 구현합니다.\n\n이제 브라우저로 가서 확인해보겠습니다.\n\n![svelte drag item](/svelte/svelte-change-list-order/img/svelte_drag_item.gif)\n\n잘 동작하는지 확인하고 싶으면, 순서 변경 후 `items`를 콘솔로 출력해보시면 됩니다.\n\n---\n\n### 마무리\n\n여기까지 **Svelte로 만드는 Todo-App**을 만들어 보았습니다. **Svelte**를 공부하기 위해서 간단히 튜토리얼이나 공식문서를 훑어보았고, 어떻게 동작하는지 실습하는 형식으로 공부하기 위해 이 시리즈의 포스트를 작성하며 공부해 보았습니다.\n\n이제 기초적인 부분을 시작했고, 전반적으로 `Svelte`로 만든 앱이 어떻게 동작하는지 조금 알았으니, 공식 문서를 꼼꼼히 읽어보며 공부하면 더 도움이 될 것이고, 이해하기도 쉬울 것입니다.\n\n*전체 프로젝트 코드는 [Github](https://github.com/hoontae24/hello-svelte)에서 보실 수 있습니다.*\n","html":"<p><img src=\"/svelte/svelte-change-list-order/img/svelte_2.png\" alt=\"svelte\"></p>\n<p>이번 포스트에서는 <code>Item</code>의 순서를 변경할 수 있도록 구현하겠습니다.</p>\n<h3 id=\"1-item-순서-변경-구현하기\">1. Item 순서 변경 구현하기</h3>\n<p><code>Item</code>의 순서를 변경하여서 Todo-App을 사용하기 좋게 만들어 보겠습니다. 순서를 변경하는 UI/UX는 심플하게 드래그해서 변경할 수 있게 만들 것입니다.</p>\n<p><code>event</code>를 이용하여 구현할 수도 있겠지만, 해본 적도 없고 하니 이미 만들어진 라이브러리를 이용하여 적용해보겠습니다.</p>\n<h4 id=\"11-sortablejs-라이브러리-적용하기\">1.1 Sortablejs 라이브러리 적용하기</h4>\n<p>정렬을 구현하는 여러 라이브러리 중 <a href=\"https://github.com/SortableJS/Sortable\">Sortablejs</a>를 이용하겠습니다.</p>\n<p><code>npm</code>을 이용해서 설치하겠습니다.</p>\n<blockquote>\n<p>$ npm install sortablejs</p>\n</blockquote>\n<p>이제 각 <code>Board</code>의 리스트에 적용해 보겠습니다. <code>Item</code>들을 감싸는 <code>div</code>를 만들어줍니다. 또 <code>list</code>라는 변수를 선언해주고 만들어 준 <code>div</code>에 바인딩 시켜주겠습니다.</p>\n<p><code>svelte</code>로 부터 <code>onMount</code>함수를 <code>import</code>하고, 그 안에 다음과 같이 구현해주세요. <code>list</code>변수에 <code>div</code> Element가 바인딩 되면 <code>Sortable</code> 라이브러리를 적용시키도록 합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  import { onMount } from &#39;svelte&#39;\n  import Sortable from &#39;sortablejs&#39;\n  \n  let list = null\n  onMount(() =&gt; {\n    if(list) {\n      new Sortable(list)\n    }\n  })\n&lt;/script&gt;\n&lt;div id={board.id} class=&quot;item-list&quot; bind:this={list}&gt;\n{#each _items as item (item.id)}\n  &lt;Item\n    {item}\n    on:update={handleUpdateItem}\n    on:remove={handleRemoveItem}\n  /&gt;\n{/each}\n&lt;/div&gt;\n</code></pre>\n<p>이제 브라우저로 가서 잘 적용되었는지 확인해 봅니다. <code>Item</code>을 드래그해서 이동할 수 있게 되었고, 순서도 변경이 됩니다.</p>\n<p>하지만 DOM Element만 움직이는 것 일뿐, 아직 실제 <code>Store</code>에 있는 데이터의 순서가 변경되는 것은 아닙니다.</p>\n<h4 id=\"12-sortablejs를-이용하여-순서-변경-구현하기\">1.2 Sortablejs를 이용하여 순서 변경 구현하기</h4>\n<p><code>Sortablejs</code>를 적용하여서 <code>DOM Element</code>를 드래그로 움직일 수 있게 했습니다. 드래그로 순서가 변경될 때, <code>Store</code>에 있는 실제 데이터가 변경되도록, 이벤트 핸들러를 연결시켜주면 됩니다.</p>\n<p>먼저 그 전에 <code>Store</code>에 있는 데이터에서 <code>Item</code>의 <code>id</code> 값을 약간 수정해주고, <code>Item</code> 컴포넌트에서 드래그 핸들을 만들어주도록 하겠습니다.</p>\n<pre><code class=\"language-js\">// stores/index.js\nconst _boards = [\n  { id: uuid(), title: &#39;Planning&#39; },\n  { id: uuid(), title: &#39;In Progress&#39; },\n  { id: uuid(), title: &#39;All Done&#39; },\n]\n\nconst _items = [\n  { id: uuid(), boardId: _boards[0].id, title: &#39;자료 조사하기&#39;, done: false },\n  { id: uuid(), boardId: _boards[0].id, title: &#39;교양책 읽기&#39;, done: false },\n  { id: uuid(), boardId: _boards[1].id, title: &#39;분리수거하기&#39;, done: false },\n  { id: uuid(), boardId: _boards[1].id, title: &#39;가계부 정리하기&#39;, done: false },\n  { id: uuid(), boardId: _boards[2].id, title: &#39;버그 수정하기&#39;, done: false },\n]\n\nconst createItems = () =&gt; {\n  const { subscribe, reset, update: _update, set } = items\n  // ...생략...\n  return { subscribe, reset, set, add, remove, update }\n}\n</code></pre>\n<p><code>Board</code>와 <code>Item</code>의 <code>id</code>를 이용해서 비교할 때, 문자와 숫자가 섞이면 비교하기 번거로우니 모두 문자로 수정하겠습니다. 그리고 <code>items</code>에 <code>set</code>함수를 넣어줘서 순서가 변경되면 적용되는 부분에 사용하도록 하겠습니다.</p>\n<p>다음은 <code>Item</code>컴포넌트를 수정해줍니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;div\n  id={item.id}\n  class=&quot;item card p-1 mb-2 shadow-sm&quot;\n  class:shadow={hovering}\n  on:mouseenter={() =&gt; hovering = true}\n  on:mouseleave={() =&gt; hovering = false}\n&gt;\n  &lt;span class=&quot;drag-handle&quot;&gt;=&lt;/span&gt;\n  {#if isEditable}\n  &lt;input bind:value={item.title} /&gt;\n  {:else}\n  &lt;span class:item-done={item.done} on:click={handleToggleDone}&gt;\n    {item.title}\n  &lt;/span&gt;\n  {/if}\n  &lt;div class=&quot;item-action&quot;&gt;\n    &lt;button class=&quot;item-btn&quot; on:click={handleToggleEditable}&gt;E&lt;/button&gt;\n    &lt;button class=&quot;item-btn&quot; on:click={handleRemoveItem}&gt;-&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p><code>Item</code>의 가장 상위 <code>div</code> 태그에 <code>id</code>속성을 넣어주었고, 드래그를 위한 핸들 아이콘을 하나 만들어 주었습니다.</p>\n<p>이제 순서가 변경될 수 있도록 <code>Sortable</code>에 옵션과 이벤트를 등록합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  const handleSortItem = e =&gt; {\n    const target = $items.find(item =&gt; item.id === e.item.id)\n    const allItems = $items.filter(item =&gt; item.id !== e.item.id)\n    const _items = allItems.filter(item =&gt; item.boardId === e.to.id)\n    target.boardId = e.to.id\n    _items.splice(e.newIndex, 0, target)\n\n    const newItems = allItems\n      .filter(item =&gt; item.boardId !== e.to.id)\n      .concat(_items)\n    items.set(newItems)\n  }\n\n  let list = null\n  onMount(() =&gt; {\n    if (list) {\n      new Sortable(list, {\n        group: &#39;board&#39;,\n        handle: &#39;.drag-handle&#39;,\n        animation: 300,\n        onEnd: handleSortItem,\n      })\n    }\n  })\n&lt;/script&gt;\n</code></pre>\n<p><code>onMount</code>함수에서 <code>Sortable</code> 생성자에 옵션을 추가해줍니다.</p>\n<ul>\n<li><code>group</code>옵션은 다른 <code>Board</code>의 리스트로 드래그하여 움직일 수 있게 해줍니다.</li>\n<li><code>handle</code>옵션은 <code>Item</code>전체를 클릭하여 드래그하지 않고, <code>handle</code>에 주입된 클래스이름을 가진 <code>Element</code>를 클릭하여 드래그할 수 있게 해줍니다.</li>\n<li><code>animation</code>옵션은 드래그로 <code>Item</code>의 순서가 변경될 때, 약간의 애니매이션을 사용합니다.</li>\n<li><code>onEnd</code>옵션은 드래그가 끝났을 때, 이벤트 핸들러로 콜백 함수를 호출합니다. 실제 <code>Store</code>의 데이터를 변경하기 위해 사용됩니다.</li>\n</ul>\n<p><code>onEnd</code>옵션의 이벤트 핸들러로 위에서 선언한 <code>handleSortItem</code>함수를 호출합니다. 해당 함수에서는 실제 데이터의 순서가 변경되도록 구현합니다.</p>\n<p>이제 브라우저로 가서 확인해보겠습니다.</p>\n<p><img src=\"/svelte/svelte-change-list-order/img/svelte_drag_item.gif\" alt=\"svelte drag item\"></p>\n<p>잘 동작하는지 확인하고 싶으면, 순서 변경 후 <code>items</code>를 콘솔로 출력해보시면 됩니다.</p>\n<hr>\n<h3 id=\"마무리\">마무리</h3>\n<p>여기까지 <strong>Svelte로 만드는 Todo-App</strong>을 만들어 보았습니다. <strong>Svelte</strong>를 공부하기 위해서 간단히 튜토리얼이나 공식문서를 훑어보았고, 어떻게 동작하는지 실습하는 형식으로 공부하기 위해 이 시리즈의 포스트를 작성하며 공부해 보았습니다.</p>\n<p>이제 기초적인 부분을 시작했고, 전반적으로 <code>Svelte</code>로 만든 앱이 어떻게 동작하는지 조금 알았으니, 공식 문서를 꼼꼼히 읽어보며 공부하면 더 도움이 될 것이고, 이해하기도 쉬울 것입니다.</p>\n<p><em>전체 프로젝트 코드는 <a href=\"https://github.com/hoontae24/hello-svelte\">Github</a>에서 보실 수 있습니다.</em></p>\n","excerpt":" 이번 포스트에서는 Item의 순서를 변경할 수 있도록 구현하겠습니다. 1. Item 순서 변경 구현하기 Item의 순서를 변경하여서 Todo-App을 사용하기 좋게 만들어 보겠습니다. 순서를 변경하는 UI/UX는 심플하게 드래그해서 변경할 수 있게 만들 것입니다. event를 이용하여 구현할 수도 있겠지만, 해본 적도 없고 하니 이미 만들어진 라이브러리를 ","thumbnail":"/svelte/svelte-change-list-order/img/svelte_2.png","thumbnailUrl":"https://hoontae24.github.io/svelte/svelte-change-list-order/img/svelte_2.png"},{"href":"4","round":4,"paths":["svelte","svelte-store-and-crud"],"slug":"svelte-store-and-crud","title":"Svelte로 만드는 TODO-App (2), 데이터 Store 구현하기 / 간단한 CRUD 구현하기","description":"","date":"2019-11-22","category":"svelte","tags":["javascript","frontend","svelte"],"seriesId":2,"markdown":"\n![svelte](/svelte/svelte-store-and-crud/img/svelte_2.png)\n\n지난 시간에 이어서 `boards`와 `items` 데이터를 `Store`를 만들어서 관리하고, `CRUD`를 구현하겠습니다.\n\n### 1. Store 구현하기\n\n`Svelte`는 이미 `Store` 기능을 내장하고 있습니다. `svelte/store`를 `import`하면 그 기능을 사용할 수 있습니다.\n\n먼저 `Store`를 구현할 파일을 만들도록 하겠습니다. `/src`폴더 아래에 `stores`폴더를 만들고, `index.js`파일을 생성합니다.\n\n만약 `Store`로 사용할 데이터가 많다면 `/stores`폴더 안에 여러 파일을 만들어 구현하면 관리가 편하겠지만, 현재 프로젝트에서는 `boards`와 `items` 두 개의 데이터만 관리하면 되니, `index.js`파일 안에 함께 구현하도록 하겠습니다.\n\n`Store`에 대한 기본 지식은 [svelte/store 공식 API 문서](https://svelte.dev/docs#svelte_store)를 참조해주세요.\n\n#### 1.1 boards 데이터 Store로 구현하기\n\n이제 `/src/stores/index.js`파일을 다음과 같이 작성합니다.\n\n```js\n// src/stores/index.js\nimport { writable } from 'svelte/store'\nimport uuid from 'uuid/v4'\n\nconst _boards = [\n  { id: 1, title: 'Planning' },\n  { id: 2, title: 'In Progress' },\n  { id: 3, title: 'All Done' },\n]\n\nconst createBoards = () => {\n  const boards = writable(_boards)\n  const { subscribe, reset, update: _update } = boards\n\n  const add = () => {\n    _update(boards => boards.concat({ id: uuid(), title: '' }))\n  }\n\n  const remove = board => {\n    if (!board) return\n    _update(boards => boards.filter(_board => _board.id !== board.id))\n  }\n\n  const update = board => {\n    if (!board) return\n    _update(boards =>\n      boards.map(_board => (_board.id === board.id ? board : _board)),\n    )\n  }\n\n  return { subscribe, reset, add, remove, update }\n}\n\nexport const boards = createBoards()\n```\n\n`Store 모듈`에서 불러온 `writable`함수의 파라미터로 초기화 할 `boards`데이터를 넣어줍니다.\n\n생성된 `Store`객체 `boards`에서 `update`메소드를 이용해 `add`, `remove`, `update` 함수를 구현합니다. (`update`라는 이름의 함수를 따로 구현하기 위해서 원래의 `update`메소드를 `_update`로 명명하였음.)\n\n`createBoards`함수가 리턴하는 객체의 `add`, `remove`, `update`함수는 데이터를 다루는 데에 사용하기 위해 구현하였고, `subscribe`, `reset`함수는 컴포넌트 내에서 `$boards`로 접근하기 위해서 함께 넘겨줍니다.\n\n`add`함수에서 `board`를 생성하려고 할 때 id가 필요한데, 중복되지 않는 값이 필요하므로 `uuid`를 사용하도록 하겠습니다. 상단에서 `uuid`를 import 하고, 콘솔로 가서 모듈을 설치하겠습니다.\n\n> \\$ npm install uuid\n\n`package.json`파일을 열어보면, 다음과 같이 모듈이 의존성에 추가된 것을 볼 수 있습니다.\n\n```json\n// package.json\n\"dependencies\": {\n    \"sirv-cli\": \"^0.4.4\",\n    \"uuid\": \"^3.3.3\"\n  },\n```\n\n다음은 `App.svelte`파일로 가서 만들어둔 `boards`를 불러오겠습니다.\n\n`./stores`에서 `boards`를 import하고, 기존에 사용하던 boards배열 데이터는 삭제하겠습니다.\n\n```html\n<!-- App.svelte -->\n<script>\n  import { boards } from './stores'\n\n  // 기존의 데이터는 삭제\n  // const boards = [\n  //   { id: 1, title: 'Planning' },\n  //   { id: 2, title: 'In Progress' },\n  //   { id: 3, title: 'All Done' },\n  // ]\n\n  // (... 생략 ...)\n</script>\n\n<!-- 기존의 boards를 $boards로 바꿔줍니다. -->\n<!-- {#each boards as board (board.id)} -->\n{#each $boards as board (board.id)}\n<div class=\"item\">\n  <Board board={board} items={items.filter(item => item.boardId === board.id)}\n  />\n</div>\n{/each}\n\n<!-- (... 생략 ...) -->\n```\n\n앞서 말했던 것 처럼, `boards`자체는 `Store`객체이기 때문에, 해당하는 데이터에 접근하려면 `$`를 앞에 붙여야 합니다.\n\n이제 페이지로 접속해서 여전히 잘 동작하는지 확인해보세요. `Store`가 잘 생성되었는지 확인하기 위해서 `boards`의 기본 데이터를 변경해보고, 반영되는지 확인하면 됩니다.\n\n#### 1.2 items 데이터 Store로 구현하기\n\n다음은 `items`데이터를 `Store`로 구현하겠습니다. `boards`에서 했던 것과 거의 동일합니다.\n\n`stores/index.js`파일로 가서 아래의 내용을 추가하겠습니다.\n\n```js\n// stores/index.js\nconst _items = [\n  { id: 1, boardId: 1, title: '자료 조사하기', done: false },\n  { id: 2, boardId: 1, title: '교양책 읽기', done: false },\n  { id: 3, boardId: 2, title: '분리수거하기', done: false },\n  { id: 4, boardId: 2, title: '가계부 정리하기', done: false },\n  { id: 5, boardId: 3, title: '버그 수정하기', done: false },\n]\n\nconst createItems = () => {\n  const items = writable(_items)\n  const { subscribe, reset, update: _update } = items\n\n  const add = boardId => {\n    if (!boardId) return\n    _update(items =>\n      items.concat({ id: uuid(), boardId, title: '', done: false }),\n    )\n  }\n\n  const remove = item => {\n    if (!item) return\n    _update(items => items.filter(_item => _item.id !== item.id))\n  }\n\n  const update = item => {\n    if (!item) return\n    _update(items => items.map(_item => (_item.id === item.id ? item : _item)))\n  }\n\n  return { subscribe, reset, add, remove, update }\n}\n\nexport const items = createItems()\n```\n\n`boards`와 다른 부분은 `add`함수에서 `item`을 생성할 때, 어느 `board`에 소속해야할 지 알기 위해 `boardId`를 파라미터로 받는 부분입니다. 나머지는 동일합니다.\n\n이제 `App.svelte`파일로 가서 `items`를 삭제합니다.\n\n```html\n<!-- App.svelte -->\n<script>\n  // 기존 데이터 삭제\n  // const items = [\n  //   { id: 1, boardId: 1, title: '자료 조사하기', done: false},\n  //   { id: 2, boardId: 1, title: '교양책 읽기', done: false},\n  //   { id: 3, boardId: 2, title: '분리수거하기', done: false},\n  //   { id: 4, boardId: 2, title: '가계부 정리하기', done: false},\n  //   { id: 5, boardId: 3, title: '버그 수정하기', done: false},\n  // ]\n</script>\n\n<!-- Board에 주입해주었던 items를 삭제합니다 -->\n<Board board={board} />\n```\n\n`Board.svelte`로 가서 `Store`의 `items`를 `import`하고, `$items`로 접근하여 해당 `board`에 연결된 `items`를 불러오게 `filter`를 걸어줍니다. (원래 `Board.svelte`에 있던 부분을 옮겼습니다.)\n\n`$`를 이용해 `_items`에 반응성 변수를 만들고 해당 `board`의 `items`를 접근합니다.\n\n기존에 `items`로 접근했던 부분을 `_items`로 변경해주세요.\n\n```html\n<!-- Board.svelte -->\n<script>\n  import { items } from '../stores'\n\n  // 기존에 props로 주입되었던 items는 삭제합니다.\n  // export items = []\n  $: _items = $items.filter(item => item.boardId === board.id)\n</script>\n<!-- \"items\" -> \"_items\" -->\n{#each _items as item (item.id)}\n<Item {item} />\n{/each}\n```\n\n페이지로 가서 잘 동작하는지 확인해보세요.\n\n**Todo-app**에서 사용할 `boards`와 `items`데이터를 `Store`로 구현해 보았습니다. 페이지는 변한 것 없이 그대로지만, 데이터를 관리하는 부분은 수월해졌습니다. 만약 `Store`를 이용하지 않으려면, 자식 컴포넌트로 [이벤트](https://svelte.dev/docs#createEventDispatcher)를 전달해서 데이터를 변경하거나, [bind된 속성](https://svelte.dev/docs#bind_component_property)을 이용하면 됩니다.\n\n---\n\n### 2. Item CRUD 구현하기\n\n> **CRUD**는 _대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다._ (참조. 위키백과)\n\n**Item**의 동작은 **추가(C)**, **읽기(R)**, **변경(U)**, **삭제(D)** 정도가 있습니다. **읽기**는 따로 구현할 것 없이 지금처럼 보이기만 하면 됩니다.\n\n**추가**와 **삭제**는 버튼을 통해 단순하게 동작하도록 먼저 만들고, **변경**은 **Item**의 제목을 변경하고, **done**속성을 이용하여 완료 체크를 할 수 있도록 만들어 보겠습니다.\n\n#### 2.1 Item 추가 기능 구현하기\n\n`Item`을 추가하는 방법은 여러가지로 구현할 수 있겠지만, 각 `Board`에 있는 `추가`버튼을 클릭하면 해당 `Board`에 새로운 `Item`이 추가되도록 구현해 보겠습니다.\n\n먼저, `Board`의 우측 하단에 버튼을 하나 만들겠습니다.\n\n```html\n<!-- Board.svelte -->\n<!-- card-body안쪽의 마지막 부분에 버튼을 추가합니다. -->\n<div class=\"card-action\">\n  <button class=\"add-item\">+</button>\n</div>\n\n<style>\n  /* 간단한 스타일을 지정합니다. */\n  .add-item {\n    float: right;\n    width: 35px;\n    height: 35px;\n    padding: 0;\n  }\n</style>\n```\n\n버튼을 클릭하면 새로운 `Item`이 추가되도록 하겠습니다. `Board.svelte` 파일에 `handleAddItem`함수를 만들고 방금 생성한 버튼에 연결시켜줍니다. `handleAddItem`함수는 `items.add`를 호출하도록 구현하겠습니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  import Item from './Item.svelte'\n  import { items } from '../stores'\n\n  export let board = null\n  $: _items = $items.filter(item => item.boardId === board.id)\n\n  // handleAddItem 함수 구현\n  const handleAddItem = () => items.add(board.id)\n</script>\n\n<!-- ...생략... -->\n\n<!-- button의 onclick 이벤트에 handleAddItem함수를 연결합니다. -->\n<button class=\"add-item\" on:click={handleAddItem}>+</button>\n```\n\n이제 버튼을 클릭해 보겠습니다.\n\n![add item](/svelte/svelte-store-and-crud/img/svelte_addItem_1.png)\n\n`Item`을 추가하는 부분에 `title`을 지정해주지 않아서 제대로 나오지 않습니다.\n\n`stores/index.js`로 가서 해당 부분을 고쳐주겠습니다.\n\n```js\n// stores/index.js\nconst add = boardId => {\n  if (!boardId) return\n  _update(items =>\n    items.concat({ id: uuid(), boardId, title: '새 항목', done: false }),\n  )\n}\n```\n\n변경 후 다시 버튼을 클릭해보면 **\"새 항목\"** 이라는 제목으로 잘 추가됩니다.\n\n#### 2.2 Item 삭제 기능 구현하기\n\n먼저 `Item.svelte`컴포넌트에 삭제 버튼을 만들겠습니다.\n\n```html\n<!-- Item.svelte -->\n<div\n  class=\"item card p-1 mb-2 shadow-sm\"\n  class:shadow={hovering}\n  on:mouseenter={() => hovering = true}\n  on:mouseleave={() => hovering = false}\n>\n  <span>\n    {item.title}\n  </span>\n  <div class=\"item-action\">\n    <button class=\"item-btn\">-</button>\n  </div>\n</div>\n\n<style>\n  .item {\n    transition: box-shadow .25s ease-in;\n    flex-direction: row;\n    justify-content: space-between\n  }\n\n  .item-btn {\n    width: 25px;\n    height: 25px;\n    padding: 0;\n  }\n</style>\n```\n\n아직 버튼은 아무 동작이 없습니다. 이제 `handleRemoveItem`함수를 만들고 이벤트로 전달해주겠습니다.\n\n```html\n<!-- Item.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte'\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n\n  const handleRemoveItem = () => dispatch('remove', item)\n</script>\n\n<!-- ...생략... -->\n<button class=\"item-btn\" on:click={handleRemoveItem}>-</button>\n```\n\n`\"remove\"`로 전달한 이벤트를 리스너를 `Board.svelte`에 연결해주겠습니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  import Item from './Item.svelte'\n  import { items } from '../stores'\n\n  export let board = null\n  $: _items = $items.filter(item => item.boardId === board.id)\n\n  const handleAddItem = () => items.add(board.id)\n  // e 객체의 detail에 dispatch 함수의 두번째 인자가 담겨 전달됩니다.\n  const handleRemoveItem = e => items.remove(e.detail)\n</script>\n\n<!-- ...생략... -->\n{#each _items as item (item.id)}\n<!-- 하위 컴포넌트에서 remove로 넘겨준 이벤트를 on:remove 으로 받아줍니다. -->\n<Item {item} on:remove={handleRemoveItem} />\n{/each}\n```\n\n잘 동작하네요.\n\n![remove item](/svelte/svelte-store-and-crud/img/svelte_remove_item_1.gif)\n\n#### 2.3 Item 편집 기능 구현하기\n\n`Item`의 편집은 제목을 수정하고, 완료 체크를 할 수 있도록 구현해보겠습니다.\n\n수정 버튼을 만들어서, 버튼을 클릭하면 제목이 `input`으로 변하는 동작을 구현하고, 제목을 수정하도록 만들어 보겠습니다.\n\n삭제 버튼 옆에 수정 버튼을 만들어 줍니다. 그리고 수정버튼을 클릭하면 변하는 상태 변수 `isEditable`과 핸들러 `handleToggleEditable`을 만들어 줍니다. 수정 버튼에는 핸들러를 연결해 줄 것입니다.\n\n그리고 `isEditable`의 상태에 따라 `Item`의 제목이 `input`이 되도록 구현해 줍니다.\n\n`Item.svelte` 파일을 다음과 같이 수정합니다.\n\n```html\n<!-- Item.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte'\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n  let isEditable = false\n\n  const handleRemoveItem = () => dispatch('remove', item)\n  const handleToggleEditable = () => (isEditable = !isEditable)\n</script>\n\n{#if item}\n<div\n  class=\"item card p-1 mb-2 shadow-sm\"\n  class:shadow={hovering}\n  on:mouseenter={() => hovering = true}\n  on:mouseleave={() => hovering = false}\n>\n  {#if isEditable}\n  <input bind:value={item.title} />\n  {:else}\n  <span>\n    {item.title}\n  </span>\n  {/if}\n  <div class=\"item-action\">\n    <button class=\"item-btn\" on:click={handleToggleEditable}>E</button>\n    <button class=\"item-btn\" on:click={handleRemoveItem}>-</button>\n  </div>\n</div>\n{/if}\n```\n\n제목을 수정할 수 있도록 UI는 구성했으니, 수정된 제목이 `Store`에 반영되도록 해줍니다.\n\n`isEditable`이 `true`에서 `false`로 변할 때, 즉 수정을 완료하고 `submit`할 때 값을 저장하도록 구현해 주겠습니다.\n\n`handleUpdateItem` 함수를 만들어주고, `handleToggleEditable` 함수에서 `isEditable`이 변할 때, 실행되도록 구현해 보겠습니다.\n\n```html\n<!-- Item.svelte -->\n<script>\n  import { createEventDispatcher } from 'svelte'\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n  let isEditable = false\n\n  const handleRemoveItem = () => dispatch('remove', item)\n  const handleUpdateItem = () => dispatch('update', item)\n  const handleToggleEditable = () => {\n    isEditable = !isEditable\n    if (!isEditable) handleUpdateItem()\n  }\n</script>\n```\n\n`handleUpdateItem` 함수에서는 상위 컴포넌트로 이벤트를 발생시키게 하였습니다. `Board.svelte` 파일로 가서 해당 이벤트를 연결시켜 줍니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  const handleUpdateItem = e => items.update(e.detail)\n</script>\n\n{#each _items as item (item.id)}\n<Item {item} on:update={handleUpdateItem} on:remove={handleRemoveItem} />\n{/each}\n```\n\n`Board.svelte` 컴포넌트에서 `on:update`로 해당 이벤트의 콜백을 연결해주고, `store`에 구현해둔 `update`를 호출합니다.\n\n![remove item](/svelte/svelte-store-and-crud/img/svelte_update_item.gif)\n\n실제로 좋은 UX를 제공하려면, `Enter`키를 입력하거나 `input`에서 `blur`처리가 될 때, 상태를 변경시켜줘야 하겠지만, 그 작업은 생략하도록 하겠습니다.\n\n이제 `Item`의 완료처리를 구현해보겠습니다. 완료처리는 간단하게 제목을 클릭하면 제목에 실선이 그어지고, 색이 변하도록 만들겠습니다.\n\n`Item.svelte`파일에서 다음과 같이 수정합니다.\n\n```html\n<!-- Item.svelte -->\n<script>\n  const handleToggleDone = () => {\n    item.done = !item.done\n    handleUpdateItem()\n  }\n</script>\n\n<span class:item-done={item.done} on:click={handleToggleDone}>\n  {item.title}\n</span>\n\n<style>\n  .item-done {\n    text-decoration: line-through;\n    color: gray;\n  }\n</style>\n```\n\n`item`의 제목이 표시되는 엘리먼트를 클릭했을 때, `item.done`의 값이 변경되도록 해주고, `store`에 반영시켜줍니다. `item.done`의 값에 따라 `item-done`클래스를 가지도록 해주고, css로 실선과 색이 변하도록 해줍니다.\n\n---\n\n이렇게 **Item**의 간단한 CRUD를 구현해 보았습니다. **svelte**로 기본적인 동작들을 만들면서 알아야 할 것들을 자연스럽게 사용해 볼 수 있었습니다.\n\n다음 시간에는 각 `Item`들의 순서를 변경하고, 다른 `Board`로 이동시키는 동작을 구현해보겠습니다.\n\n*전체 프로젝트 코드는 [Github](https://github.com/hoontae24/hello-svelte)에서 보실 수 있습니다.*\n","html":"<p><img src=\"/svelte/svelte-store-and-crud/img/svelte_2.png\" alt=\"svelte\"></p>\n<p>지난 시간에 이어서 <code>boards</code>와 <code>items</code> 데이터를 <code>Store</code>를 만들어서 관리하고, <code>CRUD</code>를 구현하겠습니다.</p>\n<h3 id=\"1-store-구현하기\">1. Store 구현하기</h3>\n<p><code>Svelte</code>는 이미 <code>Store</code> 기능을 내장하고 있습니다. <code>svelte/store</code>를 <code>import</code>하면 그 기능을 사용할 수 있습니다.</p>\n<p>먼저 <code>Store</code>를 구현할 파일을 만들도록 하겠습니다. <code>/src</code>폴더 아래에 <code>stores</code>폴더를 만들고, <code>index.js</code>파일을 생성합니다.</p>\n<p>만약 <code>Store</code>로 사용할 데이터가 많다면 <code>/stores</code>폴더 안에 여러 파일을 만들어 구현하면 관리가 편하겠지만, 현재 프로젝트에서는 <code>boards</code>와 <code>items</code> 두 개의 데이터만 관리하면 되니, <code>index.js</code>파일 안에 함께 구현하도록 하겠습니다.</p>\n<p><code>Store</code>에 대한 기본 지식은 <a href=\"https://svelte.dev/docs#svelte_store\">svelte/store 공식 API 문서</a>를 참조해주세요.</p>\n<h4 id=\"11-boards-데이터-store로-구현하기\">1.1 boards 데이터 Store로 구현하기</h4>\n<p>이제 <code>/src/stores/index.js</code>파일을 다음과 같이 작성합니다.</p>\n<pre><code class=\"language-js\">// src/stores/index.js\nimport { writable } from &#39;svelte/store&#39;\nimport uuid from &#39;uuid/v4&#39;\n\nconst _boards = [\n  { id: 1, title: &#39;Planning&#39; },\n  { id: 2, title: &#39;In Progress&#39; },\n  { id: 3, title: &#39;All Done&#39; },\n]\n\nconst createBoards = () =&gt; {\n  const boards = writable(_boards)\n  const { subscribe, reset, update: _update } = boards\n\n  const add = () =&gt; {\n    _update(boards =&gt; boards.concat({ id: uuid(), title: &#39;&#39; }))\n  }\n\n  const remove = board =&gt; {\n    if (!board) return\n    _update(boards =&gt; boards.filter(_board =&gt; _board.id !== board.id))\n  }\n\n  const update = board =&gt; {\n    if (!board) return\n    _update(boards =&gt;\n      boards.map(_board =&gt; (_board.id === board.id ? board : _board)),\n    )\n  }\n\n  return { subscribe, reset, add, remove, update }\n}\n\nexport const boards = createBoards()\n</code></pre>\n<p><code>Store 모듈</code>에서 불러온 <code>writable</code>함수의 파라미터로 초기화 할 <code>boards</code>데이터를 넣어줍니다.</p>\n<p>생성된 <code>Store</code>객체 <code>boards</code>에서 <code>update</code>메소드를 이용해 <code>add</code>, <code>remove</code>, <code>update</code> 함수를 구현합니다. (<code>update</code>라는 이름의 함수를 따로 구현하기 위해서 원래의 <code>update</code>메소드를 <code>_update</code>로 명명하였음.)</p>\n<p><code>createBoards</code>함수가 리턴하는 객체의 <code>add</code>, <code>remove</code>, <code>update</code>함수는 데이터를 다루는 데에 사용하기 위해 구현하였고, <code>subscribe</code>, <code>reset</code>함수는 컴포넌트 내에서 <code>$boards</code>로 접근하기 위해서 함께 넘겨줍니다.</p>\n<p><code>add</code>함수에서 <code>board</code>를 생성하려고 할 때 id가 필요한데, 중복되지 않는 값이 필요하므로 <code>uuid</code>를 사용하도록 하겠습니다. 상단에서 <code>uuid</code>를 import 하고, 콘솔로 가서 모듈을 설치하겠습니다.</p>\n<blockquote>\n<p>$ npm install uuid</p>\n</blockquote>\n<p><code>package.json</code>파일을 열어보면, 다음과 같이 모듈이 의존성에 추가된 것을 볼 수 있습니다.</p>\n<pre><code class=\"language-json\">// package.json\n&quot;dependencies&quot;: {\n    &quot;sirv-cli&quot;: &quot;^0.4.4&quot;,\n    &quot;uuid&quot;: &quot;^3.3.3&quot;\n  },\n</code></pre>\n<p>다음은 <code>App.svelte</code>파일로 가서 만들어둔 <code>boards</code>를 불러오겠습니다.</p>\n<p><code>./stores</code>에서 <code>boards</code>를 import하고, 기존에 사용하던 boards배열 데이터는 삭제하겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- App.svelte --&gt;\n&lt;script&gt;\n  import { boards } from &#39;./stores&#39;\n\n  // 기존의 데이터는 삭제\n  // const boards = [\n  //   { id: 1, title: &#39;Planning&#39; },\n  //   { id: 2, title: &#39;In Progress&#39; },\n  //   { id: 3, title: &#39;All Done&#39; },\n  // ]\n\n  // (... 생략 ...)\n&lt;/script&gt;\n\n&lt;!-- 기존의 boards를 $boards로 바꿔줍니다. --&gt;\n&lt;!-- {#each boards as board (board.id)} --&gt;\n{#each $boards as board (board.id)}\n&lt;div class=&quot;item&quot;&gt;\n  &lt;Board board={board} items={items.filter(item =&gt; item.boardId === board.id)}\n  /&gt;\n&lt;/div&gt;\n{/each}\n\n&lt;!-- (... 생략 ...) --&gt;\n</code></pre>\n<p>앞서 말했던 것 처럼, <code>boards</code>자체는 <code>Store</code>객체이기 때문에, 해당하는 데이터에 접근하려면 <code>$</code>를 앞에 붙여야 합니다.</p>\n<p>이제 페이지로 접속해서 여전히 잘 동작하는지 확인해보세요. <code>Store</code>가 잘 생성되었는지 확인하기 위해서 <code>boards</code>의 기본 데이터를 변경해보고, 반영되는지 확인하면 됩니다.</p>\n<h4 id=\"12-items-데이터-store로-구현하기\">1.2 items 데이터 Store로 구현하기</h4>\n<p>다음은 <code>items</code>데이터를 <code>Store</code>로 구현하겠습니다. <code>boards</code>에서 했던 것과 거의 동일합니다.</p>\n<p><code>stores/index.js</code>파일로 가서 아래의 내용을 추가하겠습니다.</p>\n<pre><code class=\"language-js\">// stores/index.js\nconst _items = [\n  { id: 1, boardId: 1, title: &#39;자료 조사하기&#39;, done: false },\n  { id: 2, boardId: 1, title: &#39;교양책 읽기&#39;, done: false },\n  { id: 3, boardId: 2, title: &#39;분리수거하기&#39;, done: false },\n  { id: 4, boardId: 2, title: &#39;가계부 정리하기&#39;, done: false },\n  { id: 5, boardId: 3, title: &#39;버그 수정하기&#39;, done: false },\n]\n\nconst createItems = () =&gt; {\n  const items = writable(_items)\n  const { subscribe, reset, update: _update } = items\n\n  const add = boardId =&gt; {\n    if (!boardId) return\n    _update(items =&gt;\n      items.concat({ id: uuid(), boardId, title: &#39;&#39;, done: false }),\n    )\n  }\n\n  const remove = item =&gt; {\n    if (!item) return\n    _update(items =&gt; items.filter(_item =&gt; _item.id !== item.id))\n  }\n\n  const update = item =&gt; {\n    if (!item) return\n    _update(items =&gt; items.map(_item =&gt; (_item.id === item.id ? item : _item)))\n  }\n\n  return { subscribe, reset, add, remove, update }\n}\n\nexport const items = createItems()\n</code></pre>\n<p><code>boards</code>와 다른 부분은 <code>add</code>함수에서 <code>item</code>을 생성할 때, 어느 <code>board</code>에 소속해야할 지 알기 위해 <code>boardId</code>를 파라미터로 받는 부분입니다. 나머지는 동일합니다.</p>\n<p>이제 <code>App.svelte</code>파일로 가서 <code>items</code>를 삭제합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- App.svelte --&gt;\n&lt;script&gt;\n  // 기존 데이터 삭제\n  // const items = [\n  //   { id: 1, boardId: 1, title: &#39;자료 조사하기&#39;, done: false},\n  //   { id: 2, boardId: 1, title: &#39;교양책 읽기&#39;, done: false},\n  //   { id: 3, boardId: 2, title: &#39;분리수거하기&#39;, done: false},\n  //   { id: 4, boardId: 2, title: &#39;가계부 정리하기&#39;, done: false},\n  //   { id: 5, boardId: 3, title: &#39;버그 수정하기&#39;, done: false},\n  // ]\n&lt;/script&gt;\n\n&lt;!-- Board에 주입해주었던 items를 삭제합니다 --&gt;\n&lt;Board board={board} /&gt;\n</code></pre>\n<p><code>Board.svelte</code>로 가서 <code>Store</code>의 <code>items</code>를 <code>import</code>하고, <code>$items</code>로 접근하여 해당 <code>board</code>에 연결된 <code>items</code>를 불러오게 <code>filter</code>를 걸어줍니다. (원래 <code>Board.svelte</code>에 있던 부분을 옮겼습니다.)</p>\n<p><code>$</code>를 이용해 <code>_items</code>에 반응성 변수를 만들고 해당 <code>board</code>의 <code>items</code>를 접근합니다.</p>\n<p>기존에 <code>items</code>로 접근했던 부분을 <code>_items</code>로 변경해주세요.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  import { items } from &#39;../stores&#39;\n\n  // 기존에 props로 주입되었던 items는 삭제합니다.\n  // export items = []\n  $: _items = $items.filter(item =&gt; item.boardId === board.id)\n&lt;/script&gt;\n&lt;!-- &quot;items&quot; -&gt; &quot;_items&quot; --&gt;\n{#each _items as item (item.id)}\n&lt;Item {item} /&gt;\n{/each}\n</code></pre>\n<p>페이지로 가서 잘 동작하는지 확인해보세요.</p>\n<p><strong>Todo-app</strong>에서 사용할 <code>boards</code>와 <code>items</code>데이터를 <code>Store</code>로 구현해 보았습니다. 페이지는 변한 것 없이 그대로지만, 데이터를 관리하는 부분은 수월해졌습니다. 만약 <code>Store</code>를 이용하지 않으려면, 자식 컴포넌트로 <a href=\"https://svelte.dev/docs#createEventDispatcher\">이벤트</a>를 전달해서 데이터를 변경하거나, <a href=\"https://svelte.dev/docs#bind_component_property\">bind된 속성</a>을 이용하면 됩니다.</p>\n<hr>\n<h3 id=\"2-item-crud-구현하기\">2. Item CRUD 구현하기</h3>\n<blockquote>\n<p><strong>CRUD</strong>는 <em>대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다.</em> (참조. 위키백과)</p>\n</blockquote>\n<p><strong>Item</strong>의 동작은 <strong>추가(C)</strong>, <strong>읽기(R)</strong>, <strong>변경(U)</strong>, <strong>삭제(D)</strong> 정도가 있습니다. <strong>읽기</strong>는 따로 구현할 것 없이 지금처럼 보이기만 하면 됩니다.</p>\n<p><strong>추가</strong>와 <strong>삭제</strong>는 버튼을 통해 단순하게 동작하도록 먼저 만들고, <strong>변경</strong>은 <strong>Item</strong>의 제목을 변경하고, <strong>done</strong>속성을 이용하여 완료 체크를 할 수 있도록 만들어 보겠습니다.</p>\n<h4 id=\"21-item-추가-기능-구현하기\">2.1 Item 추가 기능 구현하기</h4>\n<p><code>Item</code>을 추가하는 방법은 여러가지로 구현할 수 있겠지만, 각 <code>Board</code>에 있는 <code>추가</code>버튼을 클릭하면 해당 <code>Board</code>에 새로운 <code>Item</code>이 추가되도록 구현해 보겠습니다.</p>\n<p>먼저, <code>Board</code>의 우측 하단에 버튼을 하나 만들겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;!-- card-body안쪽의 마지막 부분에 버튼을 추가합니다. --&gt;\n&lt;div class=&quot;card-action&quot;&gt;\n  &lt;button class=&quot;add-item&quot;&gt;+&lt;/button&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n  /* 간단한 스타일을 지정합니다. */\n  .add-item {\n    float: right;\n    width: 35px;\n    height: 35px;\n    padding: 0;\n  }\n&lt;/style&gt;\n</code></pre>\n<p>버튼을 클릭하면 새로운 <code>Item</code>이 추가되도록 하겠습니다. <code>Board.svelte</code> 파일에 <code>handleAddItem</code>함수를 만들고 방금 생성한 버튼에 연결시켜줍니다. <code>handleAddItem</code>함수는 <code>items.add</code>를 호출하도록 구현하겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  import Item from &#39;./Item.svelte&#39;\n  import { items } from &#39;../stores&#39;\n\n  export let board = null\n  $: _items = $items.filter(item =&gt; item.boardId === board.id)\n\n  // handleAddItem 함수 구현\n  const handleAddItem = () =&gt; items.add(board.id)\n&lt;/script&gt;\n\n&lt;!-- ...생략... --&gt;\n\n&lt;!-- button의 onclick 이벤트에 handleAddItem함수를 연결합니다. --&gt;\n&lt;button class=&quot;add-item&quot; on:click={handleAddItem}&gt;+&lt;/button&gt;\n</code></pre>\n<p>이제 버튼을 클릭해 보겠습니다.</p>\n<p><img src=\"/svelte/svelte-store-and-crud/img/svelte_addItem_1.png\" alt=\"add item\"></p>\n<p><code>Item</code>을 추가하는 부분에 <code>title</code>을 지정해주지 않아서 제대로 나오지 않습니다.</p>\n<p><code>stores/index.js</code>로 가서 해당 부분을 고쳐주겠습니다.</p>\n<pre><code class=\"language-js\">// stores/index.js\nconst add = boardId =&gt; {\n  if (!boardId) return\n  _update(items =&gt;\n    items.concat({ id: uuid(), boardId, title: &#39;새 항목&#39;, done: false }),\n  )\n}\n</code></pre>\n<p>변경 후 다시 버튼을 클릭해보면 <strong>&quot;새 항목&quot;</strong> 이라는 제목으로 잘 추가됩니다.</p>\n<h4 id=\"22-item-삭제-기능-구현하기\">2.2 Item 삭제 기능 구현하기</h4>\n<p>먼저 <code>Item.svelte</code>컴포넌트에 삭제 버튼을 만들겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;div\n  class=&quot;item card p-1 mb-2 shadow-sm&quot;\n  class:shadow={hovering}\n  on:mouseenter={() =&gt; hovering = true}\n  on:mouseleave={() =&gt; hovering = false}\n&gt;\n  &lt;span&gt;\n    {item.title}\n  &lt;/span&gt;\n  &lt;div class=&quot;item-action&quot;&gt;\n    &lt;button class=&quot;item-btn&quot;&gt;-&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n  .item {\n    transition: box-shadow .25s ease-in;\n    flex-direction: row;\n    justify-content: space-between\n  }\n\n  .item-btn {\n    width: 25px;\n    height: 25px;\n    padding: 0;\n  }\n&lt;/style&gt;\n</code></pre>\n<p>아직 버튼은 아무 동작이 없습니다. 이제 <code>handleRemoveItem</code>함수를 만들고 이벤트로 전달해주겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;script&gt;\n  import { createEventDispatcher } from &#39;svelte&#39;\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n\n  const handleRemoveItem = () =&gt; dispatch(&#39;remove&#39;, item)\n&lt;/script&gt;\n\n&lt;!-- ...생략... --&gt;\n&lt;button class=&quot;item-btn&quot; on:click={handleRemoveItem}&gt;-&lt;/button&gt;\n</code></pre>\n<p><code>&quot;remove&quot;</code>로 전달한 이벤트를 리스너를 <code>Board.svelte</code>에 연결해주겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  import Item from &#39;./Item.svelte&#39;\n  import { items } from &#39;../stores&#39;\n\n  export let board = null\n  $: _items = $items.filter(item =&gt; item.boardId === board.id)\n\n  const handleAddItem = () =&gt; items.add(board.id)\n  // e 객체의 detail에 dispatch 함수의 두번째 인자가 담겨 전달됩니다.\n  const handleRemoveItem = e =&gt; items.remove(e.detail)\n&lt;/script&gt;\n\n&lt;!-- ...생략... --&gt;\n{#each _items as item (item.id)}\n&lt;!-- 하위 컴포넌트에서 remove로 넘겨준 이벤트를 on:remove 으로 받아줍니다. --&gt;\n&lt;Item {item} on:remove={handleRemoveItem} /&gt;\n{/each}\n</code></pre>\n<p>잘 동작하네요.</p>\n<p><img src=\"/svelte/svelte-store-and-crud/img/svelte_remove_item_1.gif\" alt=\"remove item\"></p>\n<h4 id=\"23-item-편집-기능-구현하기\">2.3 Item 편집 기능 구현하기</h4>\n<p><code>Item</code>의 편집은 제목을 수정하고, 완료 체크를 할 수 있도록 구현해보겠습니다.</p>\n<p>수정 버튼을 만들어서, 버튼을 클릭하면 제목이 <code>input</code>으로 변하는 동작을 구현하고, 제목을 수정하도록 만들어 보겠습니다.</p>\n<p>삭제 버튼 옆에 수정 버튼을 만들어 줍니다. 그리고 수정버튼을 클릭하면 변하는 상태 변수 <code>isEditable</code>과 핸들러 <code>handleToggleEditable</code>을 만들어 줍니다. 수정 버튼에는 핸들러를 연결해 줄 것입니다.</p>\n<p>그리고 <code>isEditable</code>의 상태에 따라 <code>Item</code>의 제목이 <code>input</code>이 되도록 구현해 줍니다.</p>\n<p><code>Item.svelte</code> 파일을 다음과 같이 수정합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;script&gt;\n  import { createEventDispatcher } from &#39;svelte&#39;\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n  let isEditable = false\n\n  const handleRemoveItem = () =&gt; dispatch(&#39;remove&#39;, item)\n  const handleToggleEditable = () =&gt; (isEditable = !isEditable)\n&lt;/script&gt;\n\n{#if item}\n&lt;div\n  class=&quot;item card p-1 mb-2 shadow-sm&quot;\n  class:shadow={hovering}\n  on:mouseenter={() =&gt; hovering = true}\n  on:mouseleave={() =&gt; hovering = false}\n&gt;\n  {#if isEditable}\n  &lt;input bind:value={item.title} /&gt;\n  {:else}\n  &lt;span&gt;\n    {item.title}\n  &lt;/span&gt;\n  {/if}\n  &lt;div class=&quot;item-action&quot;&gt;\n    &lt;button class=&quot;item-btn&quot; on:click={handleToggleEditable}&gt;E&lt;/button&gt;\n    &lt;button class=&quot;item-btn&quot; on:click={handleRemoveItem}&gt;-&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n{/if}\n</code></pre>\n<p>제목을 수정할 수 있도록 UI는 구성했으니, 수정된 제목이 <code>Store</code>에 반영되도록 해줍니다.</p>\n<p><code>isEditable</code>이 <code>true</code>에서 <code>false</code>로 변할 때, 즉 수정을 완료하고 <code>submit</code>할 때 값을 저장하도록 구현해 주겠습니다.</p>\n<p><code>handleUpdateItem</code> 함수를 만들어주고, <code>handleToggleEditable</code> 함수에서 <code>isEditable</code>이 변할 때, 실행되도록 구현해 보겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;script&gt;\n  import { createEventDispatcher } from &#39;svelte&#39;\n  const dispatch = createEventDispatcher()\n\n  export let item = null\n  let hovering = false\n  let isEditable = false\n\n  const handleRemoveItem = () =&gt; dispatch(&#39;remove&#39;, item)\n  const handleUpdateItem = () =&gt; dispatch(&#39;update&#39;, item)\n  const handleToggleEditable = () =&gt; {\n    isEditable = !isEditable\n    if (!isEditable) handleUpdateItem()\n  }\n&lt;/script&gt;\n</code></pre>\n<p><code>handleUpdateItem</code> 함수에서는 상위 컴포넌트로 이벤트를 발생시키게 하였습니다. <code>Board.svelte</code> 파일로 가서 해당 이벤트를 연결시켜 줍니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  const handleUpdateItem = e =&gt; items.update(e.detail)\n&lt;/script&gt;\n\n{#each _items as item (item.id)}\n&lt;Item {item} on:update={handleUpdateItem} on:remove={handleRemoveItem} /&gt;\n{/each}\n</code></pre>\n<p><code>Board.svelte</code> 컴포넌트에서 <code>on:update</code>로 해당 이벤트의 콜백을 연결해주고, <code>store</code>에 구현해둔 <code>update</code>를 호출합니다.</p>\n<p><img src=\"/svelte/svelte-store-and-crud/img/svelte_update_item.gif\" alt=\"remove item\"></p>\n<p>실제로 좋은 UX를 제공하려면, <code>Enter</code>키를 입력하거나 <code>input</code>에서 <code>blur</code>처리가 될 때, 상태를 변경시켜줘야 하겠지만, 그 작업은 생략하도록 하겠습니다.</p>\n<p>이제 <code>Item</code>의 완료처리를 구현해보겠습니다. 완료처리는 간단하게 제목을 클릭하면 제목에 실선이 그어지고, 색이 변하도록 만들겠습니다.</p>\n<p><code>Item.svelte</code>파일에서 다음과 같이 수정합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;script&gt;\n  const handleToggleDone = () =&gt; {\n    item.done = !item.done\n    handleUpdateItem()\n  }\n&lt;/script&gt;\n\n&lt;span class:item-done={item.done} on:click={handleToggleDone}&gt;\n  {item.title}\n&lt;/span&gt;\n\n&lt;style&gt;\n  .item-done {\n    text-decoration: line-through;\n    color: gray;\n  }\n&lt;/style&gt;\n</code></pre>\n<p><code>item</code>의 제목이 표시되는 엘리먼트를 클릭했을 때, <code>item.done</code>의 값이 변경되도록 해주고, <code>store</code>에 반영시켜줍니다. <code>item.done</code>의 값에 따라 <code>item-done</code>클래스를 가지도록 해주고, css로 실선과 색이 변하도록 해줍니다.</p>\n<hr>\n<p>이렇게 <strong>Item</strong>의 간단한 CRUD를 구현해 보았습니다. <strong>svelte</strong>로 기본적인 동작들을 만들면서 알아야 할 것들을 자연스럽게 사용해 볼 수 있었습니다.</p>\n<p>다음 시간에는 각 <code>Item</code>들의 순서를 변경하고, 다른 <code>Board</code>로 이동시키는 동작을 구현해보겠습니다.</p>\n<p><em>전체 프로젝트 코드는 <a href=\"https://github.com/hoontae24/hello-svelte\">Github</a>에서 보실 수 있습니다.</em></p>\n","excerpt":" 지난 시간에 이어서 boards와 items 데이터를 Store를 만들어서 관리하고, CRUD를 구현하겠습니다. 1. Store 구현하기 Svelte는 이미 Store 기능을 내장하고 있습니다. svelte/store를 import하면 그 기능을 사용할 수 있습니다. 먼저 Store를 구현할 파일을 만들도록 하겠습니다. /src폴더 아래에 stores폴더를","thumbnail":"/svelte/svelte-store-and-crud/img/svelte_2.png","thumbnailUrl":"https://hoontae24.github.io/svelte/svelte-store-and-crud/img/svelte_2.png"},{"href":"3","round":3,"paths":["svelte","svelte-setting-and-component"],"slug":"svelte-setting-and-component","title":"Svelte로 만드는 TODO-App (1), Svelte 설치하기 / 컴포넌트 구성하기","description":"","date":"2019-11-17","category":"svelte","tags":["javascript","frontend","svelte"],"seriesId":2,"markdown":"\n![svelte](/svelte/svelte-setting-and-component/img/svelte_2.png)\n\n최신 프론트엔드 기술 중 [Svelte](https://svelte.dev/)라는 기술에 대해 TODO-App 제작을 하면서 알아보겠습니다.\n\nSvelte에 대한 소개나 API는 [공식문서](https://svelte.dev/docs)나 아래의 자료를 읽어주세요.\n\n- [웹 프레임워크 Svelte를 소개합니다.](https://velog.io/@ashnamuh/hello-svelte)\n- [SvelteJS(스벨트) - 새로운 개념의 프론트엔드 프레임워크](https://heropy.blog/2019/09/29/svelte/)\n\n_이 글은 Svelte 실습 예제입니다._\n*전체 프로젝트 코드는 [Github](https://github.com/hoontae24/hello-svelte)에서 보실 수 있습니다.*\n\n---\n\n### 1. Svelte 설치하기\n\n먼저 Svelte를 설치합니다. Svelte 공식 사이트의 [QuickStart Guide](https://svelte.dev/blog/the-easiest-way-to-get-started)를 참조해 주세요.\n\n터미널에서 degit을 이용해서 Svelte 프로젝트 템플릿을 내려받을 수 있습니다.\n\n> $ npx degit sveltejs/template svelte-todo-app  \n> $ cd svelte-todo-app  \n> $ npm install  \n> $ npm run dev\n\n위의 작업을 마치고 [http://localhost:5000](http://localhost:5000)에 접속해봅니다. 프로젝트 설치는 잘된 것 같습니다.\n\n![Svelte_Helloword](/svelte/svelte-setting-and-component/img/svelte_helloworld.png)\n\n### 2. 컴포넌트 만들기\n\nTODO를 구성할 \"할 일\" 항목은 **Item**입니다.\n**Item**이 모여서 **Board**를 구성하고, **Board**를 통해 \"할 일의 진행 상태\"를 구분하도록 하겠습니다.\n그리고 꼭 필요한 것은 아니지만, **Appbar**를 만들도록 하겠습니다.\n\n그리고 저는 CSS 디자인 감각이 없어서 부트스트랩의 도움을 받도록 하겠습니다.  \n구글에서 `부트스트랩`을 검색하고 홈페이지에서 CDN을 가져오겠습니다.\n\n![Appbar](/svelte/svelte-setting-and-component/img/svelte_bootstrap.png)\n\n프로젝트에서 `public/index.html` 파일의 `<head>`태그 안에 cdn을 붙여 넣어줍니다.\n\n```html\n<!-- public/index.html -->\n<link\n  rel=\"stylesheet\"\n  href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\"\n  integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\"\n  crossorigin=\"anonymous\"\n/>\n```\n\n#### 2.1 Appbar 컴포넌트 만들기\n\n먼저 Appbar를 만들겠습니다. 없어도 전혀 지장이 없지만, 너무 밋밋하면 재미없으니까요.\n\n`/src` 폴더 아래에 `components`폴더를 만들고, 그 아래 `Appbar.svelte` 파일을 만들겠습니다. 또 `Board.svelte`와 `Item.svelte` 파일도 미리 만들어 두겠습니다.\n\n![디렉토리](/svelte/svelte-setting-and-component/img/svelte_diretory.png)\n\n**Appbar**에는 간단하게 제목 정도 나오게 만들어 주겠습니다.\n\n```html\n<!-- Appbar.svelte -->\n<script>\n  const appTitle = 'Svelte Todo App'\n</script>\n\n<div class=\"appbar\">\n  <h1 class=\"title\">{appTitle}</h1>\n</div>\n\n<style>\n  .appbar {\n    background-color: darkslategrey;\n    padding: 8px;\n  }\n\n  .appbar > .title {\n    text-align: center;\n    color: white;\n  }\n</style>\n```\n\n`App.svelte` 파일로 가서 **Appbar** 컴포넌트를 추가해 주겠습니다.\n\n`<script>`태그 가장 위에 `import` 구문을 입력하고, 페이지에 표시될 태그 상단에 `<Appbar />`를 추가해줍니다.\n\n```html\n<!-- App.svelte -->\n<script>\n  import Appbar from './components/Appbar.svelte'\n\n  export let name\n</script>\n\n<style>\n  h1 {\n    color: purple;\n  }\n</style>\n\n<Appbar />\n<h1>Hello {name}!</h1>\n```\n\n그리고 앱의 내용들이 가운데 올 수 있도록 `Container`로 감싸도록 하겠습니다.\n\n`src/App.svelte` 파일을 수정합니다. 기존의 내용 부분에 있던 코드를 `container`클래스를 가진 `<div>`태그로 감싸줍니다. 부트스트랩에 정의된 클래스이기 때문에 `<div>`태그가 [컨테이너](https://getbootstrap.com/docs/4.3/layout/overview/) 역할을 합니다.\n\n```html\n<!-- App.svelte -->\n<div class=\"container\">\n  <h1>Hello {name}!</h1>\n</div>\n```\n\n이제 브라우저에 가서 확인해 봅니다.\n\n![Appbar](/svelte/svelte-setting-and-component/img/svelte_appbar.png)\n\n**Appbar**와 **부트스트랩**이 적용된 **Container**가 잘 나오는 것을 확인할 수 있습니다.\n\n#### 2.2 Board 컴포넌트 만들기\n\n다음은 제대로 Todo-App에 쓰일 부분들을 만들도록 하겠습니다.\n\n`src/components/Board.svelte`로 가서 **Board**를 만들도록 하겠습니다.\n\n먼저 간단하게 제목 정도만 표시할 수 있도록 해주겠습니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  export let board = null\n</script>\n\n{#if board}\n<div class=\"board wrapper card\">\n  <!-- 부트스트랩의 card 디자인 이용 -->\n  <div class=\"card-body\">\n    {board.title}\n  </div>\n</div>\n{/if}\n\n<style>\n  .board.wrapper {\n    background-color: #e9ecef;\n  }\n</style>\n```\n\n기초적인 문법을 잠깐 짚고 넘어가겠습니다.\n\n```javascript\nexport let board = null\n```\n\n`Svelte`에서 `<script>`태그 내부에 `export`구문을 쓰면 부모 컴포넌트의 값을 받아오는 **props**가 됩니다. (만약 부모 컴포넌트에서 넘겨주는 값이 없다면 여기서는 `null`로 지정됩니다.)\n\n```html\n<div class=\"card-body\">\n  {board.title}\n</div>\n```\n\n일반적인 html태그를 쓰는 부분에서 {}를 이용하여 script에서 선언한 변수를 참조할 수 있습니다. `{board.title}`은 부모 컴포넌트에서 넘겨준 `board`객체의 `title`속성을 가져옵니다.\n\n이제 부모 컴포넌트인 `App.svelte`로 가서 **Board**를 구성해줍니다.\n\n`<script>`태그 상단에서 `Board`컴포넌트를 불러옵니다.\n\n```javascript\nimport Board from './components/Board.svelte'\n```\n\n그리고 그 아래에 Board로 사용할 임시 데이터를 선언해줍니다.\n\n```javascript\nconst boards = [\n  { title: 'Planning' },\n  { title: 'In Progress' },\n  { title: 'All Done' },\n]\n```\n\n`container`안쪽 부분의 원래 내용을 지우고 Board를 다음과 같이 작성합니다.\n\n```html\n<div class=\"container\">\n  {#each boards as board}\n  <div class=\"item\">\n    <Board board={board} />\n  </div>\n  {/each}\n</div>\n```\n\n`Svelte`의 `#each`구문은 [여기](https://svelte.dev/docs#each)서 확인하세요.  \nitems 배열에 있는 값을 하나씩 꺼내 item이라는 변수로 참조하게 합니다.\n\n```html\n<Board board={board} />\n```\n\n`<Board>` 컴포넌트의 `board`속성으로 값을 지정하면 `Board.svelte`에서 `export` 구문으로 선언한 `board`에 전달됩니다.\n\n각 `Board`에 CSS를 약간 추가해줍니다.\n\n```html\n<style>\n  .container {\n    overflow: auto;\n    display: flex;\n  }\n  .container .item {\n    width: 300px;\n    flex-grow: 1;\n    margin: 32px;\n  }\n</style>\n```\n\n그리고 전체 페이지의 배경화면을 약간 어둡게 바꾸겠습니다.  \n`public/global.css`파일의 `body`부분에 다음과 같이 추가하겠습니다.\n\n```css\nbody {\n  padding: 0px; /* padding: 8px;에서 수정 */\n  background-color: #ccc !important; /* 추가 */\n}\n```\n\n제대로 동작하는지 확인해 보겠습니다.\n\n![-](/svelte/svelte-setting-and-component/img/svelte_board.png)\n\n`App.svelte`에 선언한 `boards`의 데이터가 컴포넌트의 속성을 통해서 주입된 것을 확인할 수 있습니다.\n\n#### 2.3 Item 컴포넌트 만들기\n\n먼저 `item`으로 사용될 임시 데이터를 만듭니다.\n\n`App.svelte`파일의 `<script>`태그에 다음 내용을 추가해줍니다.\n\n```javascript\nconst items = [\n  { id: 1, boardId: 1, title: '자료 조사하기', done: false },\n  { id: 2, boardId: 1, title: '교양책 읽기', done: false },\n  { id: 3, boardId: 2, title: '분리수거하기', done: false },\n  { id: 4, boardId: 2, title: '가계부 정리하기', done: false },\n  { id: 5, boardId: 3, title: '버그 수정하기', done: false },\n]\n```\n\n그리고 이전에 만들어 둔 `boards`데이터에 `id`속성을 추가해줍니다.\n\n```javascript\nconst boards = [\n  { id: 1, title: 'Planning' },\n  { id: 2, title: 'In Progress' },\n  { id: 3, title: 'All Done' },\n]\n```\n\n각 `item`들은 자신이 속하는 `Board`의 `id`값을 가지고 있습니다.\n\n`Board.svelte`파일로 가서 `Board`의 제목 아래에 `item`들이 표시되도록 합니다.\n\n```html\n<!-- Board.svelte -->\n<script>\n  import Item from './Item.svelte' // Item 컴포넌트를 불러옵니다.\n\n  export let board = null\n  export let items = [] // App 컴포넌트에서 전달하는 items를 받습니다.\n</script>\n\n{#if board}\n<div class=\"board wrapper card\">\n  <div class=\"card-body\">\n    <h5 class=\"card-title\">\n      {board.title}\n    </h5>\n    {#each items as item (item.id)}\n    <Item {item} />\n    <!-- <Item item={item} />과 동일함. 속성과 변수명이 같으면 생략가능 -->\n    {/each}\n  </div>\n</div>\n{/if}\n\n<style>\n  .board.wrapper {\n    background-color: #ebebeb;\n  }\n</style>\n```\n\n`Item.svelte`파일에서 `item`이 표시되도록 다음과 같이 작성해줍니다. (주석으로 표시한 부분만 이해하면 됩니다.)\n\n```html\n<!-- Item.svelte -->\n<script>\n  export let item = null // Board에서 item값을 전달 받습니다.\n  let hovering = false\n</script>\n\n{#if item}\n<div\n  class=\"item card p-1 mb-1 shadow-sm\"\n\tclass:shadow={hovering}\n\ton:mouseenter={() => hovering = true}\n\ton:mouseleave={() => hovering = false}\n>\n  <span>\n    {item.title}\n    <!-- item의 제목을 출력합니다. -->\n  </span>\n</div>\n{/if}\n\n<style>\n  .item {\n    transition: box-shadow 0.25s ease-in;\n  }\n</style>\n```\n\n![-](/svelte/svelte-setting-and-component/img/svelte_item.png)\n\n각 `item`의 제목도 잘 출력되고, hover에도 반응하는 것을 볼 수 있습니다.\n\n---\n\n다음 시간에는 임시로 만들었던 `boards`와 `items` 데이터를 `store`로 분리해 관리하고, 추가/삭제 등의 동작도 구현해보겠습니다.\n\n*전체 프로젝트 코드는 [Github](https://github.com/hoontae24/hello-svelte)에서 보실 수 있습니다.*\n","html":"<p><img src=\"/svelte/svelte-setting-and-component/img/svelte_2.png\" alt=\"svelte\"></p>\n<p>최신 프론트엔드 기술 중 <a href=\"https://svelte.dev/\">Svelte</a>라는 기술에 대해 TODO-App 제작을 하면서 알아보겠습니다.</p>\n<p>Svelte에 대한 소개나 API는 <a href=\"https://svelte.dev/docs\">공식문서</a>나 아래의 자료를 읽어주세요.</p>\n<ul>\n<li><a href=\"https://velog.io/@ashnamuh/hello-svelte\">웹 프레임워크 Svelte를 소개합니다.</a></li>\n<li><a href=\"https://heropy.blog/2019/09/29/svelte/\">SvelteJS(스벨트) - 새로운 개념의 프론트엔드 프레임워크</a></li>\n</ul>\n<p><em>이 글은 Svelte 실습 예제입니다.</em>\n<em>전체 프로젝트 코드는 <a href=\"https://github.com/hoontae24/hello-svelte\">Github</a>에서 보실 수 있습니다.</em></p>\n<hr>\n<h3 id=\"1-svelte-설치하기\">1. Svelte 설치하기</h3>\n<p>먼저 Svelte를 설치합니다. Svelte 공식 사이트의 <a href=\"https://svelte.dev/blog/the-easiest-way-to-get-started\">QuickStart Guide</a>를 참조해 주세요.</p>\n<p>터미널에서 degit을 이용해서 Svelte 프로젝트 템플릿을 내려받을 수 있습니다.</p>\n<blockquote>\n<p>$ npx degit sveltejs/template svelte-todo-app<br>$ cd svelte-todo-app<br>$ npm install<br>$ npm run dev</p>\n</blockquote>\n<p>위의 작업을 마치고 <a href=\"http://localhost:5000\">http://localhost:5000</a>에 접속해봅니다. 프로젝트 설치는 잘된 것 같습니다.</p>\n<p><img src=\"/svelte/svelte-setting-and-component/img/svelte_helloworld.png\" alt=\"Svelte_Helloword\"></p>\n<h3 id=\"2-컴포넌트-만들기\">2. 컴포넌트 만들기</h3>\n<p>TODO를 구성할 &quot;할 일&quot; 항목은 <strong>Item</strong>입니다.\n<strong>Item</strong>이 모여서 <strong>Board</strong>를 구성하고, <strong>Board</strong>를 통해 &quot;할 일의 진행 상태&quot;를 구분하도록 하겠습니다.\n그리고 꼭 필요한 것은 아니지만, <strong>Appbar</strong>를 만들도록 하겠습니다.</p>\n<p>그리고 저는 CSS 디자인 감각이 없어서 부트스트랩의 도움을 받도록 하겠습니다.<br>구글에서 <code>부트스트랩</code>을 검색하고 홈페이지에서 CDN을 가져오겠습니다.</p>\n<p><img src=\"/svelte/svelte-setting-and-component/img/svelte_bootstrap.png\" alt=\"Appbar\"></p>\n<p>프로젝트에서 <code>public/index.html</code> 파일의 <code>&lt;head&gt;</code>태그 안에 cdn을 붙여 넣어줍니다.</p>\n<pre><code class=\"language-html\">&lt;!-- public/index.html --&gt;\n&lt;link\n  rel=&quot;stylesheet&quot;\n  href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css&quot;\n  integrity=&quot;sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T&quot;\n  crossorigin=&quot;anonymous&quot;\n/&gt;\n</code></pre>\n<h4 id=\"21-appbar-컴포넌트-만들기\">2.1 Appbar 컴포넌트 만들기</h4>\n<p>먼저 Appbar를 만들겠습니다. 없어도 전혀 지장이 없지만, 너무 밋밋하면 재미없으니까요.</p>\n<p><code>/src</code> 폴더 아래에 <code>components</code>폴더를 만들고, 그 아래 <code>Appbar.svelte</code> 파일을 만들겠습니다. 또 <code>Board.svelte</code>와 <code>Item.svelte</code> 파일도 미리 만들어 두겠습니다.</p>\n<p><img src=\"/svelte/svelte-setting-and-component/img/svelte_diretory.png\" alt=\"디렉토리\"></p>\n<p><strong>Appbar</strong>에는 간단하게 제목 정도 나오게 만들어 주겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Appbar.svelte --&gt;\n&lt;script&gt;\n  const appTitle = &#39;Svelte Todo App&#39;\n&lt;/script&gt;\n\n&lt;div class=&quot;appbar&quot;&gt;\n  &lt;h1 class=&quot;title&quot;&gt;{appTitle}&lt;/h1&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n  .appbar {\n    background-color: darkslategrey;\n    padding: 8px;\n  }\n\n  .appbar &gt; .title {\n    text-align: center;\n    color: white;\n  }\n&lt;/style&gt;\n</code></pre>\n<p><code>App.svelte</code> 파일로 가서 <strong>Appbar</strong> 컴포넌트를 추가해 주겠습니다.</p>\n<p><code>&lt;script&gt;</code>태그 가장 위에 <code>import</code> 구문을 입력하고, 페이지에 표시될 태그 상단에 <code>&lt;Appbar /&gt;</code>를 추가해줍니다.</p>\n<pre><code class=\"language-html\">&lt;!-- App.svelte --&gt;\n&lt;script&gt;\n  import Appbar from &#39;./components/Appbar.svelte&#39;\n\n  export let name\n&lt;/script&gt;\n\n&lt;style&gt;\n  h1 {\n    color: purple;\n  }\n&lt;/style&gt;\n\n&lt;Appbar /&gt;\n&lt;h1&gt;Hello {name}!&lt;/h1&gt;\n</code></pre>\n<p>그리고 앱의 내용들이 가운데 올 수 있도록 <code>Container</code>로 감싸도록 하겠습니다.</p>\n<p><code>src/App.svelte</code> 파일을 수정합니다. 기존의 내용 부분에 있던 코드를 <code>container</code>클래스를 가진 <code>&lt;div&gt;</code>태그로 감싸줍니다. 부트스트랩에 정의된 클래스이기 때문에 <code>&lt;div&gt;</code>태그가 <a href=\"https://getbootstrap.com/docs/4.3/layout/overview/\">컨테이너</a> 역할을 합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- App.svelte --&gt;\n&lt;div class=&quot;container&quot;&gt;\n  &lt;h1&gt;Hello {name}!&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre>\n<p>이제 브라우저에 가서 확인해 봅니다.</p>\n<p><img src=\"/svelte/svelte-setting-and-component/img/svelte_appbar.png\" alt=\"Appbar\"></p>\n<p><strong>Appbar</strong>와 <strong>부트스트랩</strong>이 적용된 <strong>Container</strong>가 잘 나오는 것을 확인할 수 있습니다.</p>\n<h4 id=\"22-board-컴포넌트-만들기\">2.2 Board 컴포넌트 만들기</h4>\n<p>다음은 제대로 Todo-App에 쓰일 부분들을 만들도록 하겠습니다.</p>\n<p><code>src/components/Board.svelte</code>로 가서 <strong>Board</strong>를 만들도록 하겠습니다.</p>\n<p>먼저 간단하게 제목 정도만 표시할 수 있도록 해주겠습니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  export let board = null\n&lt;/script&gt;\n\n{#if board}\n&lt;div class=&quot;board wrapper card&quot;&gt;\n  &lt;!-- 부트스트랩의 card 디자인 이용 --&gt;\n  &lt;div class=&quot;card-body&quot;&gt;\n    {board.title}\n  &lt;/div&gt;\n&lt;/div&gt;\n{/if}\n\n&lt;style&gt;\n  .board.wrapper {\n    background-color: #e9ecef;\n  }\n&lt;/style&gt;\n</code></pre>\n<p>기초적인 문법을 잠깐 짚고 넘어가겠습니다.</p>\n<pre><code class=\"language-javascript\">export let board = null\n</code></pre>\n<p><code>Svelte</code>에서 <code>&lt;script&gt;</code>태그 내부에 <code>export</code>구문을 쓰면 부모 컴포넌트의 값을 받아오는 <strong>props</strong>가 됩니다. (만약 부모 컴포넌트에서 넘겨주는 값이 없다면 여기서는 <code>null</code>로 지정됩니다.)</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;card-body&quot;&gt;\n  {board.title}\n&lt;/div&gt;\n</code></pre>\n<p>일반적인 html태그를 쓰는 부분에서 {}를 이용하여 script에서 선언한 변수를 참조할 수 있습니다. <code>{board.title}</code>은 부모 컴포넌트에서 넘겨준 <code>board</code>객체의 <code>title</code>속성을 가져옵니다.</p>\n<p>이제 부모 컴포넌트인 <code>App.svelte</code>로 가서 <strong>Board</strong>를 구성해줍니다.</p>\n<p><code>&lt;script&gt;</code>태그 상단에서 <code>Board</code>컴포넌트를 불러옵니다.</p>\n<pre><code class=\"language-javascript\">import Board from &#39;./components/Board.svelte&#39;\n</code></pre>\n<p>그리고 그 아래에 Board로 사용할 임시 데이터를 선언해줍니다.</p>\n<pre><code class=\"language-javascript\">const boards = [\n  { title: &#39;Planning&#39; },\n  { title: &#39;In Progress&#39; },\n  { title: &#39;All Done&#39; },\n]\n</code></pre>\n<p><code>container</code>안쪽 부분의 원래 내용을 지우고 Board를 다음과 같이 작성합니다.</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;container&quot;&gt;\n  {#each boards as board}\n  &lt;div class=&quot;item&quot;&gt;\n    &lt;Board board={board} /&gt;\n  &lt;/div&gt;\n  {/each}\n&lt;/div&gt;\n</code></pre>\n<p><code>Svelte</code>의 <code>#each</code>구문은 <a href=\"https://svelte.dev/docs#each\">여기</a>서 확인하세요.<br>items 배열에 있는 값을 하나씩 꺼내 item이라는 변수로 참조하게 합니다.</p>\n<pre><code class=\"language-html\">&lt;Board board={board} /&gt;\n</code></pre>\n<p><code>&lt;Board&gt;</code> 컴포넌트의 <code>board</code>속성으로 값을 지정하면 <code>Board.svelte</code>에서 <code>export</code> 구문으로 선언한 <code>board</code>에 전달됩니다.</p>\n<p>각 <code>Board</code>에 CSS를 약간 추가해줍니다.</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n  .container {\n    overflow: auto;\n    display: flex;\n  }\n  .container .item {\n    width: 300px;\n    flex-grow: 1;\n    margin: 32px;\n  }\n&lt;/style&gt;\n</code></pre>\n<p>그리고 전체 페이지의 배경화면을 약간 어둡게 바꾸겠습니다.<br><code>public/global.css</code>파일의 <code>body</code>부분에 다음과 같이 추가하겠습니다.</p>\n<pre><code class=\"language-css\">body {\n  padding: 0px; /* padding: 8px;에서 수정 */\n  background-color: #ccc !important; /* 추가 */\n}\n</code></pre>\n<p>제대로 동작하는지 확인해 보겠습니다.</p>\n<p><img src=\"/svelte/svelte-setting-and-component/img/svelte_board.png\" alt=\"-\"></p>\n<p><code>App.svelte</code>에 선언한 <code>boards</code>의 데이터가 컴포넌트의 속성을 통해서 주입된 것을 확인할 수 있습니다.</p>\n<h4 id=\"23-item-컴포넌트-만들기\">2.3 Item 컴포넌트 만들기</h4>\n<p>먼저 <code>item</code>으로 사용될 임시 데이터를 만듭니다.</p>\n<p><code>App.svelte</code>파일의 <code>&lt;script&gt;</code>태그에 다음 내용을 추가해줍니다.</p>\n<pre><code class=\"language-javascript\">const items = [\n  { id: 1, boardId: 1, title: &#39;자료 조사하기&#39;, done: false },\n  { id: 2, boardId: 1, title: &#39;교양책 읽기&#39;, done: false },\n  { id: 3, boardId: 2, title: &#39;분리수거하기&#39;, done: false },\n  { id: 4, boardId: 2, title: &#39;가계부 정리하기&#39;, done: false },\n  { id: 5, boardId: 3, title: &#39;버그 수정하기&#39;, done: false },\n]\n</code></pre>\n<p>그리고 이전에 만들어 둔 <code>boards</code>데이터에 <code>id</code>속성을 추가해줍니다.</p>\n<pre><code class=\"language-javascript\">const boards = [\n  { id: 1, title: &#39;Planning&#39; },\n  { id: 2, title: &#39;In Progress&#39; },\n  { id: 3, title: &#39;All Done&#39; },\n]\n</code></pre>\n<p>각 <code>item</code>들은 자신이 속하는 <code>Board</code>의 <code>id</code>값을 가지고 있습니다.</p>\n<p><code>Board.svelte</code>파일로 가서 <code>Board</code>의 제목 아래에 <code>item</code>들이 표시되도록 합니다.</p>\n<pre><code class=\"language-html\">&lt;!-- Board.svelte --&gt;\n&lt;script&gt;\n  import Item from &#39;./Item.svelte&#39; // Item 컴포넌트를 불러옵니다.\n\n  export let board = null\n  export let items = [] // App 컴포넌트에서 전달하는 items를 받습니다.\n&lt;/script&gt;\n\n{#if board}\n&lt;div class=&quot;board wrapper card&quot;&gt;\n  &lt;div class=&quot;card-body&quot;&gt;\n    &lt;h5 class=&quot;card-title&quot;&gt;\n      {board.title}\n    &lt;/h5&gt;\n    {#each items as item (item.id)}\n    &lt;Item {item} /&gt;\n    &lt;!-- &lt;Item item={item} /&gt;과 동일함. 속성과 변수명이 같으면 생략가능 --&gt;\n    {/each}\n  &lt;/div&gt;\n&lt;/div&gt;\n{/if}\n\n&lt;style&gt;\n  .board.wrapper {\n    background-color: #ebebeb;\n  }\n&lt;/style&gt;\n</code></pre>\n<p><code>Item.svelte</code>파일에서 <code>item</code>이 표시되도록 다음과 같이 작성해줍니다. (주석으로 표시한 부분만 이해하면 됩니다.)</p>\n<pre><code class=\"language-html\">&lt;!-- Item.svelte --&gt;\n&lt;script&gt;\n  export let item = null // Board에서 item값을 전달 받습니다.\n  let hovering = false\n&lt;/script&gt;\n\n{#if item}\n&lt;div\n  class=&quot;item card p-1 mb-1 shadow-sm&quot;\n    class:shadow={hovering}\n    on:mouseenter={() =&gt; hovering = true}\n    on:mouseleave={() =&gt; hovering = false}\n&gt;\n  &lt;span&gt;\n    {item.title}\n    &lt;!-- item의 제목을 출력합니다. --&gt;\n  &lt;/span&gt;\n&lt;/div&gt;\n{/if}\n\n&lt;style&gt;\n  .item {\n    transition: box-shadow 0.25s ease-in;\n  }\n&lt;/style&gt;\n</code></pre>\n<p><img src=\"/svelte/svelte-setting-and-component/img/svelte_item.png\" alt=\"-\"></p>\n<p>각 <code>item</code>의 제목도 잘 출력되고, hover에도 반응하는 것을 볼 수 있습니다.</p>\n<hr>\n<p>다음 시간에는 임시로 만들었던 <code>boards</code>와 <code>items</code> 데이터를 <code>store</code>로 분리해 관리하고, 추가/삭제 등의 동작도 구현해보겠습니다.</p>\n<p><em>전체 프로젝트 코드는 <a href=\"https://github.com/hoontae24/hello-svelte\">Github</a>에서 보실 수 있습니다.</em></p>\n","excerpt":" 최신 프론트엔드 기술 중 Svelte라는 기술에 대해 TODO-App 제작을 하면서 알아보겠습니다. Svelte에 대한 소개나 API는 공식문서나 아래의 자료를 읽어주세요.  웹 프레임워크 Svelte를 소개합니다. SvelteJS(스벨트) - 새로운 개념의 프론트엔드 프레임워크  이 글은 Svelte 실습 예제입니다. 전체 프로젝트 코드는 Github에서","thumbnail":"/svelte/svelte-setting-and-component/img/svelte_2.png","thumbnailUrl":"https://hoontae24.github.io/svelte/svelte-setting-and-component/img/svelte_2.png"},{"href":"2","round":2,"paths":["blog","jekyll-theme-and-posting"],"slug":"jekyll-theme-and-posting","title":"블로그 만들기, Jekyll Theme 적용 및 첫번째 포스트 작성하기","description":"나만의 블로그를 위해 이미 만들어져 있는 Jekyll Theme를 가져와서 적용해봅니다. 그리고 Markdown으로 블로그의 첫번째 포스트를 쉽게 작성해봅니다.","date":"2019-10-26","category":"blog","tags":["blog","jekyll","github"],"seriesId":1,"markdown":"\n![github and jekyll](/blog/jekyll-theme-and-posting/img/github_jekyll.jpg)\n\n지난 포스트에서 Github Pages를 이용하여 호스팅하는 블로그를 만들어보았다. 지금은 접속할 수 있는 환경을 만들어 둔 정도다. 이제 Jekyll을 좀 더 제대로 이용하면서 Theme 디자인 및 템플릿을 설정하여 블로그답게 만들 수 있다.\n\n---\n\n## **1. Jekyll Theme 가져오기**\n\n테마를 적용할 수 있는 방법은 여러가지이다. 아마 제일 쉬운 방법은 테마가 셋팅된 저장소를 그대로 가져오는 것이다. 사실 이전에 했던 작업이 그대로 덮어쓰여지기 때문에, 이전 포스트의 작업을 선행할 필요는 없다. 다만, Github Pages에 호스팅 하는 개념만 알고 있으면 된다.\n\n먼저 적용하고 싶은 테마를 [Jekyll Theme](http://jekyllthemes.org/), [Free Jekyll Theme](http://jekyllthemes.io/free)에서 찾아본다. 이미 만들어져 있는 테마가 많기 때문에 자신이 원하는 스타일을 고르면 된다. 이후에 세부적인 부분은 코드를 수정해서 디자인할 수도 있다.\n\n나는 가장 상위에 있는 **_Now_** 라는 테마를 선택했다.\n\n![Now Jekyll theme](/blog/jekyll-theme-and-posting/img/now.png)\n\n테마에 사용되는 플러그인 등에 따라 폴더 구조나 파일들이 제각각이다. 아직 Jekyll 블로그를 자유자재로 다룰 정도는 아니기 때문에 비교적 간단한 테마를 선택했다. 이제 테마의 Github 저장소에 가서 코드를 몽땅 다운로드한다.  \n(저장소를 Fork해서 가져와도 동일하다. 이 경우엔 fork해서 가져온 저장소의 이름을 이전 포스트에서 작업한 것 처럼 username.github.io로 변경해주고 내려받으면 된다.)\n\n![Now Github Repository](/blog/jekyll-theme-and-posting/img/now-github.png)\n\n기존의 로컬 블로그 폴더에 있던 파일을 **.git** 폴더만 제외하고 모두 삭제한다.(.git 폴더를 지우면 Github 원격 저장소 연결이 사라진다.)  \n사용하고 싶은 테마의 저장소에서 내려받은 코드를 압축 해제하고, 다 지워버린 블로그 폴더에 붙여넣기 해준다.\n\n이제 덮어쓰여진 새로운 블로그를 로컬에서 띄워보자.\n\n> $ cd my-blog-site  \n> $ jekyll serve\n\n[http://127.0.0.1:4000/](http://127.0.0.1:4000/) 으로 접속한다.\n\n![Blog page updated](/blog/jekyll-theme-and-posting/img/now-github-page.png)\n_(기본 테마와 크게 다른게 없는 것 같다...)_\n\n---\n\n## **2. 블로그 환경설정 변경하기**\n\n> Jekyll 의 핵심 역할은 텍스트 변환 엔진입니다.\n\nJekyll은 정적인 사이트를 생성해준다. [디렉토리 구조](https://jekyllrb-ko.github.io/docs/structure/)나 [환경설정](https://jekyllrb-ko.github.io/docs/configuration/)을 통해 나만의 블로그 포맷을 만들 수 있는 것이다.\n\n**\\_config.yml**파일을 열어 몇가지 설정을 변경해주어 커스터마이징 해보자. 아직은 모든 설정을 잘 모르기 때문에 중요한 부분들만 먼저 바꾸어 본다.\n\n```yml\nname: 개발자 쌓아올리기\ndescription: 조금씩 쌓아보자, 개발지식\nurl: https://[username].github.io/\nbaseurl: ''\n```\n\n해당 부분들을 변경하고 새로고침하면 블로그의 이름과 설명이 자동으로 변경된다.\n\n![Blog page updated](/blog/jekyll-theme-and-posting/img/now-github-page-2.png)\n\n기본으로 생성되어 있는 index.html 파일을 열어보면 다음과 같이 머리말이 지정되어있다.\n\n```html\n---\nlayout: default\n---\n```\n\nlayout으로 default라는 파일을 사용한다는 것인데, **\\_layout** 폴더의 **default.html** 파일을 보자.\n\n```html\n{% raw %}\n<header class=\"masthead clearfix\">\n  <a href=\"{{ site.baseurl }}/\" class=\"site-avatar\"\n    ><img src=\"{{ site.avatar }}\"\n  /></a>\n  <div class=\"site-info\">\n    <h1 class=\"site-name\"><a href=\"{{ site.baseurl }}/\">{{ site.name }}</a></h1>\n    <p class=\"site-description\">{{ site.description }}</p>\n  </div>\n  <nav>\n    <a href=\"{{ site.baseurl }}/\">Blog</a>\n    <a href=\"{{ site.baseurl }}/about\">About</a>\n  </nav>\n</header>\n```\n\n{{ ... }} 로 둘러싸인 부분은 Liquid 라는 문법으로 쓰여진 것인데, 정적 페이지로 빌드할 때 jekyll이 해당 부분을 변환해준다. **{{ site.name }}** 의 부분은 \\_config.yml에서 설정했던 **name**에 해당하는 값으로 변환되는 것이다.\n다른 많은 부분들에서도 설정된 변수나 환경에 따라 변환되도록 코딩되어 있어서, 반복되는 작업을 하거나 외부적인 플러그인을 설치하여 쉽게 정적 페이지를 제공할 수 있게 해준다.\n{% endraw %}\n\n[Jekyll 사용 설명서](https://jekyllrb-ko.github.io/docs/home/)를 통해서 필요한 기능들을 익혀가야 한다.\n\n---\n\n## **3. 포스트 작성하기**\n\nJekyll에서 포스트는 [마크다운](https://daringfireball.net/projects/markdown/)으로 작성한다. **\\_post**폴더에 YYYY-MM-DD-[제목].md 형식으로 파일을 저장하면 자동으로 포스트가 생성된다.\n\n**\\_posts**에 _2019-10-21-Gibhub Pages + Jekyll Blog (1).md_ 라는 파일을 생성하고 다음과 같이 코드를 추가하였다.\n\n```html\n---\nlayout: post\ntitle: Github Pages + Jekyll 기반 블로그 만들기 (1)\nsubtitle: Github Pages 호스팅 및 Jekyll 설치하기\nauthor: Hoontae\ncategories: blog\ntags: blog jekyll\n# image: assets/images/1.jpg\nfeatured: true\nhidden: false\npermalink: '/:categories/:title'\n---\n\n--- Github Pages와 Jekyll을 이용해 블로그 만들기 ---\n```\n\nmd파일을 추가하기만 해도 포스트가 생성된다. 블로그 폴더에 /\\_site/blog/[제목].html 파일이 생성된 것을 볼 수 있다. 설정마다 다르게 생성되는데, 지금은 md파일의 머리말에 permalink 속성으로 /:categories/:title 로 설정해두어 위와 같은 경로로 포스트 파일이 생성된 것이다.\n\n블로그에 접속해보면 해당 포스트가 생성된 것을 확인할 수 있다.\n\n![Blog page updated](/blog/jekyll-theme-and-posting/img/now-github-post.png)\n\n몇가지 설정하는 부분은 아직 모르는 부분이 많지만, 마크다운 형식으로 파일을 작성하여 Github 저장소에 Push하기만 하면 쉽게 블로그에 글을 올릴 수 있게 되었다.\n","html":"<p><img src=\"/blog/jekyll-theme-and-posting/img/github_jekyll.jpg\" alt=\"github and jekyll\"></p>\n<p>지난 포스트에서 Github Pages를 이용하여 호스팅하는 블로그를 만들어보았다. 지금은 접속할 수 있는 환경을 만들어 둔 정도다. 이제 Jekyll을 좀 더 제대로 이용하면서 Theme 디자인 및 템플릿을 설정하여 블로그답게 만들 수 있다.</p>\n<hr>\n<h2 id=\"1-jekyll-theme-가져오기\"><strong>1. Jekyll Theme 가져오기</strong></h2>\n<p>테마를 적용할 수 있는 방법은 여러가지이다. 아마 제일 쉬운 방법은 테마가 셋팅된 저장소를 그대로 가져오는 것이다. 사실 이전에 했던 작업이 그대로 덮어쓰여지기 때문에, 이전 포스트의 작업을 선행할 필요는 없다. 다만, Github Pages에 호스팅 하는 개념만 알고 있으면 된다.</p>\n<p>먼저 적용하고 싶은 테마를 <a href=\"http://jekyllthemes.org/\">Jekyll Theme</a>, <a href=\"http://jekyllthemes.io/free\">Free Jekyll Theme</a>에서 찾아본다. 이미 만들어져 있는 테마가 많기 때문에 자신이 원하는 스타일을 고르면 된다. 이후에 세부적인 부분은 코드를 수정해서 디자인할 수도 있다.</p>\n<p>나는 가장 상위에 있는 <strong><em>Now</em></strong> 라는 테마를 선택했다.</p>\n<p><img src=\"/blog/jekyll-theme-and-posting/img/now.png\" alt=\"Now Jekyll theme\"></p>\n<p>테마에 사용되는 플러그인 등에 따라 폴더 구조나 파일들이 제각각이다. 아직 Jekyll 블로그를 자유자재로 다룰 정도는 아니기 때문에 비교적 간단한 테마를 선택했다. 이제 테마의 Github 저장소에 가서 코드를 몽땅 다운로드한다.<br>(저장소를 Fork해서 가져와도 동일하다. 이 경우엔 fork해서 가져온 저장소의 이름을 이전 포스트에서 작업한 것 처럼 username.github.io로 변경해주고 내려받으면 된다.)</p>\n<p><img src=\"/blog/jekyll-theme-and-posting/img/now-github.png\" alt=\"Now Github Repository\"></p>\n<p>기존의 로컬 블로그 폴더에 있던 파일을 <strong>.git</strong> 폴더만 제외하고 모두 삭제한다.(.git 폴더를 지우면 Github 원격 저장소 연결이 사라진다.)<br>사용하고 싶은 테마의 저장소에서 내려받은 코드를 압축 해제하고, 다 지워버린 블로그 폴더에 붙여넣기 해준다.</p>\n<p>이제 덮어쓰여진 새로운 블로그를 로컬에서 띄워보자.</p>\n<blockquote>\n<p>$ cd my-blog-site<br>$ jekyll serve</p>\n</blockquote>\n<p><a href=\"http://127.0.0.1:4000/\">http://127.0.0.1:4000/</a> 으로 접속한다.</p>\n<p><img src=\"/blog/jekyll-theme-and-posting/img/now-github-page.png\" alt=\"Blog page updated\">\n<em>(기본 테마와 크게 다른게 없는 것 같다...)</em></p>\n<hr>\n<h2 id=\"2-블로그-환경설정-변경하기\"><strong>2. 블로그 환경설정 변경하기</strong></h2>\n<blockquote>\n<p>Jekyll 의 핵심 역할은 텍스트 변환 엔진입니다.</p>\n</blockquote>\n<p>Jekyll은 정적인 사이트를 생성해준다. <a href=\"https://jekyllrb-ko.github.io/docs/structure/\">디렉토리 구조</a>나 <a href=\"https://jekyllrb-ko.github.io/docs/configuration/\">환경설정</a>을 통해 나만의 블로그 포맷을 만들 수 있는 것이다.</p>\n<p><strong>_config.yml</strong>파일을 열어 몇가지 설정을 변경해주어 커스터마이징 해보자. 아직은 모든 설정을 잘 모르기 때문에 중요한 부분들만 먼저 바꾸어 본다.</p>\n<pre><code class=\"language-yml\">name: 개발자 쌓아올리기\ndescription: 조금씩 쌓아보자, 개발지식\nurl: https://[username].github.io/\nbaseurl: &#39;&#39;\n</code></pre>\n<p>해당 부분들을 변경하고 새로고침하면 블로그의 이름과 설명이 자동으로 변경된다.</p>\n<p><img src=\"/blog/jekyll-theme-and-posting/img/now-github-page-2.png\" alt=\"Blog page updated\"></p>\n<p>기본으로 생성되어 있는 index.html 파일을 열어보면 다음과 같이 머리말이 지정되어있다.</p>\n<pre><code class=\"language-html\">---\nlayout: default\n---\n</code></pre>\n<p>layout으로 default라는 파일을 사용한다는 것인데, <strong>_layout</strong> 폴더의 <strong>default.html</strong> 파일을 보자.</p>\n<pre><code class=\"language-html\">{% raw %}\n&lt;header class=&quot;masthead clearfix&quot;&gt;\n  &lt;a href=&quot;{{ site.baseurl }}/&quot; class=&quot;site-avatar&quot;\n    &gt;&lt;img src=&quot;{{ site.avatar }}&quot;\n  /&gt;&lt;/a&gt;\n  &lt;div class=&quot;site-info&quot;&gt;\n    &lt;h1 class=&quot;site-name&quot;&gt;&lt;a href=&quot;{{ site.baseurl }}/&quot;&gt;{{ site.name }}&lt;/a&gt;&lt;/h1&gt;\n    &lt;p class=&quot;site-description&quot;&gt;{{ site.description }}&lt;/p&gt;\n  &lt;/div&gt;\n  &lt;nav&gt;\n    &lt;a href=&quot;{{ site.baseurl }}/&quot;&gt;Blog&lt;/a&gt;\n    &lt;a href=&quot;{{ site.baseurl }}/about&quot;&gt;About&lt;/a&gt;\n  &lt;/nav&gt;\n&lt;/header&gt;\n</code></pre>\n<p>{{ ... }} 로 둘러싸인 부분은 Liquid 라는 문법으로 쓰여진 것인데, 정적 페이지로 빌드할 때 jekyll이 해당 부분을 변환해준다. <strong>{{ site.name }}</strong> 의 부분은 _config.yml에서 설정했던 <strong>name</strong>에 해당하는 값으로 변환되는 것이다.\n다른 많은 부분들에서도 설정된 변수나 환경에 따라 변환되도록 코딩되어 있어서, 반복되는 작업을 하거나 외부적인 플러그인을 설치하여 쉽게 정적 페이지를 제공할 수 있게 해준다.\n{% endraw %}</p>\n<p><a href=\"https://jekyllrb-ko.github.io/docs/home/\">Jekyll 사용 설명서</a>를 통해서 필요한 기능들을 익혀가야 한다.</p>\n<hr>\n<h2 id=\"3-포스트-작성하기\"><strong>3. 포스트 작성하기</strong></h2>\n<p>Jekyll에서 포스트는 <a href=\"https://daringfireball.net/projects/markdown/\">마크다운</a>으로 작성한다. <strong>_post</strong>폴더에 YYYY-MM-DD-[제목].md 형식으로 파일을 저장하면 자동으로 포스트가 생성된다.</p>\n<p><strong>_posts</strong>에 <em>2019-10-21-Gibhub Pages + Jekyll Blog (1).md</em> 라는 파일을 생성하고 다음과 같이 코드를 추가하였다.</p>\n<pre><code class=\"language-html\">---\nlayout: post\ntitle: Github Pages + Jekyll 기반 블로그 만들기 (1)\nsubtitle: Github Pages 호스팅 및 Jekyll 설치하기\nauthor: Hoontae\ncategories: blog\ntags: blog jekyll\n# image: assets/images/1.jpg\nfeatured: true\nhidden: false\npermalink: &#39;/:categories/:title&#39;\n---\n\n--- Github Pages와 Jekyll을 이용해 블로그 만들기 ---\n</code></pre>\n<p>md파일을 추가하기만 해도 포스트가 생성된다. 블로그 폴더에 /_site/blog/[제목].html 파일이 생성된 것을 볼 수 있다. 설정마다 다르게 생성되는데, 지금은 md파일의 머리말에 permalink 속성으로 /:categories/:title 로 설정해두어 위와 같은 경로로 포스트 파일이 생성된 것이다.</p>\n<p>블로그에 접속해보면 해당 포스트가 생성된 것을 확인할 수 있다.</p>\n<p><img src=\"/blog/jekyll-theme-and-posting/img/now-github-post.png\" alt=\"Blog page updated\"></p>\n<p>몇가지 설정하는 부분은 아직 모르는 부분이 많지만, 마크다운 형식으로 파일을 작성하여 Github 저장소에 Push하기만 하면 쉽게 블로그에 글을 올릴 수 있게 되었다.</p>\n","excerpt":"나만의 블로그를 위해 이미 만들어져 있는 Jekyll Theme를 가져와서 적용해봅니다. 그리고 Markdown으로 블로그의 첫번째 포스트를 쉽게 작성해봅니다. 지난 포스트에서 Github Pages를 이용하여 호스팅하는 블로그를 만들어보았다. 지금은 접속할 수 있는 환경을 만들어 둔 정도다. 이제 Jekyll을 좀 더 제대로 이용하면서 Theme 디자인 및 템플릿을 설정하여 블로그답게 만들 수 있다.  1. Jekyll Theme 가져오기 테마를 적용할 수 있는 방법은 여러가지이다. 아마 제일 쉬운 방법은 테마가","thumbnail":"/blog/jekyll-theme-and-posting/img/github_jekyll.jpg","thumbnailUrl":"https://hoontae24.github.io/blog/jekyll-theme-and-posting/img/github_jekyll.jpg"},{"href":"1","round":1,"paths":["blog","github-pages-and-jekyll"],"slug":"github-pages-and-jekyll","title":"블로그 만들기, Github Pages 호스팅 및 Jekyll 설치","description":"Github Pages와 Jekyll을 이용하여 나만의 블로그를 만들어 보겠습니다. jekyll을 이용하여 정적 사이트 블로그를 만들고, Github pages를 통해 무료로 사이트를 배포합니다.","date":"2019-10-21","category":"blog","tags":["blog","jekyll","github"],"seriesId":1,"markdown":"\n![github and jekyll](/blog/github-pages-and-jekyll/img/github_jekyll.jpg)\n\n개발자로 취업을 준비하면서 포트폴리오를 만들었던 적이 있다. 개발자, 디자이너 등으로 취업하는 분들은 이러한 경험이 있을 것이다. 내가 어떠한 것들을 만들었는지 정리하면서 그것들을 보여주는 것도 나에겐 참 어려운 일이었다.\n\n어찌어찌 신입 개발자로 취업을 하였지만, 마음 한구석에는 두 가지 고민이 계속 있었는데, 하나는 \"개발자로서 어떻게 계속 공부해 나갈 것인가\"였고, 또 하나는 \"내가 공부하고 관심 있는 것들을 정리할 블로그가 있으면 좋겠다\"였다.\n\n미루어 왔던 개발 블로그를 더 늦기 전에 시작해보려 하는데, 어떠한 플랫폼이 좋을지 선택해야 한다. github을 이용하면 로컬에서 쉽게 글을 쓰고 push할 수 있고, jekyll theme을 가져와서 템플릿을 이용할 수 있다.\n(다른 서비스도 좋은 것들이 많지만, 시작과 꾸준함이 제일 중요하니까... 일단 시작해보자.)\n\n_[jekyll 빠른 시작 설명서](https://jekyllrb-ko.github.io/docs/quickstart/)를 참조하였습니다._  \n_(Ruby, Gem이 설치되어 있어야 한다. [Ruby 설치하기](https://jekyllrb-ko.github.io/docs/installation/))_\n\n---\n\n## **1. jekyll, bundler 설치하기**\n\n> Jekyll 은 아주 심플하고 블로그 지향적인 정적 사이트 생성기입니다.\n\nJekyll은 Ruby로 만들어진 정적 사이트 생성기다. 개인적으로 약간 생소하긴 했지만, 초기 설정만 잘 해두면 쉽게 블로그를 만들어 갈 수 있을 것이다.  \nbundler는 \"다른 루비 젬들을 관리하는 루비 젬입니다.\" 라고 나와있는데, 패키지를 관리해주는 녀석인 듯 하다.\n\n콘솔에서 다음과 같이 명령을 입력하여 설치한다.\n\n> $ gem install jekyll bundler\n\n설치가 잘 되었는지 확인해볼 수 있다.\n\n> $ jekyll -v  \n> $ bundler -v\n\n---\n\n## **2. 기본 블로그 구성하기**\n\n이제 기본 블로그 사이트를 만들 수 있다.\n\n> $ jekyll new my-blog-site\n\njekyll이 작업을 마치면 my-blog-site라는 폴더가 생성되고, 기본 파일들이 생성되어 있다.\n\n> $ cd my-blog-site\n\n아직 갖춰진 것은 없지만 블로그가 만들어 졌다. 다음 명령을 통해 로컬에서 미리보기 빌드해 볼 수 있다.\n\n> $ jekyll serve\n\n[http://127.0.0.1:4000/](http://127.0.0.1:4000/) 으로 접속해 볼 수 있다.\n\n![기본 블로그 모습](/blog/github-pages-and-jekyll/img/jekyll_basic.png)\n_(위와 같은 페이지가 나오면 성공)_\n\n---\n\n## **3. github pages에 호스팅하기**\n\n이렇게 생성된 블로그를 꾸미는 것도 중요하지만, github pages를 이용해 호스팅 해야한다. _(git 또는 github에 대해서는 자세히 다루지 않겠습니다.)_\n\n### 1. 호스팅 용 github 저장소 만들기\n\n![깃헙 저장소 만들기](/blog/github-pages-and-jekyll/img/set_github_repository.png)  \n_(Repository name은 반드시 \"[username].github.io\")_  \n_(여기서 [username]은 github의 username과 동일해야 한다)_\n\n### 2. 로컬에서 Git 초기화 및 커밋하기\n\n> $ git init\n\n_(블로그 폴더에 .git 이라는 폴더가 생겼으면 성공)_\n\n> $ git add .  \n> $ git commit -m \"initialize blog\"\n\n> $ git log\n\n_(commit된 목록이 생겼으면 성공)_\n\n### 3. github 원격 저장소 설정 및 push 하기\n\n로컬에서 생성된 저장소를 1에서 만들어둔 깃헙 저장소와 연결해야 한다. github에 만들어둔 저장소 페이지에 보면 clone을 할 수 있도록 \"https://github.com/hoontae24/hoontae24.github.io.git\"와 같은 형식의 주소가 있다. 이것을 복사.\n\n> $ git remote add origin https://github.com/hoontae24/hoontae24.github.io.git  \n> _(git remote add origin [저장소 주소])_\n\n이제 로컬에서 작성된 블로그 파일들을 원격 저장소로 올린다.\n\n> $ git push --set-upstream origin master  \n> _(깃헙 계정과 관련해서 인증과정을 거쳐야 할 수도 있음)_\n\n여기까지 잘 진행되었으면, Github 저장소에 파일이 올라간 것을 확인할 수 있다.\n\n![연결된 깃헙 저장소](/blog/github-pages-and-jekyll/img/github_first_push.png)\n\n---\n\n## **4. 호스팅 된 블로그 확인하기**\n\n이제 자신이 저장소 이름으로 접속해보면 블로그를 확인할 수 있다.  \n~~(내 경우엔 [https://hoontae24.github.io/](https://hoontae24.github.io/), 주소 형식만 참고해주세요. 결과물은 변경되었습니다.)~~\n\n아직은 텅 빈 블로그지만 이제 몇가지 설정만 하면 멀쩡한 블로그가 될 것 같다.\n\n- Github 블로그에 게시글 작성하기\n- Jekyll theme으로 디자인하기\n","html":"<p><img src=\"/blog/github-pages-and-jekyll/img/github_jekyll.jpg\" alt=\"github and jekyll\"></p>\n<p>개발자로 취업을 준비하면서 포트폴리오를 만들었던 적이 있다. 개발자, 디자이너 등으로 취업하는 분들은 이러한 경험이 있을 것이다. 내가 어떠한 것들을 만들었는지 정리하면서 그것들을 보여주는 것도 나에겐 참 어려운 일이었다.</p>\n<p>어찌어찌 신입 개발자로 취업을 하였지만, 마음 한구석에는 두 가지 고민이 계속 있었는데, 하나는 &quot;개발자로서 어떻게 계속 공부해 나갈 것인가&quot;였고, 또 하나는 &quot;내가 공부하고 관심 있는 것들을 정리할 블로그가 있으면 좋겠다&quot;였다.</p>\n<p>미루어 왔던 개발 블로그를 더 늦기 전에 시작해보려 하는데, 어떠한 플랫폼이 좋을지 선택해야 한다. github을 이용하면 로컬에서 쉽게 글을 쓰고 push할 수 있고, jekyll theme을 가져와서 템플릿을 이용할 수 있다.\n(다른 서비스도 좋은 것들이 많지만, 시작과 꾸준함이 제일 중요하니까... 일단 시작해보자.)</p>\n<p><em><a href=\"https://jekyllrb-ko.github.io/docs/quickstart/\">jekyll 빠른 시작 설명서</a>를 참조하였습니다.</em><br><em>(Ruby, Gem이 설치되어 있어야 한다. <a href=\"https://jekyllrb-ko.github.io/docs/installation/\">Ruby 설치하기</a>)</em></p>\n<hr>\n<h2 id=\"1-jekyll-bundler-설치하기\"><strong>1. jekyll, bundler 설치하기</strong></h2>\n<blockquote>\n<p>Jekyll 은 아주 심플하고 블로그 지향적인 정적 사이트 생성기입니다.</p>\n</blockquote>\n<p>Jekyll은 Ruby로 만들어진 정적 사이트 생성기다. 개인적으로 약간 생소하긴 했지만, 초기 설정만 잘 해두면 쉽게 블로그를 만들어 갈 수 있을 것이다.<br>bundler는 &quot;다른 루비 젬들을 관리하는 루비 젬입니다.&quot; 라고 나와있는데, 패키지를 관리해주는 녀석인 듯 하다.</p>\n<p>콘솔에서 다음과 같이 명령을 입력하여 설치한다.</p>\n<blockquote>\n<p>$ gem install jekyll bundler</p>\n</blockquote>\n<p>설치가 잘 되었는지 확인해볼 수 있다.</p>\n<blockquote>\n<p>$ jekyll -v<br>$ bundler -v</p>\n</blockquote>\n<hr>\n<h2 id=\"2-기본-블로그-구성하기\"><strong>2. 기본 블로그 구성하기</strong></h2>\n<p>이제 기본 블로그 사이트를 만들 수 있다.</p>\n<blockquote>\n<p>$ jekyll new my-blog-site</p>\n</blockquote>\n<p>jekyll이 작업을 마치면 my-blog-site라는 폴더가 생성되고, 기본 파일들이 생성되어 있다.</p>\n<blockquote>\n<p>$ cd my-blog-site</p>\n</blockquote>\n<p>아직 갖춰진 것은 없지만 블로그가 만들어 졌다. 다음 명령을 통해 로컬에서 미리보기 빌드해 볼 수 있다.</p>\n<blockquote>\n<p>$ jekyll serve</p>\n</blockquote>\n<p><a href=\"http://127.0.0.1:4000/\">http://127.0.0.1:4000/</a> 으로 접속해 볼 수 있다.</p>\n<p><img src=\"/blog/github-pages-and-jekyll/img/jekyll_basic.png\" alt=\"기본 블로그 모습\">\n<em>(위와 같은 페이지가 나오면 성공)</em></p>\n<hr>\n<h2 id=\"3-github-pages에-호스팅하기\"><strong>3. github pages에 호스팅하기</strong></h2>\n<p>이렇게 생성된 블로그를 꾸미는 것도 중요하지만, github pages를 이용해 호스팅 해야한다. <em>(git 또는 github에 대해서는 자세히 다루지 않겠습니다.)</em></p>\n<h3 id=\"1-호스팅-용-github-저장소-만들기\">1. 호스팅 용 github 저장소 만들기</h3>\n<p><img src=\"/blog/github-pages-and-jekyll/img/set_github_repository.png\" alt=\"깃헙 저장소 만들기\"><br><em>(Repository name은 반드시 &quot;[username].github.io&quot;)</em><br><em>(여기서 [username]은 github의 username과 동일해야 한다)</em></p>\n<h3 id=\"2-로컬에서-git-초기화-및-커밋하기\">2. 로컬에서 Git 초기화 및 커밋하기</h3>\n<blockquote>\n<p>$ git init</p>\n</blockquote>\n<p><em>(블로그 폴더에 .git 이라는 폴더가 생겼으면 성공)</em></p>\n<blockquote>\n<p>$ git add .<br>$ git commit -m &quot;initialize blog&quot;</p>\n</blockquote>\n<blockquote>\n<p>$ git log</p>\n</blockquote>\n<p><em>(commit된 목록이 생겼으면 성공)</em></p>\n<h3 id=\"3-github-원격-저장소-설정-및-push-하기\">3. github 원격 저장소 설정 및 push 하기</h3>\n<p>로컬에서 생성된 저장소를 1에서 만들어둔 깃헙 저장소와 연결해야 한다. github에 만들어둔 저장소 페이지에 보면 clone을 할 수 있도록 &quot;<a href=\"https://github.com/hoontae24/hoontae24.github.io.git&quot;%EC%99%80\">https://github.com/hoontae24/hoontae24.github.io.git&quot;와</a> 같은 형식의 주소가 있다. 이것을 복사.</p>\n<blockquote>\n<p>$ git remote add origin <a href=\"https://github.com/hoontae24/hoontae24.github.io.git\">https://github.com/hoontae24/hoontae24.github.io.git</a><br><em>(git remote add origin [저장소 주소])</em></p>\n</blockquote>\n<p>이제 로컬에서 작성된 블로그 파일들을 원격 저장소로 올린다.</p>\n<blockquote>\n<p>$ git push --set-upstream origin master<br><em>(깃헙 계정과 관련해서 인증과정을 거쳐야 할 수도 있음)</em></p>\n</blockquote>\n<p>여기까지 잘 진행되었으면, Github 저장소에 파일이 올라간 것을 확인할 수 있다.</p>\n<p><img src=\"/blog/github-pages-and-jekyll/img/github_first_push.png\" alt=\"연결된 깃헙 저장소\"></p>\n<hr>\n<h2 id=\"4-호스팅-된-블로그-확인하기\"><strong>4. 호스팅 된 블로그 확인하기</strong></h2>\n<p>이제 자신이 저장소 이름으로 접속해보면 블로그를 확인할 수 있다.<br><del>(내 경우엔 <a href=\"https://hoontae24.github.io/\">https://hoontae24.github.io/</a>, 주소 형식만 참고해주세요. 결과물은 변경되었습니다.)</del></p>\n<p>아직은 텅 빈 블로그지만 이제 몇가지 설정만 하면 멀쩡한 블로그가 될 것 같다.</p>\n<ul>\n<li>Github 블로그에 게시글 작성하기</li>\n<li>Jekyll theme으로 디자인하기</li>\n</ul>\n","excerpt":"Github Pages와 Jekyll을 이용하여 나만의 블로그를 만들어 보겠습니다. jekyll을 이용하여 정적 사이트 블로그를 만들고, Github pages를 통해 무료로 사이트를 배포합니다. 개발자로 취업을 준비하면서 포트폴리오를 만들었던 적이 있다. 개발자, 디자이너 등으로 취업하는 분들은 이러한 경험이 있을 것이다. 내가 어떠한 것들을 만들었는지 정리하면서 그것들을 보여주는 것도 나에겐 참 어려운 일이었다. 어찌어찌 신입 개발자로 취업을 하였지만, 마음 한구석에는 두 가지 고민이 계속 있었는데, 하나는 &quot;개발자로서 어떻게 계속 공부","thumbnail":"/blog/github-pages-and-jekyll/img/github_jekyll.jpg","thumbnailUrl":"https://hoontae24.github.io/blog/github-pages-and-jekyll/img/github_jekyll.jpg"}]}}