{"env":{"BASE_PATH":"","ARTICLES_ROOT":".articles","ARTICLE_FILENAME":"README.md"},"__N_SSG":true,"pageProps":{"post":{"href":"12","round":12,"paths":["react","react-component-rerendering"],"slug":"react-component-rerendering","title":"리액트 컴포넌트 Rerendering 파헤치기","description":"","date":"2020-03-15","category":"react","tags":["react","frontend"],"seriesId":null,"markdown":"\n![react render props](/react/react-component-rerendering/img/react_render_props.png)\n\nReact는 웹 프론트엔드 라이브러리로 많이 사용되어지고 있습니다. 저 역시 리액트를 처음 접하고 업무 프로젝트로 사용한 지 1년 정도가 되었습니다. 라이브러리를 이용하여 개발을 하면 더 편하지만 알아야 할 것도 많이 생깁니다.\n\n리액트로 개발을 할 때, 컴포넌트의 **Rerendering**에 대해 고민하게 될 때가 있는데요. React는 화면의 변경 사항에 대해서 ReactDOM을 이용하여 변경된 부분에 대해서만 Rerendering(또는 Update)합니다. React의 [Lifecycle](https://ko.reactjs.org/docs/react-component.html#the-component-lifecycle)을 이해하면 Rerendering을 잘 고려해서 개발할 수 있습니다.\n\n오늘은 간단한 Phonebook을 구현하면서, ReactDOM의 업데이트를 관찰하고, 컴포넌트의 Rerendering에 대해서 살펴보겠습니다. 특히 불필요한 업데이트를 줄이는 방법에 대해 중점적으로 보려고 합니다.\n\n---\n\n### 0. 개발 환경 구성하기\n\n오늘 실습 개발 환경을 위해서 다음 두 가지가 필요합니다.\n\n1. [CRA(create-react-app)](https://github.com/facebook/create-react-app)\n2. [chrome 확장프로그램 React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)\n\n먼저 CRA를 이용하여 간단한 React App을 만듭니다. 그리고 실습에 사용될 몇가지 패키지를 설치하겠습니다.\n\n```bash\n$ npx create-react-app react-rerendering-test\n$ cd react-rerendering-test\n$ npm i lodash random-name @material-ui/core\n```\n\n`lodash`와 `random-name`은 샘플 데이터를 다루기 위해서 설치합니다. `@material-ui`는 `input`태그를 대신하여 사용할 `TextField`를 위해 설치합니다. 또한 실제 업무에서도 html 태그가 아닌 UI 라이브러리의 컴포넌트를 사용하는 경우가 많으니 실습에 더 도움이 될 것이라 생각합니다.\n\n`App.js`에 템플릿으로 작성되어있는 내용을 모두 지우고 다음과 같이 작성하겠습니다.\n\n```jsx\n// src/App.js\nimport React from \"react\";\nimport PhoneBook from \"./components/phone-book\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div\n        style={ {\n          backgroundColor: \"steelblue\",\n          color: \"white\",\n          marginBottom: 16,\n        } }\n      >\n        <h1\n          style={ {\n            margin: \"auto\",\n            width: \"fit-content\",\n            height: 100,\n            display: \"flex\",\n            alignItems: \"center\",\n          } }\n        >\n          HELLO REACT RENDER\n        </h1>\n      </div>\n      <PhoneBook />\n    </div>\n  );\n}\n```\n\n그리고 `src`폴더 아래에 `components`폴더를 만들고 `phone-book.js`파일을 다음과 같이 작성합니다.\n\n```jsx\n// src/components/phone-book.js\nimport React from \"react\";\nimport lodash from \"lodash\";\nimport randomName from \"random-name\";\nimport { withStyles, Grid, TextField } from \"@material-ui/core\";\n\nconst randomNumber = () => String(Math.floor((Math.random() * 100) % 10));\nconst randomPhone = () => `010-xxxx-xxxx`.replace(/x/g, () => randomNumber());\n\nconst memberCount = 10;\nconst members = lodash\n  .range(memberCount)\n  .map(i => ({ id: i, name: randomName(), phone: randomPhone() }));\n\nclass PhoneBook extends React.Component {\n  state = { members };\n\n  handleChange = e => {\n    const {\n      dataset: { id },\n      name: field,\n      value,\n    } = e.target;\n\n    const members = [...this.state.members];\n    const index = members.findIndex(member => member.id === Number(id));\n    members[index] = { ...members[index], [field]: value };\n\n    this.setState({ members: [...members] });\n  };\n\n  render() {\n    const { classes } = this.props;\n    const { members } = this.state;\n    return (\n      <div className={classes.root}>\n        <h2>PhoneBook</h2>\n        {members.map(member => (\n          <Grid\n            key={member.id}\n            container\n            spacing={2}\n            className={classes.row}\n            alignItems=\"center\"\n          >\n            <Grid item xs={2}>\n              {member.id}\n            </Grid>\n            <Grid item xs={5}>\n              <TextField\n                inputProps={ { \"data-id\": member.id } }\n                label=\"name\"\n                name=\"name\"\n                value={member.name}\n                onChange={this.handleChange}\n              />\n            </Grid>\n            <Grid item xs={5}>\n              <TextField\n                inputProps={ { \"data-id\": member.id } }\n                label=\"phone\"\n                name=\"phone\"\n                value={member.phone}\n                onChange={this.handleChange}\n              />\n            </Grid>\n          </Grid>\n        ))}\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  root: {\n    margin: \"0 200px\",\n  },\n  row: {\n    margin: 16,\n  },\n};\n\nexport default withStyles(styles)(PhoneBook);\n\n```\n\n이제 개발 서버를 실행해보겠습니다. 콘솔에서 `npm run start`로 시작해주세요. 다음과 같은 화면이 표시됩니다. `input`의 값도 잘 변경 됩니다.\n\n![screenshot](/react/react-component-rerendering/img/react-rerendering-test_1.png)\n\n이제 컴포넌트의 변경(Rerendering)을 관찰할 수 있도록 React Developer Tools를 설치하겠습니다.\n\n![react developer tools](/react/react-component-rerendering/img/react-developer-tools.png)\n\n이제 크롬의 개발자 도구를 열고, `Profiler`탭에서 `톱니바퀴 모양(view settings)`을 누르고 `Highlight updates when components render`옵션을 켜줍니다.\n\n![screenshot](/react/react-component-rerendering/img/react-rerendering-test_2.gif)\n\n컴포넌트가 새로 그려질 때 마다 브라우저에 표시됩니다.\n\n---\n\n### 1. 컴포넌트 Rerendering 살펴보기\n\n`PhoneBook` 컴포넌트를 살펴보겠습니다. `members` 배열을 `map`을 통해서 바로 렌더링하고 있습니다. 하나의 `TextField`에서 값을 변경하면 모든 `TextField`가 리렌더링 되는 것을 볼 수 있습니다. 그리고 타이핑을 할 때마다 모든 `TextField`가 리렌더링하느라 버벅임이 발생합니다. `setState`에서 `members`의 값을 변경하면 `PhoneBook` 컴포넌트가 업데이트 되기 때문에 자식 컴포넌트도 업데이트 되는 것입니다. 현재는 10개의 `member`가 있지만 늘어날 수록 더욱 느려질 것입니다.\n\n---\n\n### 2. 자식 컴포넌트 분리하기\n\n하나의 `TextField`가 업데이트 될 때, 다른 컴포넌트는 업데이트 될 필요가 없습니다. 자식 컴포넌트로 분리해서 따로 동작하도록 만들어 보겠습니다.\n\n각 Member 단위로 컴포넌트로 구현하겠습니다. `src/components`폴더에 `form.js`파일을 만들고 다음과 같이 작성하겠습니다.\n\n```jsx\n// src/components/form.js\nimport React from \"react\";\nimport { withStyles, TextField, Grid } from \"@material-ui/core\";\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: \"1px solid lightgray\",\n  },\n};\n\nclass Form extends React.PureComponent {\n  render() {\n    const { classes, member, onChange } = this.props;\n    return (\n      <Grid container spacing={2} className={classes.form}>\n        <Grid item xs={2}>\n          {member.id}\n        </Grid>\n        <Grid item xs={5}>\n          <TextField\n            inputProps={ { \"data-id\": member.id } }\n            name=\"name\"\n            value={member.name}\n            onChange={onChange}\n          />\n        </Grid>\n        <Grid item xs={5}>\n          <TextField\n            inputProps={ { \"data-id\": member.id } }\n            name=\"phone\"\n            value={member.phone}\n            onChange={onChange}\n          />\n        </Grid>\n      </Grid>\n    );\n  }\n}\n\nexport default withStyles(styles)(Form);\n```\n\n이제 `phone-book.js`파일을 수정해줍니다.\n\n```jsx\n// src/components/phone-book.js\nimport React from \"react\";\nimport lodash from \"lodash\";\nimport randomName from \"random-name\";\nimport { withStyles, Grid, TextField } from \"@material-ui/core\";\nimport Form from \"./form\";\n\nconst randomNumber = () => String(Math.floor((Math.random() * 100) % 10));\nconst randomPhone = () => `010-xxxx-xxxx`.replace(/x/g, () => randomNumber());\n\nconst memberCount = 10;\nconst members = lodash\n  .range(memberCount)\n  .map(i => ({ id: i, name: randomName(), phone: randomPhone() }));\n\nclass PhoneBook extends React.Component {\n  state = { members };\n\n  handleChange = e => {\n    const {\n      dataset: { id },\n      name: field,\n      value,\n    } = e.target;\n\n    const members = [...this.state.members];\n    const index = members.findIndex(member => member.id === Number(id));\n    members[index] = { ...members[index], [field]: value };\n\n    this.setState({ members: [...members] });\n  };\n\n  render() {\n    const { classes } = this.props;\n    const { members } = this.state;\n    return (\n      <div className={classes.root}>\n        <h2>PhoneBook</h2>\n        {members.map(member => (\n          <Form key={member.id} member={member} onChange={this.handleChange} />\n        ))}\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  root: {\n    margin: \"0 200px\",\n  },\n  row: {\n    margin: 16,\n  },\n};\n\nexport default withStyles(styles)(PhoneBook);\n```\n\n각 Member를 그리는 부분을 컴포넌트로 분리했습니다. 그리고 자식 컴포넌트로 사용되는 `Form`컴포넌트는 `PureComponent`를 상속받은 컴포넌트입니다. 한번 실행해보겠습니다.\n\n![screenshot](/react/react-component-rerendering/img/react-rerendering-test_3.gif)\n\n`TextField`에 입력을 하면 `PhoneBook`컴포넌트가 업데이트 됩니다. 하지만 자식 컴포넌트인 `Form`컴포넌트는 `props`가 변하는 컴포넌트만 리렌더링이 발생합니다. 버벅임도 사라졌습니다.\n\n---\n\n### 3. React.memo 사용하기\n\n`Form`컴포넌트를 `PureComponent`를 사용하지 않는다면 어떻게 할 수 있을까요? `Form`컴포넌트를 함수형 컴포넌트로 수정해 보겠습니다. 그리고 컴포넌트를 `React.memo`함수로 전달해줍니다.\n\n```jsx\n// src/components/form.js\nimport React from \"react\";\nimport { withStyles, TextField, Grid } from \"@material-ui/core\";\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: \"1px solid lightgray\",\n  },\n};\n\nconst Form = props => {\n  const { classes, member, onChange } = props;\n  return (\n    <Grid container spacing={2} className={classes.form}>\n      <Grid item xs={2}>\n        {member.id}\n      </Grid>\n      <Grid item xs={5}>\n        <TextField\n          inputProps={ { \"data-id\": member.id } }\n          name=\"name\"\n          value={member.name}\n          onChange={onChange}\n        />\n      </Grid>\n      <Grid item xs={5}>\n        <TextField\n          inputProps={ { \"data-id\": member.id } }\n          name=\"phone\"\n          value={member.phone}\n          onChange={onChange}\n        />\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default withStyles(styles)(React.memo(Form));\n```\n\n이렇게 하면 `PureComponent`를 사용하는 것과 같은 효과를 가지게 됩니다. 상태를 가지지 않는 `Form`컴포넌트의 경우에는 함수형 컴포넌트가 작성하기도 쉽고 직관적으로 코드를 작성/파악할 수 있습니다.\n\n---\n\n### 4. 세부 컴포넌트 분리하기\n\n`Form`컴포넌트로 분리했지만 아직 그 안에 두 개의 `TextField`가 있습니다. 지금은 두 개이지만 몇 개가 될 지 보장할 수 없습니다. 그렇다고 `TextField`를 또 다른 컴포넌트로 작성하면 번거로울 수 있습니다. 따로 컴포넌트로 분리하지 않고 `TextField`가 각각의 업데이트에 독립적으로 동작하도록 만들어 봅시다.\n\n`React.useMemo`를 이용하여 코드를 분리시켜보겠습니다. `form.js`를 다음과 같이 수정하겠습니다.\n\n```jsx\n// src/components/form.js\nimport React from \"react\";\nimport { withStyles, TextField, Grid } from \"@material-ui/core\";\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: \"1px solid lightgray\",\n  },\n};\n\nconst Form = props => {\n  const { classes, member, onChange } = props;\n\n  const nameField = React.useMemo(\n    () => (\n      <TextField\n        inputProps={ { \"data-id\": member.id } }\n        name=\"name\"\n        value={member.name}\n        onChange={onChange}\n      />\n    ),\n    [member.name, member.id],\n  );\n\n  const phoneField = React.useMemo(\n    () => (\n      <TextField\n        inputProps={ { \"data-id\": member.id } }\n        name=\"phone\"\n        value={member.phone}\n        onChange={onChange}\n      />\n    ),\n    [member.phone, member.id],\n  );\n\n  return (\n    <Grid container spacing={2} className={classes.form}>\n      <Grid item xs={2}>\n        {member.id}\n      </Grid>\n      <Grid item xs={5}>\n        {nameField}\n      </Grid>\n      <Grid item xs={5}>\n        {phoneField}\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default withStyles(styles)(React.memo(Form));\n```\n\n`TextField`를 사용하는 `name`과 `phone` 부분을 분리했습니다. `React.useMemo`를 이용하여 각각의 필드가 영향을 받는 값에 대해서만 업데이트 되도록 작성했습니다. 동작과 업데이트를 한번 보겠습니다.\n\n![screenshot](/react/react-component-rerendering/img/react-rerendering-test_4.gif)\n\n이제 `Form`컴포넌트 내에서도 각 `TextField`의 업데이트가 서로 영향을 주지 않습니다. 독립적으로 리렌더링 됩니다.\n\n---\n\n### 마무리\n\n오늘은 리액트 컴포넌트가 리렌더링 되는 것과 컴포넌트를 분리해서 불필요한 리렌더링을 방지하는 실습을 해봤습니다. 개발을 하다보면 컴포넌트가 커지고 복잡해질수록 불필요한 프로세스를 줄이고 성능 최적화를 구성하는 것이 어려워집니다. 작은 컴포넌트 단위부터 잘 구성하여서 성능 이슈를 발생시키지 않도록 하는 연습을 많이 해야할 것 같습니다.\n","html":"<p><img src=\"/react/react-component-rerendering/img/react_render_props.png\" alt=\"react render props\"></p>\n<p>React는 웹 프론트엔드 라이브러리로 많이 사용되어지고 있습니다. 저 역시 리액트를 처음 접하고 업무 프로젝트로 사용한 지 1년 정도가 되었습니다. 라이브러리를 이용하여 개발을 하면 더 편하지만 알아야 할 것도 많이 생깁니다.</p>\n<p>리액트로 개발을 할 때, 컴포넌트의 <strong>Rerendering</strong>에 대해 고민하게 될 때가 있는데요. React는 화면의 변경 사항에 대해서 ReactDOM을 이용하여 변경된 부분에 대해서만 Rerendering(또는 Update)합니다. React의 <a href=\"https://ko.reactjs.org/docs/react-component.html#the-component-lifecycle\">Lifecycle</a>을 이해하면 Rerendering을 잘 고려해서 개발할 수 있습니다.</p>\n<p>오늘은 간단한 Phonebook을 구현하면서, ReactDOM의 업데이트를 관찰하고, 컴포넌트의 Rerendering에 대해서 살펴보겠습니다. 특히 불필요한 업데이트를 줄이는 방법에 대해 중점적으로 보려고 합니다.</p>\n<hr>\n<h3 id=\"0-개발-환경-구성하기\">0. 개발 환경 구성하기</h3>\n<p>오늘 실습 개발 환경을 위해서 다음 두 가지가 필요합니다.</p>\n<ol>\n<li><a href=\"https://github.com/facebook/create-react-app\">CRA(create-react-app)</a></li>\n<li><a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\">chrome 확장프로그램 React Developer Tools</a></li>\n</ol>\n<p>먼저 CRA를 이용하여 간단한 React App을 만듭니다. 그리고 실습에 사용될 몇가지 패키지를 설치하겠습니다.</p>\n<pre><code class=\"language-bash\">$ npx create-react-app react-rerendering-test\n$ cd react-rerendering-test\n$ npm i lodash random-name @material-ui/core\n</code></pre>\n<p><code>lodash</code>와 <code>random-name</code>은 샘플 데이터를 다루기 위해서 설치합니다. <code>@material-ui</code>는 <code>input</code>태그를 대신하여 사용할 <code>TextField</code>를 위해 설치합니다. 또한 실제 업무에서도 html 태그가 아닌 UI 라이브러리의 컴포넌트를 사용하는 경우가 많으니 실습에 더 도움이 될 것이라 생각합니다.</p>\n<p><code>App.js</code>에 템플릿으로 작성되어있는 내용을 모두 지우고 다음과 같이 작성하겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/App.js\nimport React from &quot;react&quot;;\nimport PhoneBook from &quot;./components/phone-book&quot;;\n\nfunction App() {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;div\n        style={ {\n          backgroundColor: &quot;steelblue&quot;,\n          color: &quot;white&quot;,\n          marginBottom: 16,\n        } }\n      &gt;\n        &lt;h1\n          style={ {\n            margin: &quot;auto&quot;,\n            width: &quot;fit-content&quot;,\n            height: 100,\n            display: &quot;flex&quot;,\n            alignItems: &quot;center&quot;,\n          } }\n        &gt;\n          HELLO REACT RENDER\n        &lt;/h1&gt;\n      &lt;/div&gt;\n      &lt;PhoneBook /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>그리고 <code>src</code>폴더 아래에 <code>components</code>폴더를 만들고 <code>phone-book.js</code>파일을 다음과 같이 작성합니다.</p>\n<pre><code class=\"language-jsx\">// src/components/phone-book.js\nimport React from &quot;react&quot;;\nimport lodash from &quot;lodash&quot;;\nimport randomName from &quot;random-name&quot;;\nimport { withStyles, Grid, TextField } from &quot;@material-ui/core&quot;;\n\nconst randomNumber = () =&gt; String(Math.floor((Math.random() * 100) % 10));\nconst randomPhone = () =&gt; `010-xxxx-xxxx`.replace(/x/g, () =&gt; randomNumber());\n\nconst memberCount = 10;\nconst members = lodash\n  .range(memberCount)\n  .map(i =&gt; ({ id: i, name: randomName(), phone: randomPhone() }));\n\nclass PhoneBook extends React.Component {\n  state = { members };\n\n  handleChange = e =&gt; {\n    const {\n      dataset: { id },\n      name: field,\n      value,\n    } = e.target;\n\n    const members = [...this.state.members];\n    const index = members.findIndex(member =&gt; member.id === Number(id));\n    members[index] = { ...members[index], [field]: value };\n\n    this.setState({ members: [...members] });\n  };\n\n  render() {\n    const { classes } = this.props;\n    const { members } = this.state;\n    return (\n      &lt;div className={classes.root}&gt;\n        &lt;h2&gt;PhoneBook&lt;/h2&gt;\n        {members.map(member =&gt; (\n          &lt;Grid\n            key={member.id}\n            container\n            spacing={2}\n            className={classes.row}\n            alignItems=&quot;center&quot;\n          &gt;\n            &lt;Grid item xs={2}&gt;\n              {member.id}\n            &lt;/Grid&gt;\n            &lt;Grid item xs={5}&gt;\n              &lt;TextField\n                inputProps={ { &quot;data-id&quot;: member.id } }\n                label=&quot;name&quot;\n                name=&quot;name&quot;\n                value={member.name}\n                onChange={this.handleChange}\n              /&gt;\n            &lt;/Grid&gt;\n            &lt;Grid item xs={5}&gt;\n              &lt;TextField\n                inputProps={ { &quot;data-id&quot;: member.id } }\n                label=&quot;phone&quot;\n                name=&quot;phone&quot;\n                value={member.phone}\n                onChange={this.handleChange}\n              /&gt;\n            &lt;/Grid&gt;\n          &lt;/Grid&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n}\n\nconst styles = {\n  root: {\n    margin: &quot;0 200px&quot;,\n  },\n  row: {\n    margin: 16,\n  },\n};\n\nexport default withStyles(styles)(PhoneBook);\n</code></pre>\n<p>이제 개발 서버를 실행해보겠습니다. 콘솔에서 <code>npm run start</code>로 시작해주세요. 다음과 같은 화면이 표시됩니다. <code>input</code>의 값도 잘 변경 됩니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-rerendering-test_1.png\" alt=\"screenshot\"></p>\n<p>이제 컴포넌트의 변경(Rerendering)을 관찰할 수 있도록 React Developer Tools를 설치하겠습니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-developer-tools.png\" alt=\"react developer tools\"></p>\n<p>이제 크롬의 개발자 도구를 열고, <code>Profiler</code>탭에서 <code>톱니바퀴 모양(view settings)</code>을 누르고 <code>Highlight updates when components render</code>옵션을 켜줍니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-rerendering-test_2.gif\" alt=\"screenshot\"></p>\n<p>컴포넌트가 새로 그려질 때 마다 브라우저에 표시됩니다.</p>\n<hr>\n<h3 id=\"1-컴포넌트-rerendering-살펴보기\">1. 컴포넌트 Rerendering 살펴보기</h3>\n<p><code>PhoneBook</code> 컴포넌트를 살펴보겠습니다. <code>members</code> 배열을 <code>map</code>을 통해서 바로 렌더링하고 있습니다. 하나의 <code>TextField</code>에서 값을 변경하면 모든 <code>TextField</code>가 리렌더링 되는 것을 볼 수 있습니다. 그리고 타이핑을 할 때마다 모든 <code>TextField</code>가 리렌더링하느라 버벅임이 발생합니다. <code>setState</code>에서 <code>members</code>의 값을 변경하면 <code>PhoneBook</code> 컴포넌트가 업데이트 되기 때문에 자식 컴포넌트도 업데이트 되는 것입니다. 현재는 10개의 <code>member</code>가 있지만 늘어날 수록 더욱 느려질 것입니다.</p>\n<hr>\n<h3 id=\"2-자식-컴포넌트-분리하기\">2. 자식 컴포넌트 분리하기</h3>\n<p>하나의 <code>TextField</code>가 업데이트 될 때, 다른 컴포넌트는 업데이트 될 필요가 없습니다. 자식 컴포넌트로 분리해서 따로 동작하도록 만들어 보겠습니다.</p>\n<p>각 Member 단위로 컴포넌트로 구현하겠습니다. <code>src/components</code>폴더에 <code>form.js</code>파일을 만들고 다음과 같이 작성하겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/components/form.js\nimport React from &quot;react&quot;;\nimport { withStyles, TextField, Grid } from &quot;@material-ui/core&quot;;\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: &quot;1px solid lightgray&quot;,\n  },\n};\n\nclass Form extends React.PureComponent {\n  render() {\n    const { classes, member, onChange } = this.props;\n    return (\n      &lt;Grid container spacing={2} className={classes.form}&gt;\n        &lt;Grid item xs={2}&gt;\n          {member.id}\n        &lt;/Grid&gt;\n        &lt;Grid item xs={5}&gt;\n          &lt;TextField\n            inputProps={ { &quot;data-id&quot;: member.id } }\n            name=&quot;name&quot;\n            value={member.name}\n            onChange={onChange}\n          /&gt;\n        &lt;/Grid&gt;\n        &lt;Grid item xs={5}&gt;\n          &lt;TextField\n            inputProps={ { &quot;data-id&quot;: member.id } }\n            name=&quot;phone&quot;\n            value={member.phone}\n            onChange={onChange}\n          /&gt;\n        &lt;/Grid&gt;\n      &lt;/Grid&gt;\n    );\n  }\n}\n\nexport default withStyles(styles)(Form);\n</code></pre>\n<p>이제 <code>phone-book.js</code>파일을 수정해줍니다.</p>\n<pre><code class=\"language-jsx\">// src/components/phone-book.js\nimport React from &quot;react&quot;;\nimport lodash from &quot;lodash&quot;;\nimport randomName from &quot;random-name&quot;;\nimport { withStyles, Grid, TextField } from &quot;@material-ui/core&quot;;\nimport Form from &quot;./form&quot;;\n\nconst randomNumber = () =&gt; String(Math.floor((Math.random() * 100) % 10));\nconst randomPhone = () =&gt; `010-xxxx-xxxx`.replace(/x/g, () =&gt; randomNumber());\n\nconst memberCount = 10;\nconst members = lodash\n  .range(memberCount)\n  .map(i =&gt; ({ id: i, name: randomName(), phone: randomPhone() }));\n\nclass PhoneBook extends React.Component {\n  state = { members };\n\n  handleChange = e =&gt; {\n    const {\n      dataset: { id },\n      name: field,\n      value,\n    } = e.target;\n\n    const members = [...this.state.members];\n    const index = members.findIndex(member =&gt; member.id === Number(id));\n    members[index] = { ...members[index], [field]: value };\n\n    this.setState({ members: [...members] });\n  };\n\n  render() {\n    const { classes } = this.props;\n    const { members } = this.state;\n    return (\n      &lt;div className={classes.root}&gt;\n        &lt;h2&gt;PhoneBook&lt;/h2&gt;\n        {members.map(member =&gt; (\n          &lt;Form key={member.id} member={member} onChange={this.handleChange} /&gt;\n        ))}\n      &lt;/div&gt;\n    );\n  }\n}\n\nconst styles = {\n  root: {\n    margin: &quot;0 200px&quot;,\n  },\n  row: {\n    margin: 16,\n  },\n};\n\nexport default withStyles(styles)(PhoneBook);\n</code></pre>\n<p>각 Member를 그리는 부분을 컴포넌트로 분리했습니다. 그리고 자식 컴포넌트로 사용되는 <code>Form</code>컴포넌트는 <code>PureComponent</code>를 상속받은 컴포넌트입니다. 한번 실행해보겠습니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-rerendering-test_3.gif\" alt=\"screenshot\"></p>\n<p><code>TextField</code>에 입력을 하면 <code>PhoneBook</code>컴포넌트가 업데이트 됩니다. 하지만 자식 컴포넌트인 <code>Form</code>컴포넌트는 <code>props</code>가 변하는 컴포넌트만 리렌더링이 발생합니다. 버벅임도 사라졌습니다.</p>\n<hr>\n<h3 id=\"3-reactmemo-사용하기\">3. React.memo 사용하기</h3>\n<p><code>Form</code>컴포넌트를 <code>PureComponent</code>를 사용하지 않는다면 어떻게 할 수 있을까요? <code>Form</code>컴포넌트를 함수형 컴포넌트로 수정해 보겠습니다. 그리고 컴포넌트를 <code>React.memo</code>함수로 전달해줍니다.</p>\n<pre><code class=\"language-jsx\">// src/components/form.js\nimport React from &quot;react&quot;;\nimport { withStyles, TextField, Grid } from &quot;@material-ui/core&quot;;\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: &quot;1px solid lightgray&quot;,\n  },\n};\n\nconst Form = props =&gt; {\n  const { classes, member, onChange } = props;\n  return (\n    &lt;Grid container spacing={2} className={classes.form}&gt;\n      &lt;Grid item xs={2}&gt;\n        {member.id}\n      &lt;/Grid&gt;\n      &lt;Grid item xs={5}&gt;\n        &lt;TextField\n          inputProps={ { &quot;data-id&quot;: member.id } }\n          name=&quot;name&quot;\n          value={member.name}\n          onChange={onChange}\n        /&gt;\n      &lt;/Grid&gt;\n      &lt;Grid item xs={5}&gt;\n        &lt;TextField\n          inputProps={ { &quot;data-id&quot;: member.id } }\n          name=&quot;phone&quot;\n          value={member.phone}\n          onChange={onChange}\n        /&gt;\n      &lt;/Grid&gt;\n    &lt;/Grid&gt;\n  );\n};\n\nexport default withStyles(styles)(React.memo(Form));\n</code></pre>\n<p>이렇게 하면 <code>PureComponent</code>를 사용하는 것과 같은 효과를 가지게 됩니다. 상태를 가지지 않는 <code>Form</code>컴포넌트의 경우에는 함수형 컴포넌트가 작성하기도 쉽고 직관적으로 코드를 작성/파악할 수 있습니다.</p>\n<hr>\n<h3 id=\"4-세부-컴포넌트-분리하기\">4. 세부 컴포넌트 분리하기</h3>\n<p><code>Form</code>컴포넌트로 분리했지만 아직 그 안에 두 개의 <code>TextField</code>가 있습니다. 지금은 두 개이지만 몇 개가 될 지 보장할 수 없습니다. 그렇다고 <code>TextField</code>를 또 다른 컴포넌트로 작성하면 번거로울 수 있습니다. 따로 컴포넌트로 분리하지 않고 <code>TextField</code>가 각각의 업데이트에 독립적으로 동작하도록 만들어 봅시다.</p>\n<p><code>React.useMemo</code>를 이용하여 코드를 분리시켜보겠습니다. <code>form.js</code>를 다음과 같이 수정하겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/components/form.js\nimport React from &quot;react&quot;;\nimport { withStyles, TextField, Grid } from &quot;@material-ui/core&quot;;\n\nconst styles = {\n  form: {\n    padding: 8,\n    border: &quot;1px solid lightgray&quot;,\n  },\n};\n\nconst Form = props =&gt; {\n  const { classes, member, onChange } = props;\n\n  const nameField = React.useMemo(\n    () =&gt; (\n      &lt;TextField\n        inputProps={ { &quot;data-id&quot;: member.id } }\n        name=&quot;name&quot;\n        value={member.name}\n        onChange={onChange}\n      /&gt;\n    ),\n    [member.name, member.id],\n  );\n\n  const phoneField = React.useMemo(\n    () =&gt; (\n      &lt;TextField\n        inputProps={ { &quot;data-id&quot;: member.id } }\n        name=&quot;phone&quot;\n        value={member.phone}\n        onChange={onChange}\n      /&gt;\n    ),\n    [member.phone, member.id],\n  );\n\n  return (\n    &lt;Grid container spacing={2} className={classes.form}&gt;\n      &lt;Grid item xs={2}&gt;\n        {member.id}\n      &lt;/Grid&gt;\n      &lt;Grid item xs={5}&gt;\n        {nameField}\n      &lt;/Grid&gt;\n      &lt;Grid item xs={5}&gt;\n        {phoneField}\n      &lt;/Grid&gt;\n    &lt;/Grid&gt;\n  );\n};\n\nexport default withStyles(styles)(React.memo(Form));\n</code></pre>\n<p><code>TextField</code>를 사용하는 <code>name</code>과 <code>phone</code> 부분을 분리했습니다. <code>React.useMemo</code>를 이용하여 각각의 필드가 영향을 받는 값에 대해서만 업데이트 되도록 작성했습니다. 동작과 업데이트를 한번 보겠습니다.</p>\n<p><img src=\"/react/react-component-rerendering/img/react-rerendering-test_4.gif\" alt=\"screenshot\"></p>\n<p>이제 <code>Form</code>컴포넌트 내에서도 각 <code>TextField</code>의 업데이트가 서로 영향을 주지 않습니다. 독립적으로 리렌더링 됩니다.</p>\n<hr>\n<h3 id=\"마무리\">마무리</h3>\n<p>오늘은 리액트 컴포넌트가 리렌더링 되는 것과 컴포넌트를 분리해서 불필요한 리렌더링을 방지하는 실습을 해봤습니다. 개발을 하다보면 컴포넌트가 커지고 복잡해질수록 불필요한 프로세스를 줄이고 성능 최적화를 구성하는 것이 어려워집니다. 작은 컴포넌트 단위부터 잘 구성하여서 성능 이슈를 발생시키지 않도록 하는 연습을 많이 해야할 것 같습니다.</p>\n","excerpt":" React는 웹 프론트엔드 라이브러리로 많이 사용되어지고 있습니다. 저 역시 리액트를 처음 접하고 업무 프로젝트로 사용한 지 1년 정도가 되었습니다. 라이브러리를 이용하여 개발을 하면 더 편하지만 알아야 할 것도 많이 생깁니다. 리액트로 개발을 할 때, 컴포넌트의 Rerendering에 대해 고민하게 될 때가 있는데요. React는 화면의 변경 사항에 대해","thumbnail":"/react/react-component-rerendering/img/react_render_props.png","thumbnailUrl":"https://hoontae24.github.io/react/react-component-rerendering/img/react_render_props.png"},"url":"https://hoontae24.github.io/12"}}