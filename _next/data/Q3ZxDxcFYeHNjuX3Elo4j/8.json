{"env":{"BASE_PATH":"","ARTICLES_ROOT":".articles","ARTICLE_FILENAME":"README.md"},"__N_SSG":true,"pageProps":{"post":{"href":"8","round":8,"paths":["react","react-mobx-action"],"slug":"react-mobx-action","title":"Mobx의 상태 변화, Action을 알아보자(feat. 비동기 Action)","description":"","date":"2020-01-30","category":"react","tags":["mobx","react"],"seriesId":null,"markdown":"\n![mobx](/react/react-mobx-action/img/mobx.png)\n\nMobx는 리액트에서 사용되어지는 상태 관리 라이브러리입니다. 리액트 자체적으로 state나 useState를 이용해서 상태 관리를 할 수 있지만, 전역적인 상태나 반응적인 변화를 위해서 Mobx와 같은 외부 라이브러리를 사용하기도 합니다.\n\n`Mobx`에서 상태 변화를 일으키는 것을 `Action`이라고 합니다. 이 글에서는 `리액트`에서 `Action`을 사용하는 것과 `비동기` 작업에서는 어떻게 사용해야할 지 살펴보겠습니다.\n\n_(이 글에서는 `Mobx`에 대한 주요 개념이나 사용법을 다루지 않습니다.)_\n\n[참조] 이 글을 작성하면서 아래의 글에 도움을 받았습니다.\n\n- [Mobx와 비동기 작업 - React - BYSEOP's devlog](https://byseop.netlify.com/mobx-async/)\n- [MobX (2) 리액트 프로젝트에서 MobX 사용하기 - velog](https://velog.io/@velopert/MobX-2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-MobX-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-oejltas52z)\n\n---\n\n### 1. 작업 환경 구성\n\n먼저 리액트와 Mobx를 사용할 수 있는 환경을 구성하겠습니다. 작업 순서는 다음과 같습니다.\n\n1. create-react-app으로 리액트 프로젝트 생성\n2. 프로젝트 eject 및 decorator 사용 환경 구성\n3. mobx 설치 및 실습\n\n먼저 create-react-app을 이용해 실습 프로젝트를 생성합니다.\n\n```bash\n$ npx create-react-app mobx-async-action --use-npm\n```\n\n`--use-npm` 옵션은 `yarn` 대신에 `npm`을 사용하기 위한 옵션입니다. 하지 않아도 상관없습니다.\n\n```bash\n$ cd mobx-async-action\n$ npm run eject # eject에 대한 confirm 질문이 나오면 y 입력\n```\n\n`eject` 명령어를 이용해 `webpack`설정을 커스텀할 수 있게 만듭니다. 그리고 `decorator`를 사용할 수 있도록 babel 설정을 해줍니다.\n\n```bash\n$ npm i @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators\n```\n\n이제 `package.json`을 열고 babel 설정을 다음과 같이 수정합니다.\n\n```json\n\"babel\": {\n    \"presets\": [\n      \"react-app\"\n    ],\n    \"plugins\": [\n      [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }],\n      [\"@babel/plugin-proposal-class-properties\", { \"loose\": true }]\n    ]\n  }\n```\n\n혹시 vscode에서 데코레이터 때문에 오류가 발생하면, 프로젝트 폴더에 `jsconfig.json`파일을 만들고 다음 코드를 추가해주세요.\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n이제 실습 대상 라이브러리인 `mobx`를 설치합니다.\n\n```bash\n$ npm i mobx mobx-react\n```\n\n이제 환경 설정이 끝났습니다. 설정이 잘 동작하는지 개발 서버를 구동시켜서 확인해 보겠습니다.\n\n```bash\n$ npm start\n```\n\n![개발 서버 스크린샷](/react/react-mobx-action/img/mobx-async-action-ss-1.png)\n\n이제 CRA를 통해 만든 프로젝트에서 필요 없는 부분을 삭제해주겠습니다.\n\n`src`폴더에서 `index.css`, `logo.svg`, `App.css`, `App.test.js` 파일은 지우고, `index.js`와 `App.js`파일을 수정해줍니다.\n\n```jsx\n// src/index.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n```\n\n```jsx\n// src/App.js\nimport React, { Component } from 'react'\n\nclass App extends Component {\n  render() {\n    return (\n      <div className='App'>\n        <h1>mobx-async-action</h1>\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n---\n\n### 2. Mobx Action 살펴보기\n\n먼저 `mobx`의 `observable` 변수를 선언해주고, 변수에 `reaction`을 걸어두겠습니다. 그리고 간단히 값을 변경시키는 버튼과 로직을 만들겠습니다.\n\n```jsx\n// src/App.js\nimport React, { Component } from 'react'\nimport { observable, reaction } from 'mobx'\nimport { observer } from 'mobx-react'\n\n@observer\nclass App extends Component {\n  @observable number1 = 0\n  @observable number2 = 0\n\n  constructor(props) {\n    super(props)\n    reaction(\n      () => [this.number1, this.number2],\n      ([number1, number2]) => console.log('Reaction:', number1, number2),\n    )\n  }\n\n  componentDidUpdate() {\n    console.log('Updated:', this.number1, this.number2)\n  }\n\n  handleClick = () => {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }\n\n  getRandomNumber = () => Math.ceil(Math.random() * 10)\n\n  render() {\n    return (\n      <div className='App'>\n        <h1>mobx-async-action</h1>\n        <h5>number1: {this.number1}</h5>\n        <h5>number2: {this.number2}</h5>\n        <button onClick={this.handleClick}>random</button>\n      </div>\n    )\n  }\n}\n\nexport default App\n```\n\n`App`컴포넌트는 `number1`과 `number2`라는 상태를 가지고 있고, 버튼을 클릭하면 두 상태 변수에 랜덤한 값이 저장됩니다. 상태가 변경되면 콘솔에 `Reaction:` 으로 출력되도록 `reaction`을 만들어 두었고, 컴포넌트가 변경되면 `Updated:`로 콘솔에 출력됩니다.\n\n먼저 `random`버튼을 클릭해보겠습니다.\n\n제 경우에는 다음과 같이 출력되었습니다.\n\n```output\n# output\nReaction: 2 0\nReaction: 2 1\nUpdated: 2 1\n```\n\n출력을 분석해보면 두 개의 상태 변수가 변경될 때 각각의 `Action`이 총 2번 발생되고, `Action`이 끝나면 컴포넌트가 업데이트 되는 것을 알 수 있습니다.\n\n그렇다면 비동기 상황에서는 어떻게 동작할까요? `handleClick`메소드에 `setTimeout`으로 비동기적 상황을 만들어 보겠습니다.\n\n```jsx\n// src/App.js\nhandleClick = () => {\n  // 1초 후에 number의 값이 변하는 동작\n  setTimeout(() => {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }, 1000)\n}\n```\n\n```output\n# output\nReaction: 4 0\nUpdated: 4 0\nReaction: 4 6\nUpdated: 4 6\n```\n\n`setTimeout`함수를 이용해서 1초 후에 값이 변하는 `Action`을 실행시켜보았습니다. 아까와 같이 2번의 `Action`이 발생하였고, 이번에는 `Updated` 또한 2번이 발생했습니다.\n\n`mobx`에서는 이러한 상태 변화를 하나로 묶는 `action`함수를 제공합니다. 데코레이터를 사용해서 `handleClick`메소드를 `action`으로 감싸보겠습니다.\n\n```js\n// src/App.js\nimport { observable, reaction, action } from 'mobx'\n\n// 데코레이터를 이용해 mobx의 action으로 handleClick 메소드를 감싸줌\n@action\nhandleClick = () => {\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n```\n\n```output\n# output\nReaction: 5 9\nUpdated: 5 9\n```\n\n실행되는 메소드를 `action`으로 감싸주니 두 변수의 상태가 변했음에도 한번의 `Action`만 발생하는 것을 볼 수 있습니다. 또한 `mobx`의 `action`으로 감싸주면 개발자도구를 통해 변화의 정보를 추적할 수 있습니다.\n\n이번에는 하나의 함수 안에서 `action`으로 감싼 함수를 호출해보도록 하겠습니다.\n\n```js\n// src/App.js\nhandleClick = () => {\n  this.setNumber1()\n  this.setNumber2()\n}\n\n@action setNumber1 = () => (this.number1 = this.getRandomNumber())\n@action setNumber2 = () => (this.number2 = this.getRandomNumber())\n```\n\n```output\n# output\nReaction: 3 0\nReaction: 3 3\nUpdated: 3 3\n```\n\n`action`으로 감싼 함수를 각각 호출해보니 독립적으로 `Action`이 발생했습니다. 다시 `handleClick`메소드에 `action`을 감싸봅시다.\n\n```js\n// src/App.js\n@action\nhandleClick = () => {\n  this.setNumber1()\n  this.setNumber2()\n}\n\n@action setNumber1 = () => (this.number1 = this.getRandomNumber())\n@action setNumber2 = () => (this.number2 = this.getRandomNumber())\n```\n\n```output\n# output\nReaction: 5 3\nUpdated: 5 3\n```\n\n`action`을 감싸주니 독립된 `Action`을 하나로 묶어 동작하게 됩니다. 또한 `setNumber1`과 `setNumber2`에 `@action`을 제거하더라도 하나의 `Action`으로 묶여 동작하는 것을 볼 수 있습니다.\n\n이번에는 `action`내에서 비동기 동작을 관찰해 보겠습니다.\n\n```js\n// src/App.js\n@action\nhandleClick = () => {\n  setTimeout(() => {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }, 1000)\n}\n```\n\n```output\n# output\nReaction: 1 0\nUpdated: 1 0\nReaction: 1 4\nUpdated: 1 4\n```\n\n동작하는 함수에 `action`을 적용시켰음에도 전혀 그렇지 않은 것처럼 동작합니다. mobx 문서에서는 다음과 같이 말합니다.\n\n> _The action wrapper / decorator only affects the currently running function, not functions that are scheduled (but not invoked) by the current function!_\n\n`action`으로 감싸주더라도 그 영향은 현재 실행 중인 함수 내에만 적용됩니다. `setTimeout` 또는 `Promise.then`, `async`함수 등 새롭게 호출되는 함수의 동작에 대해서는 `action`의 기능을 적용받을 수 없습니다.\n\n---\n\n### 3. 비동기 작업의 Action 다루기\n\nmobx에서 이러한 비동기 작업에서 `Action`을 처리하기 위해서는 새로운 `action`을 적용해야 합니다. mobx 문서에서 다루고 있는 방법들을 살펴보겠습니다.\n\n#### 3-1. 다른 action으로 감싸기\n\n비동기 작업에서의 `Action`이 발생하는 부분을 다른 `action`으로 감싸주도록 하겠습니다.\n\n```js\n// src/App.js\n// @action\nhandleClick = () => {\n  setTimeout(() => {\n    this.setNumbers()\n  }, 1000)\n}\n\n@action\nsetNumbers = () => {\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n```\n\n이렇게 비동기 작업 자체를 `action`으로 감싸 새로운 함수로 만들 수 있습니다. 만약 메인으로 호출하는 `handleClick`메소드에 `Action`이 발생할 일이 없다면 `@action`을 제거해도 됩니다.\n\n데코레이터를 이용하지 않고 `action`을 감싸주는 방법도 있습니다.\n\n```js\n// src/App.js\n@action\nhandleClick = () => {\n  setTimeout(\n    action('setNumbersAsync1', () => {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    }),\n    1000,\n  )\n\n  Promise.resolve().then(\n    action('setNumbersAsync2', () => {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    }),\n  )\n}\n```\n\n데코레이터를 사용하지 않고 `action`으로 감싸면서 새로운 함수를 생성합니다. `action`으로 생성된 `setNumbersAsync`함수가 실행 로직이 아니라 `setTimeout`과 `Promise.then`의 콜백함수 자리를 대신하고 있습니다.\n\n#### 3-2. runInAction 사용하기\n\n비동기 작업이 있을 때마다 `action`으로 감싸주거나, 새로운 함수를 선언하는 것은 약간 귀찮은 일이 될 수도 있습니다. mobx는 `runInAction`함수를 통해 실행 로직에서 직관성을 잃지 않고 `Action`을 발생 시킬 수 있게합니다.\n\n```js\n// src/App.js\n@action\nhandleClick = () => {\n  Promise.resolve().then(() => {\n    runInAction(() => {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    })\n  })\n}\n```\n\n`runInAction`함수의 첫번째 인자로 익명의 함수를 넘겨줍니다. `runInAction`은 인자로 받은 함수를 즉시 실행하며 `Action`을 묶어주게 됩니다.\n\n#### 3-3. async/await\n\n만약 비동기 작업을 호출하는 함수가 `async`함수라면 `await`이 실행된 후에는 `action`의 적용되지 않습니다. `await` 이후의 코드 블록에서 `상태 변화`가 발생한다면 `runInAction`으로 감싸주어야 합니다.\n\n```js\n@action\nhandleClick = async () => {\n  await Promise.resolve()\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n```\n\n```output\n# output\nReaction: 3 0\nUpdated: 3 0\nReaction: 3 7\nUpdated: 3 7\n```\n\n```js\n@action\nhandleClick = async () => {\n  await Promise.resolve()\n  runInAction(() => {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  })\n}\n```\n\n```output\n# output\nReaction: 8 3\nUpdated: 8 3\n```\n\n#### 3-4 flow\n\n`flow`를 사용하면 코드는 가장 깔끔하고 직관적이게 작성할 수 있습니다. 하지만 약간 다른 방법으로 비동기 작업을 제어합니다. `async/await`와 비슷하지만 `function *` 제너레이터를 사용합니다. `await` 대신에 제너레이터의 `yield`를 사용합니다. `runInAction`과 같은 새로운 `Action`을 감싸 줄 필요가 없어집니다.\n\n```js\nconstructor(props) {\n    super(props)\n    // flow 내에서 this를 사용하기 위해 바인딩\n    this.handleClick = this.handleClick.bind(this)\n}\n\nhandleClick = flow(function*() {\n  yield Promise.resolve()\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n})\n```\n\n---\n\n### 마무리\n\n지금까지 mobx의 상태 변화 Action을 다루는 법을 살펴보았습니다. 상태 변화를 감지하여 `Action`이 발생할 때, 여러 번의 `Action`을 하나로 묶어주어 상태 변화를 잘 처리할 수 있도록 여러 가지 방법을 살펴보았습니다.\n\n특히 비동기 작업에서의 `Action` 적용은 컴포넌트의 업데이트에도 영향을 주기 때문에, 직관적이고 보기 좋은 코드를 작성할 뿐만 아니라, 컴포넌트 라이프 사이클을 이해하고 `Action`과 함께 잘 다루는 법을 익혀야 할 것 같습니다.\n","html":"<p><img src=\"/react/react-mobx-action/img/mobx.png\" alt=\"mobx\"></p>\n<p>Mobx는 리액트에서 사용되어지는 상태 관리 라이브러리입니다. 리액트 자체적으로 state나 useState를 이용해서 상태 관리를 할 수 있지만, 전역적인 상태나 반응적인 변화를 위해서 Mobx와 같은 외부 라이브러리를 사용하기도 합니다.</p>\n<p><code>Mobx</code>에서 상태 변화를 일으키는 것을 <code>Action</code>이라고 합니다. 이 글에서는 <code>리액트</code>에서 <code>Action</code>을 사용하는 것과 <code>비동기</code> 작업에서는 어떻게 사용해야할 지 살펴보겠습니다.</p>\n<p><em>(이 글에서는 <code>Mobx</code>에 대한 주요 개념이나 사용법을 다루지 않습니다.)</em></p>\n<p>[참조] 이 글을 작성하면서 아래의 글에 도움을 받았습니다.</p>\n<ul>\n<li><a href=\"https://byseop.netlify.com/mobx-async/\">Mobx와 비동기 작업 - React - BYSEOP&#39;s devlog</a></li>\n<li><a href=\"https://velog.io/@velopert/MobX-2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-MobX-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-oejltas52z\">MobX (2) 리액트 프로젝트에서 MobX 사용하기 - velog</a></li>\n</ul>\n<hr>\n<h3 id=\"1-작업-환경-구성\">1. 작업 환경 구성</h3>\n<p>먼저 리액트와 Mobx를 사용할 수 있는 환경을 구성하겠습니다. 작업 순서는 다음과 같습니다.</p>\n<ol>\n<li>create-react-app으로 리액트 프로젝트 생성</li>\n<li>프로젝트 eject 및 decorator 사용 환경 구성</li>\n<li>mobx 설치 및 실습</li>\n</ol>\n<p>먼저 create-react-app을 이용해 실습 프로젝트를 생성합니다.</p>\n<pre><code class=\"language-bash\">$ npx create-react-app mobx-async-action --use-npm\n</code></pre>\n<p><code>--use-npm</code> 옵션은 <code>yarn</code> 대신에 <code>npm</code>을 사용하기 위한 옵션입니다. 하지 않아도 상관없습니다.</p>\n<pre><code class=\"language-bash\">$ cd mobx-async-action\n$ npm run eject # eject에 대한 confirm 질문이 나오면 y 입력\n</code></pre>\n<p><code>eject</code> 명령어를 이용해 <code>webpack</code>설정을 커스텀할 수 있게 만듭니다. 그리고 <code>decorator</code>를 사용할 수 있도록 babel 설정을 해줍니다.</p>\n<pre><code class=\"language-bash\">$ npm i @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators\n</code></pre>\n<p>이제 <code>package.json</code>을 열고 babel 설정을 다음과 같이 수정합니다.</p>\n<pre><code class=\"language-json\">&quot;babel&quot;: {\n    &quot;presets&quot;: [\n      &quot;react-app&quot;\n    ],\n    &quot;plugins&quot;: [\n      [&quot;@babel/plugin-proposal-decorators&quot;, { &quot;legacy&quot;: true }],\n      [&quot;@babel/plugin-proposal-class-properties&quot;, { &quot;loose&quot;: true }]\n    ]\n  }\n</code></pre>\n<p>혹시 vscode에서 데코레이터 때문에 오류가 발생하면, 프로젝트 폴더에 <code>jsconfig.json</code>파일을 만들고 다음 코드를 추가해주세요.</p>\n<pre><code class=\"language-json\">{\n  &quot;compilerOptions&quot;: {\n    &quot;experimentalDecorators&quot;: true\n  }\n}\n</code></pre>\n<p>이제 실습 대상 라이브러리인 <code>mobx</code>를 설치합니다.</p>\n<pre><code class=\"language-bash\">$ npm i mobx mobx-react\n</code></pre>\n<p>이제 환경 설정이 끝났습니다. 설정이 잘 동작하는지 개발 서버를 구동시켜서 확인해 보겠습니다.</p>\n<pre><code class=\"language-bash\">$ npm start\n</code></pre>\n<p><img src=\"/react/react-mobx-action/img/mobx-async-action-ss-1.png\" alt=\"개발 서버 스크린샷\"></p>\n<p>이제 CRA를 통해 만든 프로젝트에서 필요 없는 부분을 삭제해주겠습니다.</p>\n<p><code>src</code>폴더에서 <code>index.css</code>, <code>logo.svg</code>, <code>App.css</code>, <code>App.test.js</code> 파일은 지우고, <code>index.js</code>와 <code>App.js</code>파일을 수정해줍니다.</p>\n<pre><code class=\"language-jsx\">// src/index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport App from &#39;./App&#39;\nimport * as serviceWorker from &#39;./serviceWorker&#39;\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n</code></pre>\n<pre><code class=\"language-jsx\">// src/App.js\nimport React, { Component } from &#39;react&#39;\n\nclass App extends Component {\n  render() {\n    return (\n      &lt;div className=&#39;App&#39;&gt;\n        &lt;h1&gt;mobx-async-action&lt;/h1&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<hr>\n<h3 id=\"2-mobx-action-살펴보기\">2. Mobx Action 살펴보기</h3>\n<p>먼저 <code>mobx</code>의 <code>observable</code> 변수를 선언해주고, 변수에 <code>reaction</code>을 걸어두겠습니다. 그리고 간단히 값을 변경시키는 버튼과 로직을 만들겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/App.js\nimport React, { Component } from &#39;react&#39;\nimport { observable, reaction } from &#39;mobx&#39;\nimport { observer } from &#39;mobx-react&#39;\n\n@observer\nclass App extends Component {\n  @observable number1 = 0\n  @observable number2 = 0\n\n  constructor(props) {\n    super(props)\n    reaction(\n      () =&gt; [this.number1, this.number2],\n      ([number1, number2]) =&gt; console.log(&#39;Reaction:&#39;, number1, number2),\n    )\n  }\n\n  componentDidUpdate() {\n    console.log(&#39;Updated:&#39;, this.number1, this.number2)\n  }\n\n  handleClick = () =&gt; {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }\n\n  getRandomNumber = () =&gt; Math.ceil(Math.random() * 10)\n\n  render() {\n    return (\n      &lt;div className=&#39;App&#39;&gt;\n        &lt;h1&gt;mobx-async-action&lt;/h1&gt;\n        &lt;h5&gt;number1: {this.number1}&lt;/h5&gt;\n        &lt;h5&gt;number2: {this.number2}&lt;/h5&gt;\n        &lt;button onClick={this.handleClick}&gt;random&lt;/button&gt;\n      &lt;/div&gt;\n    )\n  }\n}\n\nexport default App\n</code></pre>\n<p><code>App</code>컴포넌트는 <code>number1</code>과 <code>number2</code>라는 상태를 가지고 있고, 버튼을 클릭하면 두 상태 변수에 랜덤한 값이 저장됩니다. 상태가 변경되면 콘솔에 <code>Reaction:</code> 으로 출력되도록 <code>reaction</code>을 만들어 두었고, 컴포넌트가 변경되면 <code>Updated:</code>로 콘솔에 출력됩니다.</p>\n<p>먼저 <code>random</code>버튼을 클릭해보겠습니다.</p>\n<p>제 경우에는 다음과 같이 출력되었습니다.</p>\n<pre><code class=\"language-output\"># output\nReaction: 2 0\nReaction: 2 1\nUpdated: 2 1\n</code></pre>\n<p>출력을 분석해보면 두 개의 상태 변수가 변경될 때 각각의 <code>Action</code>이 총 2번 발생되고, <code>Action</code>이 끝나면 컴포넌트가 업데이트 되는 것을 알 수 있습니다.</p>\n<p>그렇다면 비동기 상황에서는 어떻게 동작할까요? <code>handleClick</code>메소드에 <code>setTimeout</code>으로 비동기적 상황을 만들어 보겠습니다.</p>\n<pre><code class=\"language-jsx\">// src/App.js\nhandleClick = () =&gt; {\n  // 1초 후에 number의 값이 변하는 동작\n  setTimeout(() =&gt; {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }, 1000)\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 4 0\nUpdated: 4 0\nReaction: 4 6\nUpdated: 4 6\n</code></pre>\n<p><code>setTimeout</code>함수를 이용해서 1초 후에 값이 변하는 <code>Action</code>을 실행시켜보았습니다. 아까와 같이 2번의 <code>Action</code>이 발생하였고, 이번에는 <code>Updated</code> 또한 2번이 발생했습니다.</p>\n<p><code>mobx</code>에서는 이러한 상태 변화를 하나로 묶는 <code>action</code>함수를 제공합니다. 데코레이터를 사용해서 <code>handleClick</code>메소드를 <code>action</code>으로 감싸보겠습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\nimport { observable, reaction, action } from &#39;mobx&#39;\n\n// 데코레이터를 이용해 mobx의 action으로 handleClick 메소드를 감싸줌\n@action\nhandleClick = () =&gt; {\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 5 9\nUpdated: 5 9\n</code></pre>\n<p>실행되는 메소드를 <code>action</code>으로 감싸주니 두 변수의 상태가 변했음에도 한번의 <code>Action</code>만 발생하는 것을 볼 수 있습니다. 또한 <code>mobx</code>의 <code>action</code>으로 감싸주면 개발자도구를 통해 변화의 정보를 추적할 수 있습니다.</p>\n<p>이번에는 하나의 함수 안에서 <code>action</code>으로 감싼 함수를 호출해보도록 하겠습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\nhandleClick = () =&gt; {\n  this.setNumber1()\n  this.setNumber2()\n}\n\n@action setNumber1 = () =&gt; (this.number1 = this.getRandomNumber())\n@action setNumber2 = () =&gt; (this.number2 = this.getRandomNumber())\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 3 0\nReaction: 3 3\nUpdated: 3 3\n</code></pre>\n<p><code>action</code>으로 감싼 함수를 각각 호출해보니 독립적으로 <code>Action</code>이 발생했습니다. 다시 <code>handleClick</code>메소드에 <code>action</code>을 감싸봅시다.</p>\n<pre><code class=\"language-js\">// src/App.js\n@action\nhandleClick = () =&gt; {\n  this.setNumber1()\n  this.setNumber2()\n}\n\n@action setNumber1 = () =&gt; (this.number1 = this.getRandomNumber())\n@action setNumber2 = () =&gt; (this.number2 = this.getRandomNumber())\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 5 3\nUpdated: 5 3\n</code></pre>\n<p><code>action</code>을 감싸주니 독립된 <code>Action</code>을 하나로 묶어 동작하게 됩니다. 또한 <code>setNumber1</code>과 <code>setNumber2</code>에 <code>@action</code>을 제거하더라도 하나의 <code>Action</code>으로 묶여 동작하는 것을 볼 수 있습니다.</p>\n<p>이번에는 <code>action</code>내에서 비동기 동작을 관찰해 보겠습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\n@action\nhandleClick = () =&gt; {\n  setTimeout(() =&gt; {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  }, 1000)\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 1 0\nUpdated: 1 0\nReaction: 1 4\nUpdated: 1 4\n</code></pre>\n<p>동작하는 함수에 <code>action</code>을 적용시켰음에도 전혀 그렇지 않은 것처럼 동작합니다. mobx 문서에서는 다음과 같이 말합니다.</p>\n<blockquote>\n<p><em>The action wrapper / decorator only affects the currently running function, not functions that are scheduled (but not invoked) by the current function!</em></p>\n</blockquote>\n<p><code>action</code>으로 감싸주더라도 그 영향은 현재 실행 중인 함수 내에만 적용됩니다. <code>setTimeout</code> 또는 <code>Promise.then</code>, <code>async</code>함수 등 새롭게 호출되는 함수의 동작에 대해서는 <code>action</code>의 기능을 적용받을 수 없습니다.</p>\n<hr>\n<h3 id=\"3-비동기-작업의-action-다루기\">3. 비동기 작업의 Action 다루기</h3>\n<p>mobx에서 이러한 비동기 작업에서 <code>Action</code>을 처리하기 위해서는 새로운 <code>action</code>을 적용해야 합니다. mobx 문서에서 다루고 있는 방법들을 살펴보겠습니다.</p>\n<h4 id=\"3-1-다른-action으로-감싸기\">3-1. 다른 action으로 감싸기</h4>\n<p>비동기 작업에서의 <code>Action</code>이 발생하는 부분을 다른 <code>action</code>으로 감싸주도록 하겠습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\n// @action\nhandleClick = () =&gt; {\n  setTimeout(() =&gt; {\n    this.setNumbers()\n  }, 1000)\n}\n\n@action\nsetNumbers = () =&gt; {\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n</code></pre>\n<p>이렇게 비동기 작업 자체를 <code>action</code>으로 감싸 새로운 함수로 만들 수 있습니다. 만약 메인으로 호출하는 <code>handleClick</code>메소드에 <code>Action</code>이 발생할 일이 없다면 <code>@action</code>을 제거해도 됩니다.</p>\n<p>데코레이터를 이용하지 않고 <code>action</code>을 감싸주는 방법도 있습니다.</p>\n<pre><code class=\"language-js\">// src/App.js\n@action\nhandleClick = () =&gt; {\n  setTimeout(\n    action(&#39;setNumbersAsync1&#39;, () =&gt; {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    }),\n    1000,\n  )\n\n  Promise.resolve().then(\n    action(&#39;setNumbersAsync2&#39;, () =&gt; {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    }),\n  )\n}\n</code></pre>\n<p>데코레이터를 사용하지 않고 <code>action</code>으로 감싸면서 새로운 함수를 생성합니다. <code>action</code>으로 생성된 <code>setNumbersAsync</code>함수가 실행 로직이 아니라 <code>setTimeout</code>과 <code>Promise.then</code>의 콜백함수 자리를 대신하고 있습니다.</p>\n<h4 id=\"3-2-runinaction-사용하기\">3-2. runInAction 사용하기</h4>\n<p>비동기 작업이 있을 때마다 <code>action</code>으로 감싸주거나, 새로운 함수를 선언하는 것은 약간 귀찮은 일이 될 수도 있습니다. mobx는 <code>runInAction</code>함수를 통해 실행 로직에서 직관성을 잃지 않고 <code>Action</code>을 발생 시킬 수 있게합니다.</p>\n<pre><code class=\"language-js\">// src/App.js\n@action\nhandleClick = () =&gt; {\n  Promise.resolve().then(() =&gt; {\n    runInAction(() =&gt; {\n      this.number1 = this.getRandomNumber()\n      this.number2 = this.getRandomNumber()\n    })\n  })\n}\n</code></pre>\n<p><code>runInAction</code>함수의 첫번째 인자로 익명의 함수를 넘겨줍니다. <code>runInAction</code>은 인자로 받은 함수를 즉시 실행하며 <code>Action</code>을 묶어주게 됩니다.</p>\n<h4 id=\"3-3-asyncawait\">3-3. async/await</h4>\n<p>만약 비동기 작업을 호출하는 함수가 <code>async</code>함수라면 <code>await</code>이 실행된 후에는 <code>action</code>의 적용되지 않습니다. <code>await</code> 이후의 코드 블록에서 <code>상태 변화</code>가 발생한다면 <code>runInAction</code>으로 감싸주어야 합니다.</p>\n<pre><code class=\"language-js\">@action\nhandleClick = async () =&gt; {\n  await Promise.resolve()\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 3 0\nUpdated: 3 0\nReaction: 3 7\nUpdated: 3 7\n</code></pre>\n<pre><code class=\"language-js\">@action\nhandleClick = async () =&gt; {\n  await Promise.resolve()\n  runInAction(() =&gt; {\n    this.number1 = this.getRandomNumber()\n    this.number2 = this.getRandomNumber()\n  })\n}\n</code></pre>\n<pre><code class=\"language-output\"># output\nReaction: 8 3\nUpdated: 8 3\n</code></pre>\n<h4 id=\"3-4-flow\">3-4 flow</h4>\n<p><code>flow</code>를 사용하면 코드는 가장 깔끔하고 직관적이게 작성할 수 있습니다. 하지만 약간 다른 방법으로 비동기 작업을 제어합니다. <code>async/await</code>와 비슷하지만 <code>function *</code> 제너레이터를 사용합니다. <code>await</code> 대신에 제너레이터의 <code>yield</code>를 사용합니다. <code>runInAction</code>과 같은 새로운 <code>Action</code>을 감싸 줄 필요가 없어집니다.</p>\n<pre><code class=\"language-js\">constructor(props) {\n    super(props)\n    // flow 내에서 this를 사용하기 위해 바인딩\n    this.handleClick = this.handleClick.bind(this)\n}\n\nhandleClick = flow(function*() {\n  yield Promise.resolve()\n  this.number1 = this.getRandomNumber()\n  this.number2 = this.getRandomNumber()\n})\n</code></pre>\n<hr>\n<h3 id=\"마무리\">마무리</h3>\n<p>지금까지 mobx의 상태 변화 Action을 다루는 법을 살펴보았습니다. 상태 변화를 감지하여 <code>Action</code>이 발생할 때, 여러 번의 <code>Action</code>을 하나로 묶어주어 상태 변화를 잘 처리할 수 있도록 여러 가지 방법을 살펴보았습니다.</p>\n<p>특히 비동기 작업에서의 <code>Action</code> 적용은 컴포넌트의 업데이트에도 영향을 주기 때문에, 직관적이고 보기 좋은 코드를 작성할 뿐만 아니라, 컴포넌트 라이프 사이클을 이해하고 <code>Action</code>과 함께 잘 다루는 법을 익혀야 할 것 같습니다.</p>\n","excerpt":" Mobx는 리액트에서 사용되어지는 상태 관리 라이브러리입니다. 리액트 자체적으로 state나 useState를 이용해서 상태 관리를 할 수 있지만, 전역적인 상태나 반응적인 변화를 위해서 Mobx와 같은 외부 라이브러리를 사용하기도 합니다. Mobx에서 상태 변화를 일으키는 것을 Action이라고 합니다. 이 글에서는 리액트에서 Action을 사용하는 것과","thumbnail":"/react/react-mobx-action/img/mobx.png","thumbnailUrl":"https://hoontae24.github.io/react/react-mobx-action/img/mobx.png"},"url":"https://hoontae24.github.io/8"}}